grammar org.abs_models.xtext.Abs hidden(WS,ML_COMMENT,SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate abs "http://www.abs_models.org/xtext/Abs"

CompilationUnit
    : {CompilationUnit} (module+=ModuleDecl)*
    ;

ModuleDecl
    : 'module' name=QualifiedTypeIdentifier ';'
        (modeExportImports+=ModuleExportImport)*
        (decls+=Decl)*
        (mainBlock=Block)?
    ;

ModuleExportImport
    : ModuleExport
    | ModuleImport
    ;

ModuleExport
    : 'export' (hasStar?='*' 'from' module=QualifiedTypeIdentifier
        | names+=AnyIdentifier (',' names+=AnyIdentifier)*)
        ('from' module=QualifiedTypeIdentifier)?
        ';'
    ;

ModuleImport
    : 'import' (hasStar?='*' 'from' module=QualifiedTypeIdentifier
        | names+=AnyIdentifier (',' names+=AnyIdentifier)* 'from' module=QualifiedTypeIdentifier
        | names+=AnyIdentifier (',' names+=AnyIdentifier)*)
        ';'
    ;


// Annotations

AnnotationFragment: (l=TYPE_IDENTIFIER ':')? r=PureExp ;

Annotations: ( '[' a+=AnnotationFragment (',' a+=AnnotationFragment) ']')* ;

// Declarations

Decl
    : DataTypeDecl
    | TypeSynonymDecl
    | ExceptionDecl
    | FunctionDecl
    | PartialFunctionDecl
    | InterfaceDecl
    | ClassDecl
    // | TraitDecl
    ;

DataTypeDecl
    : ann=Annotations 'data' name=TYPE_IDENTIFIER
        ('<' typeparam+=TYPE_IDENTIFIER (',' typeparam+=TYPE_IDENTIFIER) '>')?
        ('=' constructors+=DataConstructorDecl ('|' constructors+=DataConstructorDecl))?
        ';'
    ;

DataConstructorDecl : name=TYPE_IDENTIFIER ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ;

DataConstructorParamDecl : type=TypeUse (name=IDENTIFIER)? ;

TypeSynonymDecl : ann=Annotations 'type' name=TYPE_IDENTIFIER '=' type=TypeUse ';' ;

ExceptionDecl
    : ann=Annotations 'exception' name=TYPE_IDENTIFIER
        ('(' args+=DataConstructorParamDecl (',' args+=DataConstructorParamDecl)* ')')? ';'
    ;

FunctionDecl
    : ann=Annotations 'def' type=TypeUse name=IDENTIFIER
        ('<' typeparam+=TYPE_IDENTIFIER (',' typeparam+=TYPE_IDENTIFIER) '>')?
        '(' args+=ParamDecl (',' args+=ParamDecl)* ')'
        '=' (isBuiltin?='builtin' | body=PureExp)
        ';'
    ;

PartialFunctionDecl
    : ann=Annotations 'def' type=TypeUse name=IDENTIFIER
        ('<' typeparam+=TYPE_IDENTIFIER (',' typeparam+=TYPE_IDENTIFIER) '>')?
        '(' function_args+=IDENTIFIER (',' function_args+=IDENTIFIER)* ')'
        '(' args+=ParamDecl (',' args+=ParamDecl)* ')'
        '=' body=PureExp
        ';'
    ;

InterfaceDecl
    : ann=Annotations 'interface' name=TYPE_IDENTIFIER
        ('extends' extends+=QualifiedTypeIdentifier (',' extends+=QualifiedTypeIdentifier))?
        '{' (methods+=MethodSignature)* '}'
    ;

MethodSignature
    : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        '(' args+=ParamDecl (',' args+=ParamDecl)* ')'
        ';'
    ;

ClassDecl
    : ann=Annotations 'class' name=TYPE_IDENTIFIER
        ( '(' args+=ParamDecl (',' args+=ParamDecl)* ')' )?
        ( 'implements' implements+=QualifiedTypeIdentifier (',' implements+=QualifiedTypeIdentifier)* )?
        '{'
        (fields+=FieldDecl)*
        ( hasRecoverBlock?='recover' '{' (recoverbranches+=CaseStmtBranch)* '}' )?
        // (traits+=TraitUsage)*
        (methods+=MethodDecl)*
        '}'
    ;

FieldDecl
    : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        (hasInit?='=' init=Exp)? ';'
    ;

MethodDecl
    : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER
        '(' args+=ParamDecl (',' args+=ParamDecl)* ')'
        '{' (statements+=Stmt)* '}'
    ;

ParamDecl : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ;

// Statements

Stmt
    : VarDeclStmt
    | AssignStmt
    | SkipStmt
    | ReturnStmt
    | AssertStmt
    | Block
    | IfStmt
    | WhileStmt
    | ForeachStmt
    | TryCatchFinallyStmt
    | AwaitStmt
    | SuspendStmt
    | DurationStmt
    | ThrowStmt
    | DieStmt
    | MoveCogToStmt
    | ExpStmt
    | CaseStmt
    ;

VarDeclStmt : ann=Annotations type=TypeUseNoAnnotations name=IDENTIFIER ( hasInit?='=' init=Exp )? ';' ;

AssignStmt : ann=Annotations lhs=VarOrFieldExp '=' exp=Exp ';' ;

SkipStmt : ann=Annotations 'skip' ';' ;

ReturnStmt : ann=Annotations 'return' exp=Exp ';' ;

AssertStmt : ann=Annotations 'assert' exp=Exp ';' ;

Block : ann=Annotations '{' (stmt+=Stmt)* '}' ;

IfStmt : ann=Annotations 'if' '(' condition=PureExp ')' consequence=Stmt (=>'else' alternate=Stmt) ;

WhileStmt : ann=Annotations 'while' '(' condition=PureExp ')' body=Stmt ;

ForeachStmt : ann=Annotations 'foreach' '(' var=IDENTIFIER 'in' list=PureExp ')' body=Stmt ;

TryCatchFinallyStmt
    : ann=Annotations
        'try' body=Stmt
        'catch' (( '{' (branches+=CaseStmtBranch)* '}') | branches+=CaseStmtBranch)
        ('finally' finally=Stmt)?
    ;

AwaitStmt : ann=Annotations 'await' guard=Guard ';' ;

Guard : SingleGuard ({Guard.left=current} '&' right=SingleGuard)* ;

SingleGuard returns Guard
    : ClaimGuard
    | DurationGuard
    | ExpGuard
    ;

ClaimGuard returns Guard : exp=VarOrFieldExp '?' ;

DurationGuard returns Guard :  'duration' '(' min=PureExp ',' max=PureExp ')' ;

ExpGuard returns Guard : exp=PureExp ;

SuspendStmt : ann=Annotations 'suspend' ';' ;

DurationStmt : ann=Annotations 'duration' '(' min=PureExp ',' max=PureExp ')' ;

ThrowStmt : ann=Annotations 'throw' exception=PureExp ';' ;

DieStmt : ann=Annotations 'die' exception=PureExp ';' ;

MoveCogToStmt : ann=Annotations 'movecogto' target=PureExp ';' ;

ExpStmt : ann=Annotations exp=Exp ';' ;

CaseStmt : ann=Annotations 'case' condition=PureExp '{' (branches+=CaseStmtBranch)* '}' ;

CaseStmtBranch : p=Pattern '=>' body=PureExp ';' ;

// Expressions

// KLUDGE: the expression grammar fragment is not LL(2) (although
// PureExp by itself is) -- we turned on backtracking in
// `GenerateAbs.mwe2' for now.
Exp
    : PureExp
    | EffExp
    ;

EffExp
    : GetExp
    | NewExp
    | SyncCallExp
    | AsyncCallExp
    | AwaitAsyncCallExp
    | OriginalCallExp
    ;

GetExp : future=PureExp '.get' ;

NewExp : 'new' hasLocal?='local' c=QualifiedTypeIdentifier '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

SyncCallExp : o=PureExp '.' m=IDENTIFIER '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

AsyncCallExp : o=PureExp '!' m=IDENTIFIER '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

AwaitAsyncCallExp : 'await' o=PureExp '!' m=IDENTIFIER '('  args+=PureExp ( ',' args+=PureExp)* ')' ;

OriginalCallExp : (( d=TYPE_IDENTIFIER | c?='core' ) '.')? 'original' '(' args+=PureExp ( ',' args+=PureExp)* ')' ;

PureExp
    : FunctionAppExp
    | VariadicFunctionAppExp
    | PartialFunctionAppExp
    | ConstructorAppExp
    | TemplateStringExp
    | LetExp
    | IfExp
    | CaseExp
    | OperatorExp
    ;

FunctionAppExp
    : name=QualifiedIdentifier '(' args+=PureExp ( ',' args+=PureExp)* ')'
    ;

VariadicFunctionAppExp
    : name=QualifiedIdentifier '[' args+=PureExp ( ',' args+=PureExp)* ']'
    ;

PartialFunctionAppExp
    : name=QualifiedIdentifier
        '(' fnargs+=PartialFunctionParam (',' fnargs+=PartialFunctionParam )* ')'
        '(' args+=PureExp ( ',' args+=PureExp)* ')'
    ;

PartialFunctionParam
    : name=QualifiedIdentifier
    | '(' params+=ParamDecl (',' params+=ParamDecl)* ')' "=>" body=PureExp
    ;

ConstructorAppExp
    : name=QualifiedTypeIdentifier ( '(' args+=PureExp ( ',' args+=PureExp)* ')' )?
    ;

TemplateStringExp
    : {TemplateStringExp} TEMPLATESTRINGLITERAL
    | TEMPLATESTRINGSTART e1=PureExp
        (b+=TEMPLATESTRINGINBETWEEN e+=PureExp)*
        TEMPLATESTRINGEND
    ;


LetExp
    : 'let' '(' param+=ParamDecl ')' '=' e+=PureExp
        (',' '(' param+=ParamDecl ')' '=' e+=PureExp)*
        'in' body=PureExp
    ;

IfExp
    : 'if' condition=PureExp 'then' consequence=PureExp 'else' alternate=PureExp
    ;

CaseExp
    : 'case' c=PureExp '{' (casebranch+=CaseExpBranch)* '}'
    ;

CaseExpBranch
    : p=Pattern '=>' e=PureExp ';'
    ;

Pattern
    : {WildcardPattern} '_'
    | {IntLiteralPattern} value=INTLITERAL
    | {StringLiteralPatern} value=STRINGLITERAL
    | {FloatLiteralPattern} value=FloatLiteral
    | {VariablePattern} value=IDENTIFIER
    | {ConstructorPattern} name=QualifiedTypeIdentifier ( '(' args+=Pattern (',' args+=Pattern)* ')' )?
    ;


// See http://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions

OperatorExp returns PureExp
    : body=OrExp (op=('implements' | 'as') i=QualifiedTypeIdentifier )?
    ;

OrExp returns PureExp
    : AndExp ({OrExp.left=current} '||' right=AndExp)*
    ; // left-assoc

AndExp returns PureExp
    : EqExp ({AndExp.left=current} '&&' right=EqExp)*
    ; // left-assoc

EqExp returns PureExp
    : CompareExp ({EqExp.left=current} op=('==' | '!=') right=CompareExp)?
    ; // non-assoc

CompareExp returns PureExp
    : PlusMinusExp ({CompareExp.left=current} op=('<' | '>' | '<=' | '>=') right=PlusMinusExp)?
    ; // non-assoc

PlusMinusExp returns PureExp
    : MulDivModExp ({PlusMinusExp.left=current} op=('+' | '-') right=MulDivModExp)*
    ; // left-assoc

MulDivModExp returns PureExp
    : UnaryExp ({MulDivExp.left=current} op=('*' | '/' | '%') right=UnaryExp)*
    ; // left-assoc

UnaryExp returns PureExp
    : '(' PureExp ')'
    | op=('!' | '-' | '+') body=UnaryExp
    | AtomicExp
    ;

AtomicExp returns PureExp
    : {IntLiteral} INTLITERAL
    | FloatLiteral
    | {StringLiteral} STRINGLITERAL
    | VarOrFieldExp
    | {ThisExp} 'this'
    | {NullLiteral} 'null'
    ;

VarOrFieldExp returns PureExp
    : (hasThis?='this' '.')? name=IDENTIFIER
    ;

// Types

TypeUse : ann=Annotations type=TypeUseNoAnnotations ;

// We use TypeUseNoAnnotations for parameters and methods so
// annotations are parsed as part of the method / parameter, not its
// type.
TypeUseNoAnnotations
    : name=QualifiedTypeIdentifier ('<' param+=TypeUse (param+=TypeUse)* '>')?
    ;

// Terminals

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal fragment SMALLLETTER : 'a'..'z' ;
terminal fragment CAPITALLETTER : 'A'..'Z' ;

terminal DIGIT : '0'..'9' ;

INTLITERAL returns ecore::EInt : DIGIT+ ;

// "Note: It is generally not a good idea to implement floating point literals
// with terminal rules. You should use data type rules instead due to possible
// shadowing problems explained above."
// https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html
FloatLiteral returns ecore::EFloat
    : INTLITERAL? '.' DIGIT+ (('e' | 'E' | 'e+' | 'E+' | 'e-' | 'E-') DIGIT+)?
    ;

terminal STRINGLITERAL
    : '"' ( '\\' ('"' | '\\' | 't' | 'n' | 'r') | !('"' | '\\'))* '"'
    ;

terminal fragment TEMPLATESTRING_INNER
    : '\\' ('`' | '$')
    | !('`' | '$')
    ;

terminal TEMPLATESTRINGLITERAL : '`' TEMPLATESTRING_INNER* '`' ;

terminal TEMPLATESTRINGSTART
    : '`' TEMPLATESTRING_INNER* '$'
    ;

terminal TEMPLATESTRINGINBETWEEN
    : '$' TEMPLATESTRING_INNER* '$'
    ;
terminal TEMPLATESTRINGEND
    : '$' TEMPLATESTRING_INNER* '`'
    ;


terminal IDENTIFIER : SMALLLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

terminal TYPE_IDENTIFIER : CAPITALLETTER (CAPITALLETTER|SMALLLETTER|'_'|DIGIT)* ;

QualifiedIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* IDENTIFIER ;
QualifiedTypeIdentifier returns ecore::EString : (TYPE_IDENTIFIER '.')* TYPE_IDENTIFIER ;

AnyIdentifier returns ecore::EString
    : QualifiedIdentifier
    | QualifiedTypeIdentifier
    ;

// Local Variables:
// mode: antlr
// End:
