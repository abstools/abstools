// -*- mode: java; tab-width: 4; -*-

import java.io.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicBoolean;

import org.abs_models.backend.java.*;
import org.abs_models.backend.java.codegeneration.*;
import org.abs_models.backend.java.lib.runtime.*;
import org.abs_models.backend.java.lib.expr.*;
import org.abs_models.backend.java.lib.types.*;
import org.abs_models.frontend.ast.*;
import org.abs_models.frontend.typechecker.locationtypes.LocationTypeExtension;
import org.abs_models.frontend.typechecker.locationtypes.LocationType;
import org.apfloat.Apint;
import org.apfloat.Aprational;

aspect GenerateJava {

    public boolean Model.includeDebug = true;

    public void Model.generateJavaCode(JavaCode code, boolean includeDebug) throws IOException, JavaCodeGenerationException {
        this.includeDebug = includeDebug;
        JavaGeneratorHelper.createGenFolder(code);
        for (ModuleDecl decl : getModuleDecls()) {
            try {
                decl.generateJavaCode(code);
            } catch (NotImplementedYetException e) {
                throw new JavaCodeGenerationException("Module " + decl.getName() + ":" + e.getLocalizedMessage(),e);
            } catch (RuntimeException e) {
                throw new JavaCodeGenerationException("Module " + decl.getName() + ":" + e.getLocalizedMessage(),e);
            }
        }
        code.writeOntology(this);
    }


    // Provide easy access to the Java package that is generated for each ModuleDecl
    private JavaCode.Package ModuleDecl.generatedJavaPackage = null;
    public JavaCode.Package ModuleDecl.getJavaPackage() throws JavaCodeGenerationException {
        if (generatedJavaPackage != null)
            return generatedJavaPackage;
        else
            throw new JavaCodeGenerationException("A Java Package is not yet associated with this ModuleDecl (this only happens upon code generation).");
    }

    public void ModuleDecl.generateJavaCode(JavaCode code) throws IOException, JavaCodeGenerationException {
        String packageName = getName();
        this.generatedJavaPackage = code.createPackage(packageName);

        for (Decl decl : getDecls()) {
            decl.generateJavaCode(generatedJavaPackage);
        }

        if (hasBlock()) {
            Block block = getBlock();

            String mainName = JavaBackend.getJavaNameForMainBlock();
            generatedJavaPackage.addMainClass(mainName);
            File file = generatedJavaPackage.createJavaFile(mainName);
            try (PrintStream stream = JavaCodeStream.from(file)) {
                stream.println("package " + generatedJavaPackage.packageName + ";");
                //stream.println(JavaBackendConstants.LIB_IMPORT_STATEMENT);

                stream.println("public class " + mainName + " extends " + ABSObject.class.getName() + " {");
                stream.println("public static void main(java.lang.String[] args) throws Exception {");
                stream.println(StartUp.class.getName() + ".startup(args," + mainName + ".class);");
                stream.println("}");

                stream.println("public java.lang.String getClassName() { return \"Main\"; }");
                stream.println("public java.util.List<java.lang.String> getFieldNames() { return java.util.Collections.emptyList(); }");
                stream.println("public " + mainName + "(" + COG.class.getName() + " cog) { super(cog); }");
                stream.println("public java.util.List<java.util.Map<java.lang.String, java.lang.Object>> getHttpCallableMethodInfo() { throw new UnsupportedOperationException(\"method 'getHttpCallableMethodInfo' cannot be called on Main block\");} ");

                // main block
                stream.println("public " + ABSUnit.class.getName() + " run() {");
                stream.println("// Create initial DC, hook it up to the initial cog");
                stream.println(ABSInterface.class.getName() + " __main_block_dc = ABS.DC.DeploymentComponent_c.createNewLocalObject(\"Initial DC\", ABS.StdLib.map_f.apply(new ABS.StdLib.List_Nil<>()));");
                stream.println(ABSThread.class.getName() + ".getCurrentCOG().setDCfromMainBlock(__main_block_dc);");
                block.generateJava(stream);
                stream.println("return " + JavaBackendConstants.UNITVALUE + ";");
                stream.println("}");
                stream.println("}");
            }
        }


    }

    public void Decl.generateJavaCode(JavaCode.Package pkg) throws IOException, JavaCodeGenerationException {
        PrintStream s = null;
        try {
            String name = JavaBackend.getJavaName(this);
            File file = pkg.createJavaFile(name);
            s = JavaCodeStream.from(file);
            s.println("package " + pkg.packageName + ";");
            //s.println(JavaBackendConstants.LIB_IMPORT_STATEMENT);
            generateJava(s);
        } finally {
            if (s != null)
                s.close();
        }

    }

    public void DataTypeDecl.generateJavaCode(JavaCode.Package pkg) throws IOException, JavaCodeGenerationException {
        super.generateJavaCode(pkg);
        for (DataConstructor c : getDataConstructors()) {
            c.generateJavaCode(pkg);
        }
    }

    abstract void Decl.generateJava(PrintStream stream);

    public void DataConstructor.generateJava(PrintStream stream) {
        DataTypeDecl dataTypeDecl = ((DataTypeType)getType()).getDecl();
        String iname = dataTypeDecl.getName()
                       + JavaGeneratorHelper.getTypeParameters(dataTypeDecl);
        JavaGeneratorHelper.generateDataConstructor(stream, this, iname, dataTypeDecl);
    }

    public void ExceptionConstructor.generateJava(PrintStream stream) {
        DataTypeDecl dataTypeDecl = ((DataTypeType)getType()).getDecl();
        JavaGeneratorHelper.generateDataConstructor(stream, this, "ABS.StdLib.Exception", dataTypeDecl);
    }

    public void InterfaceDecl.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateHelpLine(stream,this);
        stream.print("public interface " + JavaBackend.getJavaName(this) + " extends " + ABSInterface.class.getName());
        for (InterfaceTypeUse use : getExtendedInterfaceUses()) {
            String iname = JavaBackend.getQualifiedString(((InterfaceType)use.getType()).getDecl());
            stream.print(", " + iname);
        }
        stream.println(" {");

        for (MethodSig s : getBodys()) {
            // Async
            s.generateJava(stream, true);
            stream.println(";");
            // Sync
            s.generateJava(stream, false);
            stream.println(";");
        }
        stream.println("boolean __ABS_isSameCOG();");
        stream.println("}");
    }

    public void MethodSig.generateJava(PrintStream stream) {
        generateJava(stream,false);
    }

    public void MethodSig.generateJava(PrintStream stream, boolean async) {
        JavaGeneratorHelper.generateMethodSig(stream,this,async);
    }

    public void ParamDecl.generateJava(PrintStream stream) {
        getTypeUse().generateJava(stream);
        stream.print(" " + JavaBackend.getVariableName(getName()));
    }

    public void ClassDecl.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateClassDecl(stream,this);
    }

    public void DeltaDecl.generateJava(PrintStream stream) {
        // TODO: Java generation here
    }

    public void MethodImpl.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateMethodImpl(stream, this);
    }

    public void FieldDecl.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateHelpLine(stream,this);
        stream.print("private ");
        getTypeUse().generateJava(stream);
        stream.print(" ");
        stream.print(JavaBackend.getVariableName(getName()));
        stream.println(";");
    }


    public void DataTypeDecl.generateJava(PrintStream stream) {
        boolean hasConstructors = getNumDataConstructor() > 0;

        JavaGeneratorHelper.generateHelpLine(stream,this);
        if (hasConstructors) {
            stream.print("public sealed interface " + getName());
        } else {
            // Two cases apply here: 
            // - The dummy definitions of Int etc. in abslang.abs
            // - The Exception type, which is an open type
            stream.print("public interface " + getName());
        }
        JavaGeneratorHelper.generateTypeParameters(stream,this);

        stream.print(" extends " + ABSAlgebraicDataType.class.getName());

        if (hasConstructors) {
            stream.print(" permits ");
            stream.print(ListUtils.toJavaList(getDataConstructors())
                    .stream()
                    .map(JavaBackend::getConstructorName)
                    .collect(Collectors.joining(", ")));
        }

        stream.println(" { }");
    }

    public void FunctionDecl.generateJava(PrintStream stream) {
        if (getFunctionDef() instanceof BuiltinFunctionDef) {
            // There are two cases here at the moment:
            // - "really" builtin functions. These occur only in the standard
            //   library and are known at compile-time (see class
            //   ABSBuiltInFunctions).
            // - SQLite queries; for these, we need to generate a body that
            //   runs the query.
            BuiltinFunctionDef b = (BuiltinFunctionDef)getFunctionDef();
            if (!b.isSQLite3Query()) {
                return;
            }
        }
        JavaGeneratorHelper.generateHelpLine(stream,this);

        String className = JavaBackend.getFunctionName(getName());
        stream.print("public final class " + className);
        stream.println(" implements " + ABSFunction.class.getName() + " {");
        stream.println("private " + className + "() { }");
        stream.print("public static ");
        JavaGeneratorHelper.generateTypeParameters(stream,this);

        getTypeUse().generateJava(stream);
        stream.print(" apply");
        JavaGeneratorHelper.generateParams(stream, getParams(), true);
        stream.println(" {");
        if (getFunctionDef() instanceof BuiltinFunctionDef) {
            // Can currently only be an SQLite query; let it emit a function
            // body instead of a single expression.
            getFunctionDef().generateJava(stream);
        } else if (getFunctionDef() instanceof ExpFunctionDef) {
            Set<PatternVarUse> boundVars = ((ExpFunctionDef)getFunctionDef()).getRhs().boundPatternVars();
            for (var boundVar : boundVars) {
                stream.println("final var $$" + boundVar.getName() + " = " + boundVar.getName() + ";");
            }
            getTypeUse().generateJava(stream);
            stream.print(" $result = ");
            getFunctionDef().generateJava(stream);
            stream.println(";");
            stream.println("return $result;");
        } else {
            throw new NotImplementedYetException(this, "Unknown function definition body");
        }
        stream.println("}");
        stream.println("}");
    }

    public void PartialFunctionDecl.generateJavaCode(JavaCode.Package pkg) {}

    public void PartialFunctionDecl.generateJava(PrintStream stream) {}

    public void ParFnApp.generateJava(PrintStream stream) {}

    public void FunctionDef.generateJava(PrintStream stream) { }

    public void ExpFunctionDef.generateJava(PrintStream stream) {
        getRhs().generateJava(stream);
    }

    public void BuiltinFunctionDef.generateJava(PrintStream stream) {
        // See FunctionDecl.generateJava: here we emit a series of statements
        // including a return statement instead of just an expression.
        if (isSQLite3Query()) {
            JavaGeneratorHelper.generateSqlite3Body(stream, this);
        } else {
            stream.println("return null;");
        }
    }

    public void TypeParameterDecl.generateJava(PrintStream stream) {
        // is never called
    }

    public void UnknownDecl.generateJava(PrintStream stream) {
        // is never called for type-correct programs
    }

    public void TypeSynDecl.generateJava(PrintStream stream) {
        // generate nothing as type synonyms do not appear in the Java outout
    }

    public void ExceptionDecl.generateJava(PrintStream stream) {
        // generate nothing as exceptions are rewritten to datatypes
    }

    public void Block.generateJava(PrintStream stream) {
        generateJava(stream, false);
    }

    public void Block.generateJava(PrintStream stream, boolean addReturn) {
        stream.println(" {");

        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        if (getModel().includeDebug && (this instanceof MainBlock || this instanceof InitBlock)) {
            stream.print("if (" + ABSRuntime.class.getName() + ".getRuntime().debuggingEnabled()) ");
            String name = "init block";
            if (this instanceof MainBlock)
                name = "main block";
            stream.println(ABSThread.class.getName() + ".getCurrentTask().newStackFrame(this,\"" + name + "\");");
        }

        for (Stmt stmt : getStmts()) {
            PureExp cost = AnnotationHelper.getAnnotationValueFromName(stmt.getAnnotationList(), "ABS.DC.Cost");
            if (cost != null) {
                stream.print("new " + ABSResourceGuard.class.getName() + "(");
                cost.generateJava(stream);
                stream.println(").await(" + ABSThread.class.getName() + ".getCurrentCOG(), " + ABSThread.class.getName() + ".getCurrentTask());");
            }
            stmt.generateJava(stream);
        }

        if (this instanceof MainBlock) {
            for (VarDecl v : getVars()) {
                if (v.getName().equals("testresult")) {
                    stream.println("System.out.println(\"__ABS_TESTRESULT=\" + testresult);");
                }
            }
        }

        if (addReturn) {
            if (getModel().includeDebug) {
                stream.println(JavaGeneratorHelper.getDebugString(this, getEndLine()));
                stream.print("if (" + ABSRuntime.class.getName() + ".getRuntime().debuggingEnabled()) ");
                stream.println(ABSThread.class.getName() + ".getCurrentTask().popStackFrame();");
            }

            stream.println("return " + JavaBackendConstants.UNITVALUE + ";");
        }
        stream.println("}");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void VarDecl.generateJava(PrintStream stream) {
        getTypeUse().generateJava(stream);
        String name = JavaBackend.getVariableName(getName());
        stream.print(" " + name + " = ");

        if (hasInitExp()) {
            getInitExp().generateJava(stream);
        } else {
            stream.print("null");
        }
        stream.println(";");
        if (getModel().includeDebug) {
            stream.print("if (" + ABSRuntime.class.getName() + ".getRuntime().debuggingEnabled()) ");
            stream.print(ABSThread.class.getName() + ".getCurrentTask().setLocalVariable(\"" + getName() + "\"," + name + ");");
        }
        if (getInitExp() instanceof NewExp) {
            VarDeclStmt stmt = closestParent(VarDeclStmt.class);
            if (stmt != null) {
                List<Annotation> annotations = stmt.getAnnotations();
                PureExp restname = AnnotationHelper.getAnnotationValueFromName(annotations, "ABS.StdLib.HTTPName");
                if (restname instanceof StringLiteral) {
                    stream.println();
                    stream.print(ModelApi.class.getName() + ".registerObject("
                                 + "\""+ ((StringLiteral)restname).getContent() + "\", "
                                 + "(" + ABSObject.class.getName() + ")" + name + ");");
                }
            }
        }
    }


    /*
     * STATEMENTS
     */

    abstract public void Stmt.generateJava(PrintStream stream);

    public void VarDeclStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        getVarDecl().generateJava(stream);
        stream.println();
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void AssignStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        getVar().generateJava(stream);
        stream.print(" = ");
        getValue().generateJava(stream);
        stream.println(";");

        if (getVar() instanceof VarUse) {
            if (getModel().includeDebug) {
                stream.print("if (" + ABSRuntime.class.getName() + ".getRuntime().debuggingEnabled()) ");
                stream.print(ABSThread.class.getName() + ".getCurrentTask().setLocalVariable(\"" + getVar().getName() + "\", ");
                getVar().generateJava(stream);
                stream.print(");");
            }
        }
        if (getValue() instanceof NewExp) {
            PureExp restname = AnnotationHelper.getAnnotationValueFromName(getAnnotations(), "ABS.StdLib.HTTPName");
            if (restname != null && restname instanceof StringLiteral) {
                stream.println();
                stream.print(ModelApi.class.getName() + ".registerObject("
                             + "\""+ ((StringLiteral)restname).getContent() + "\", "
                             + "(" + ABSObject.class.getName() + ")" + JavaBackend.getVariableName(getVar().getName()) + ");");
            }
        }
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void AwaitStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        JavaGeneratorHelper.generateAwaitStmt(this, stream);
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void ExpressionStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        getExp().generateJava(stream);
        stream.println(";");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void IfStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.print("if (");
        getCondition().generateJava(stream);
        stream.println(") {");
        getThen().generateJava(stream);
        stream.println("}");
        if (hasElse()) {
            stream.println("else {");
            getElse().generateJava(stream);
            stream.println("}");
        }
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void ReturnStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        MethodImpl m = getContextMethod();
        Type lht = getModel().getUnitType();
        if (m != null) {
            lht = m.getMethodSig().getReturnType().getType();
        }
        if (getModel().includeDebug) {
            stream.print("if (" + ABSRuntime.class.getName() + ".getRuntime().debuggingEnabled()) ");
            stream.println(ABSThread.class.getName() + ".getCurrentTask().popStackFrame();");
        }

        stream.print("return ");
        getRetExp().generateJava(stream);
        stream.println(";");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void SkipStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.println(";");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void DurationStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.print("new " + ABSDurationGuard.class.getName() + "(");
        getMin().generateJava(stream);
        stream.print(", ");
        getMax().generateJava(stream);
        stream.println(").await(" + ABSThread.class.getName() + ".getCurrentCOG(), " + ABSThread.class.getName() + ".getCurrentTask());");
        stream.println(";");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void MoveCogToStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.println(";");
        throw new NotImplementedYetException(this);
        // JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void SuspendStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.println(JavaBackendConstants.ABSRUNTIME + ".suspend();");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void WhileStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.print("while (");
        getCondition().generateJava(stream);
        stream.print(")");
        getBody().generateJava(stream);
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void CaseStmt.generateJava(PrintStream stream) {
        int depth = distanceTo(Decl.class);
        String expVarName = "$value$" + depth;
        String varType = JavaBackend.getQualifiedString(getExpr().getType());
        boolean hasDefault = false;
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.println("{ // via CaseStmt");
        stream.print("final " + varType + " " + expVarName + " = ");
        getExpr().generateJava(stream);
        stream.println(";");
        Set<String> boundPatternVars = boundPatternVars().stream()
            .map(v -> v.getName())
            .collect(Collectors.toSet());

        Set<String> allBound = new HashSet<>(boundPatternVars);
        Stmt parent = this.closestParent(Stmt.class);
        while (parent != null) {
            parent.boundPatternVars().forEach(v -> allBound.add(v.getName()));
            parent = parent.closestParent(Stmt.class);
        }
        stream.println("switch (" + expVarName + ") {");
        for (CaseBranchStmt b : getBranchs()) {
            Pattern pattern = b.getLeft();
            if (pattern instanceof UnderscorePattern) {
                stream.print("default -> ");
                hasDefault = true;
            } else {
                stream.print("case ");
                pattern.generateJava(stream, new AtomicInteger(0));
                pattern.generateJavaConditions(stream, new AtomicInteger(0), new AtomicBoolean(true), allBound);
                stream.print (" -> ");
            }
            b.getRight().generateJava(stream);
        }
        if (!hasDefault) {
            stream.print("default -> throw new " + UnmatchedCaseException.class.getName() + "(\"");
            JavaGeneratorHelper.printEscapedString(stream, getPositionString());
            stream.println(": value did not match any pattern.\");");
        }
        stream.println("} // via CaseStmt");
        stream.println("} // via CaseStmt");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }


    public void AssertStmt.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateStmtPreamble(stream, this);
        stream.print("if (!");
        getCondition().generateJava(stream);
        stream.print(") throw new " + ABSAssertException.class.getName() + "(\"");
        JavaGeneratorHelper.printEscapedString(stream, getPositionString());
        stream.println(": Assertion failed\");");
        JavaGeneratorHelper.generateStmtEpilogue(stream, this);
    }

    public void ThrowStmt.generateJava(PrintStream stream) {
        // throw new NotImplementedYetException(this);
    }

    public void DieStmt.generateJava(PrintStream stream) {
        throw new NotImplementedYetException(this);
    }

    public void TryCatchFinallyStmt.generateJava(PrintStream stream) {
        throw new NotImplementedYetException(this);
    }


    public void ForeachStmt.generateJava(PrintStream stream) {
        throw new NotImplementedYetException(this, "ForEachStmt should have been eliminated by tree rewriting");
    }

    /*
     * GUARDS
     */

    public abstract void Guard.generateJavaGuard(PrintStream beforeAwaitStream, PrintStream stream);

    public void AndGuard.generateJavaGuard(PrintStream beforeAwaitStream, PrintStream stream) {
        stream.print("new " + JavaBackendConstants.ANDGUARD + "(");
        getLeft().generateJavaGuard(beforeAwaitStream, stream);
        stream.print(",");
        getRight().generateJavaGuard(beforeAwaitStream, stream);
        stream.print(")");
    }

    public void ClaimGuard.generateJavaGuard(PrintStream beforeAwaitStream, PrintStream stream) {
        stream.print("new " + JavaBackendConstants.CLAIMGUARD + "(");
        getVar().generateJava(stream);
        stream.print(")");
    }

    public void ExpGuard.generateJavaGuard(PrintStream beforeAwaitStream, PrintStream stream) {
        JavaGeneratorHelper.generateExprGuard(this, beforeAwaitStream, stream);
    }

    public void DurationGuard.generateJavaGuard(PrintStream beforeAwaitStream, PrintStream stream) {
        stream.print("new " + JavaBackendConstants.DURATIONGUARD + "(");
        getMin().generateJava(stream);
        stream.print(", ");
        getMax().generateJava(stream);
        stream.print(")");
    }

    /*
     * EXPRESSIONS
     */

    public abstract void Exp.generateJava(PrintStream stream);

    public void AsyncCall.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateAsyncCall(stream, this);
    }

    public void AwaitAsyncCall.generateJava(PrintStream stream) {
        JavaGeneratorHelper.generateAwaitAsyncCall(stream, this);
    }

    public void SyncCall.generateJava(PrintStream stream) {
        PureExp callee = getCallee();
        final List<PureExp> params = getParams();
        if (callee instanceof ThisExp) {
            stream.print(JavaBackend.getMethodName(getMethod()));
            JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
        } else {
            LocationTypeExtension locationTypeSystem = (LocationTypeExtension)this.getModel().getTypeExt().getFirstRegisteredTypeExtension(LocationTypeExtension.class);
            LocationType tv = null;
            if (locationTypeSystem != null) {
                tv = locationTypeSystem.getLocationType(callee.getType());
            }
            if (tv == null || tv.isSomewhere()) {
                if (closestParent(Stmt.class) instanceof ExpressionStmt) {
                    // we're a stand-alone o!m()
                    stream.print("if (" + ABSRuntime.class.getName() + ".checkForNull(");
                    callee.generateJava(stream);
                    stream.print(").__ABS_isSameCOG()) ");
                    callee.generateJava(stream);
                    stream.print("." + JavaBackend.getMethodName(getMethod()));
                    JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
                    stream.print("; else ");
                    callee.generateJava(stream);
                    stream.print(".async_" + JavaBackend.getMethodName(getMethod()));
                    JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
                    stream.print(".get()");
                    // last semicolon comes from ExpressionStmt.generateJava()
                } else {
                    // we're the right-hand side of an assignment or similar
                    stream.print(ABSRuntime.class.getName() + ".checkForNull(");
                    callee.generateJava(stream);
                    stream.print(").__ABS_isSameCOG() ? ");
                    // synchronous method call
                    callee.generateJava(stream);
                    stream.print("." + JavaBackend.getMethodName(getMethod()));
                    JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
                    stream.print(" : ");
                    // asynchronous method call + get
                    callee.generateJava(stream);
                    stream.print(".async_" + JavaBackend.getMethodName(getMethod()));
                    JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
                    stream.print(".get()");
                }
            } else {
                if (tv.isNear()) {
                    stream.print(ABSRuntime.class.getName() + ".checkForNull(");
                    callee.generateJava(stream);
                    stream.print(")");
                    stream.print("." + JavaBackend.getMethodName(getMethod()));
                    JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
                } else if(tv.isFar()) {
                    stream.print(ABSRuntime.class.getName() + ".checkForNull(");
                    callee.generateJava(stream);
                    stream.print(")");
                    stream.print(".async_" + JavaBackend.getMethodName(getMethod()));
                    JavaGeneratorHelper.generateArgs(stream,params,getMethodSig().getTypes());
                    stream.print(".get()");
                }
            }
        }

    }

    public void OriginalCall.generateJava(PrintStream stream) {
        // TODO: implement
        // throw new NotImplementedYetException(this);
    }

    public void GetExp.generateJava(PrintStream stream) {
        DataTypeType t = (DataTypeType) getPureExp().getType();

        if (t.isDestinyType())
            throw new NotImplementedYetException(this, "Get expressions are not yet implemented for expressions directly typed by Destiny for the Java backend");

        // assume to be of type Fut<V>
        if (!t.isFutureType() || !t.hasTypeArgs())
            return;

        Type typeArg = t.getTypeArg(0);
        if (!(getParent() instanceof ExpressionStmt)) {
            stream.print("(" + JavaBackend.getQualifiedString(typeArg) + ")");
        }
        getPureExp().generateJava(stream);
        stream.print(".get()");
    }

    public void NewExp.generateJava(PrintStream stream) {
        ClassDecl decl = ((UnionType)getType()).getOriginatingClass();
        String className = JavaBackend.getQualifiedString(decl);

        if (!hasLocal()) {
            String strategy = null;
            PureExp scheduler = getInheritedAnnotationValue("Scheduler");
            PureExp dc = getInheritedAnnotationValue("DC");
            String dc_exp = "(ABS.DC.DeploymentComponent_i)(" + ABSThread.class.getName() + ".getCurrentCOG().getDC())";
            if (dc != null) {
                ByteArrayOutputStream output = new ByteArrayOutputStream();
                PrintStream s = new PrintStream(output);
                dc.generateJava(s);
                dc_exp = output.toString();
            }
            if (scheduler != null) {
                strategy = JavaGeneratorHelper.generateUserSchedulingStrategy(this, scheduler);
            }
            stream.print(className + ".__ABS_createNewCogObject");

            if (strategy != null)
                JavaGeneratorHelper.generateArgs(stream, "this, new " + strategy + "(), " + dc_exp, getParams(), decl.getTypes());
            else
                JavaGeneratorHelper.generateArgs(stream, "this, null, " + dc_exp, getParams(), decl.getTypes());

        } else {
            stream.print(className + ".__ABS_createNewLocalObject");
            JavaGeneratorHelper.generateArgs(stream, "this", getParams(), decl.getTypes());
        }
    }

    public void ImplementsExp.generateJava(PrintStream stream) {
        stream.print("((");
        getExp().generateJava(stream);
        stream.print(")");
        stream.print(" instanceof ");
        getInterfaceTypeUse().generateJava(stream);
        stream.print(")");
    }

    public void AsExp.generateJava(PrintStream stream) {
        stream.print("((");
        getExp().generateJava(stream);
        stream.print(") instanceof ");
        getInterfaceTypeUse().generateJava(stream);
        stream.print(" ? (");
        getInterfaceTypeUse().generateJava(stream);
        stream.print(")");
        getExp().generateJava(stream);
        stream.print(" : null)");
    }

    public abstract void TypeUse.generateJava(PrintStream stream);

    public void DataTypeUse.generateJava(PrintStream stream) {
        stream.print(JavaBackend.getJavaType(this));
    }

    public void InterfaceTypeUse.generateJava(PrintStream stream) {
        stream.print(JavaBackend.getJavaType(this));
    }
    /******/
    public void TypeParameterUse.generateJava(PrintStream stream) {
        stream.print(getName());
    }

    public void UnresolvedTypeUse.generateJava(PrintStream stream) {
        throw new JavaBackendException(this,"Type " + getName() + " is unresolved!");
    }

    public void FieldUse.generateJava(PrintStream stream) {
        ClassDecl d = (ClassDecl) getContextDecl();
        String className = JavaBackend.getClassName(d.getName());
        stream.print(className + ".this." + JavaBackend.getVariableName(getName()));
    }

    public void VarUse.generateJava(PrintStream stream) {
        stream.print(JavaBackend.getVariableName(getName()));
    }

    public void IfExp.generateJava(PrintStream stream) {
        getCondExp().generateJava(stream);
        stream.print(" ? ");
        getThenExp().generateJava(stream);
        stream.print(" : ");
        getElseExp().generateJava(stream);
    }

    public void CaseExp.generateJava(PrintStream stream) {
        Stmt stmt = closestParent(Stmt.class);
        // We might be a nested switch expression: only consider bound
        // variables rebound by the statement itself, not by any outer
        // switch since these are effectively final anyway
        Set<String> vars = stmt == null
            ? Set.of()
            : stmt.boundPatternVars()
                .stream()
                .map(PatternVarUse::getName)
                .collect(Collectors.toSet());

        stream.print("switch (");
        getExpr().generateJava(stream);
        stream.println(") {");
        for (CaseBranch b : getBranchs()) {
            Pattern pattern = b.getLeft();
            if (pattern instanceof UnderscorePattern) {
                stream.print("default -> ");
            } else {
                stream.print("case ");
                pattern.generateJava(stream, new AtomicInteger(0));
                pattern.generateJavaConditions(stream, new AtomicInteger(0), new AtomicBoolean(true), vars);
                stream.print(" -> ");
            }
            b.getRight().generateJava(stream);
            stream.println(";");
        }
        if (TypeCheckerHelper.needsDefaultBranch(this)) {
            stream.println("default -> throw new " + UnmatchedCaseException.class.getName() + "(\""
                           + JavaGeneratorHelper.escapedString(getPositionString())
                           + ": value did not match any pattern.\");");
        }
        stream.print("}");
    }

    // when Pattern.generateJava and Pattern.generateJavaConditions
    // are started with the same counter state, the variable names of
    // the generated code for pattern and when-condition will agree,
    // as long as sub-patterns are visited in the same order.  The
    // third argument to generateJavaConditions tells us which prefix
    // to emit ("when " or " && ").  The fourth argument tells us
    // which variables to prefix with a "$$" when matching against.
    public abstract void Pattern.generateJava(PrintStream stream, AtomicInteger counter);
    public abstract void Pattern.generateJavaConditions(PrintStream stream, AtomicInteger counter, AtomicBoolean first, Set<String> boundVars);

    public void ConstructorPattern.generateJava(PrintStream stream, AtomicInteger counter) {
        DataConstructor decl = getDataConstructor();
        assert decl != null : "We typechecked it!";
        if (decl.getType().isBoolType()) {
            // KLUDGE: Java >=24 allow matching against primitive
            // types, in Java 21 we have to use conditions here
            int depth = distanceTo(Decl.class);
            String varName = "$b" + counter.incrementAndGet() + "$" + depth;
            stream.print("Boolean " + varName);
        } else {
            stream.print(JavaBackend.getQualifiedString(decl));
            stream.print("(");
            String separator = "";
            for (Pattern p : getParams()) {
                stream.print(separator);
                separator = ", ";
                p.generateJava(stream, counter);
            }
            stream.print(")");
        }
    }
    public void ConstructorPattern.generateJavaConditions(PrintStream stream, AtomicInteger counter, AtomicBoolean first, Set<String> boundVars) {
        DataConstructor decl = getDataConstructor();
        if (decl.getType().isBoolType()) {
            // KLUDGE: Java >=24 allow matching against primitive
            // types, in Java 21 we have to use conditions here
            int depth = distanceTo(Decl.class);
            String varName = "$b" + counter.incrementAndGet() + "$" + depth;
            if (first.getAndSet(false)) {
                stream.print(" when ");
            } else {
                stream.print(" && ");
            }
            if (decl.getName().equals("True")) {
                stream.print("Boolean.TRUE.equals(" + varName + ")");
            } else {
                stream.print("Boolean.FALSE.equals(" + varName + ")");
            }
        } else {
            for (Pattern p : getParams()) {
                p.generateJavaConditions(stream, counter, first, boundVars);
            }
        }
    }

    public void PatternVar.generateJava(PrintStream stream, AtomicInteger counter) {
        stream.print(JavaBackend.getQualifiedString(this.getVar().getType()) + " " + JavaBackend.getVariableName(getVar().getName()));
    }
    public void PatternVar.generateJavaConditions(PrintStream stream, AtomicInteger counter, AtomicBoolean first, Set<String> boundVars) { }

    public void UnderscorePattern.generateJava(PrintStream stream, AtomicInteger counter) {
        // when we use java >= 24, we can use `_` instead.
        int depth = distanceTo(Decl.class);
        stream.print("java.lang.Object $" + counter.incrementAndGet() + "$" + depth);
    }
    public void UnderscorePattern.generateJavaConditions(PrintStream stream, AtomicInteger counter, AtomicBoolean first, Set<String> boundVars) {
        counter.incrementAndGet();
    }

    public void PatternVarUse.generateJava(PrintStream stream, AtomicInteger counter) {
        int depth = distanceTo(Decl.class);
        String varName = JavaBackend.getVariableName(getName()) + "$" + depth;
        stream.print(JavaBackend.getQualifiedString(getType()) + " " + varName);
    }
    public void PatternVarUse.generateJavaConditions(PrintStream stream, AtomicInteger counter, AtomicBoolean first, Set<String> boundVars) {
        int depth = distanceTo(Decl.class);
        String name = JavaBackend.getVariableName(getName());
        String varName = name + "$" + depth;
        String prefix = boundVars.contains(name) ? "$$" : "";
        if (first.getAndSet(false)) {
            stream.print(" when ");
        } else {
            stream.print(" && ");
        }
        stream.print(BinOp.class.getName() + ".eq(" + varName + ", " + prefix + name + ")");
    }

    public void LiteralPattern.generateJava(PrintStream stream, AtomicInteger counter) {
        int depth = distanceTo(Decl.class);
        String varName = "$" + counter.incrementAndGet() + "$" + depth;
        stream.print(JavaBackend.getQualifiedString(getLiteral().getType()) + " " + varName);
    }
    public void LiteralPattern.generateJavaConditions(PrintStream stream, AtomicInteger counter, AtomicBoolean first, Set<String> boundVars) {
        int depth = distanceTo(Decl.class);
        String varName = "$" + counter.incrementAndGet() + "$" + depth;
        if (first.getAndSet(false)) {
            stream.print(" when ");
        } else {
            stream.print(" && ");
        }
        stream.print(BinOp.class.getName() + ".eq(" + varName + ", ");
        getLiteral().generateJava(stream);
        stream.print(")");
    }

    public void FnApp.generateJava(PrintStream stream) {

        // Have to explicitly type the call due to a bug in the JastAdd Java
        // compiler that generates wrong code otherwise.
        FunctionDecl d = (FunctionDecl)getDecl();

        if (d.getFunctionDef() instanceof BuiltinFunctionDef) {
            // This handles both StdLib functions and sqlite queries
            JavaGeneratorHelper.generateBuiltInFnApp(stream,this);
        } else {
            stream.print(JavaBackend.getQualifiedString(d) + ".");
            Type declaredResultType = d.getTypeUse().getType();
            stream.print("apply");
            JavaGeneratorHelper.generateArgs(stream,getParams(), d.getTypes());
        }
    }

    public void DataConstructorExp.generateJava(PrintStream stream) {
        DataConstructor c = getDataConstructor();
        assert c != null;
        DataTypeDecl decl = c.getDataTypeDecl();
        Type t = decl.getType();
        if (t.isBoolType()) {
            // FIXME: would love to emit "true" and "false" here, but certain
            // ABS methods cannot be compiled.
            if ("True".equals(c.getName()))
                stream.print("Boolean.TRUE");
            else
                stream.print("Boolean.FALSE");
        } else if (t.isUnitType()) {
            stream.print(JavaBackendConstants.UNITVALUE);
        } else {
            stream.print("new " + JavaBackend.getQualifiedString(c));
            if (decl instanceof ParametricDataTypeDecl) {
                stream.print("<>");
            }
            JavaGeneratorHelper.generateArgs(stream,getParams(), c.getTypes());
        }
    }

    public void LetExp.generateJava(PrintStream stream) {
        stream.print("new " + Let.class.getName());
        String varType = JavaBackend.getQualifiedString(getVar().getType());
        String expType = JavaBackend.getQualifiedString(getExp().getType());
        stream.print("() { public " + expType);
        stream.print(" in(");
        for (String freeVarName : getExp().getFreeVars()) {
            if (freeVarName.equals(getVar().getName()))
                continue;
            // ignore renaming of variables to temp variables...
            String freeVarName2 = freeVarName.replaceFirst("^temp\\$[0-9]+\\$", "");
            VarOrFieldDecl decl = getExp().lookupVarOrFieldName(freeVarName2,false);
            if (decl == null) {
                throw new IllegalArgumentException("Variable " + freeVarName + " cannot be resolved");
            }
            String freeVarType = JavaBackend.getQualifiedString(decl.getType());
            stream.print("final " + freeVarType + " " + JavaBackend.getVariableName(freeVarName));
            stream.print(", ");
        }

        stream.print("final " + varType + " " + JavaBackend.getVariableName(getVar().getName()));
        stream.print(") { ");
        stream.print("return ");
        getExp().generateJava(stream);
        stream.print("; }}.in(");
        for (String freeVarName : getExp().getFreeVars()) {
            if (freeVarName.equals(getVar().getName()))
                continue;
            stream.print(freeVarName);
            stream.print(", ");
        }
        getVal().generateJava(stream);
        stream.print(")");
    }

    public void IntLiteral.generateJava(PrintStream stream) {
        // Long.MAX_VALUE = 9223372036854775807L
        boolean needsFromString = getContent().length() > 18;
        boolean isZero = getContent().equals("0");
        boolean isOne = getContent().equals("1");
        if (isZero) {
            stream.print(Apint.class.getName() + ".ZERO");
        } else if (isOne) {
            stream.print(Apint.class.getName() + ".ONE");
        } else {
            stream.print("new " + Apint.class.getName());
            if (needsFromString) {
                stream.print("(\"");
                stream.print(getContent());
                stream.print("\")");
            } else  {
                stream.print("(");
                stream.print(getContent());
                stream.print("L)");
            }
        }
    }

    public void FloatLiteral.generateJava(PrintStream stream) {
        stream.print(getContent() + "d");
    }

    public void StringLiteral.generateJava(PrintStream stream) {
        stream.print("\"");
        JavaGeneratorHelper.printEscapedString(stream, getContent());
        stream.print("\"");
    }

    public void ListLiteral.generateJava(PrintStream stream) {
        for (PureExp e : getPureExps()) {
            stream.print("new ABS.StdLib.List_Cons(");
            e.generateJava(stream);
            stream.print(", ");
        }
        stream.print("new ABS.StdLib.List_Nil()");
        for (int i = 0; i < getNumPureExp(); i++) {
            stream.print(")");
        }
    }

    public void NullExp.generateJava(PrintStream stream) {
        stream.print("null");
    }

    public void ThisExp.generateJava(PrintStream stream) {
        stream.print("this");
    }

    public void DestinyExp.generateJava(PrintStream stream) {
        throw new NotImplementedYetException(this);
    }

    public void MinusExp.generateJava(PrintStream stream) {
        if (getOperand().getType().isFloatType()) {
            stream.print("(-");
            getOperand().generateJava(stream);
            stream.print(")");
        } else {
            getOperand().generateJava(stream);
            stream.print(".negate()");
        }
    }

    public void NegExp.generateJava(PrintStream stream) {
        stream.print("!(");
        getOperand().generateJava(stream);
        stream.print(")");
    }

    public void AddAddExp.generateJava(PrintStream stream) {
        Type t = getLeft().getType();
        if (t.isStringType() || t.isFloatType()) {
            stream.print("(");
            getLeft().generateJava(stream);
            stream.print("+");
            getRight().generateJava(stream);
            stream.print(")");
        } else {
            getLeft().generateJava(stream);
            stream.print(".add(");
            getRight().generateJava(stream);
            stream.print(")");
        }
    }

    public void SubAddExp.generateJava(PrintStream stream) {
        Type t = getLeft().getType();
        if (t.isFloatType()) {
            stream.print("(");
            getLeft().generateJava(stream);
            stream.print("-");
            getRight().generateJava(stream);
            stream.print(")");
        } else {
            getLeft().generateJava(stream);
            stream.print(".subtract(");
            getRight().generateJava(stream);
            stream.print(")");
        }
    }

    public void DivMultExp.generateJava(PrintStream stream) {
        Type t = getLeft().getType();
        if (t.isFloatType()) {
            stream.print("(");
            getLeft().generateJava(stream);
            stream.print("/");
            getRight().generateJava(stream);
            stream.print(")");
        } else if (t.isIntType() && getRight().getType().isIntType()) {
            stream.print("new " + Aprational.class.getName() + "(");
            getLeft().generateJava(stream);
            stream.print(",");
            getRight().generateJava(stream);
            stream.print(")");
        } else {
            getLeft().generateJava(stream);
            stream.print(".divide(");
            getRight().generateJava(stream);
            stream.print(")");
        }
    }

    public void ModMultExp.generateJava(PrintStream stream) {
        Type t = getLeft().getType();
        if (t.isFloatType()) {
            stream.print("(");
            getLeft().generateJava(stream);
            stream.print("%");
            getRight().generateJava(stream);
            stream.print(")");
        } else {
            getLeft().generateJava(stream);
            stream.print(".mod(");
            getRight().generateJava(stream);
            stream.print(")");
        }
    }

    public void MultMultExp.generateJava(PrintStream stream) {
        Type t = getLeft().getType();
        if (t.isFloatType()) {
            stream.print("(");
            getLeft().generateJava(stream);
            stream.print("*");
            getRight().generateJava(stream);
            stream.print(")");
        } else {
            getLeft().generateJava(stream);
            stream.print(".multiply(");
            getRight().generateJava(stream);
            stream.print(")");
        }
    }

    public void AndBoolExp.generateJava(PrintStream stream) {
        stream.print("(");
        getLeft().generateJava(stream);
        stream.print(") && (");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void OrBoolExp.generateJava(PrintStream stream) {
        stream.print("(");
        getLeft().generateJava(stream);
        stream.print(") || (");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void EqExp.generateJava(PrintStream stream) {
        stream.print(BinOp.class.getName() + ".eq(");
        getLeft().generateJava(stream);
        stream.print(",");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void NotEqExp.generateJava(PrintStream stream) {
        stream.print(BinOp.class.getName() + ".notEq(");
        getLeft().generateJava(stream);
        stream.print(",");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void GTEQExp.generateJava(PrintStream stream) {
        stream.print(BinOp.class.getName() + ".gtEq(");
        getLeft().generateJava(stream);
        stream.print(",");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void GTExp.generateJava(PrintStream stream) {
        stream.print(BinOp.class.getName() + ".gt(");
        getLeft().generateJava(stream);
        stream.print(",");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void LTEQExp.generateJava(PrintStream stream) {
        stream.print(BinOp.class.getName() + ".ltEq(");
        getLeft().generateJava(stream);
        stream.print(",");
        getRight().generateJava(stream);
        stream.print(")");
    }

    public void LTExp.generateJava(PrintStream stream) {
        stream.print(BinOp.class.getName() + ".lt(");
        getLeft().generateJava(stream);
        stream.print(",");
        getRight().generateJava(stream);
        stream.print(")");
    }

    /*****/
    public void TraitUse.generateJava(PrintStream stream) { }
    public void TraitUse.generateJavaDynamic(PrintStream stream) { }
    public void TraitDecl.generateJavaDynamic(PrintStream stream) { }
    public void TraitDecl.generateJava(PrintStream stream) { }
    public void DeltaTraitModifier.generateJavaDynamic(PrintStream stream) { }
    public void DeltaTraitModifier.generateJava(PrintStream stream) { }
    public void AddMethodModifier.generateJavaDynamic(PrintStream stream) { }
    public void AddMethodModifier.generateJava(PrintStream stream) { }
    public void RemoveMethodModifier.generateJavaDynamic(PrintStream stream) { }
    public void RemoveMethodModifier.generateJava(PrintStream stream) { }
    public void ModifyMethodModifier.generateJavaDynamic(PrintStream stream) { }
    public void ModifyMethodModifier.generateJava(PrintStream stream) { }

}


