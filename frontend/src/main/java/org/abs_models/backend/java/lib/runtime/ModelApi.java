package org.abs_models.backend.java.lib.runtime;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.math.BigInteger;
import java.net.FileNameMap;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

import org.abs_models.backend.java.lib.expr.BinOp;
import org.abs_models.backend.java.lib.types.ABSAlgebraicDataType;
import org.abs_models.backend.java.lib.types.ABSUnit;
import org.abs_models.backend.java.lib.types.ABSValue;
import org.abs_models.backend.java.observing.GraphObserver;
import org.apache.jena.riot.Lang;
import org.apache.jena.riot.RDFLanguages;
import org.apfloat.Apint;
import org.apfloat.Aprational;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.exc.StreamReadException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DatabindException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

public class ModelApi {

    protected static final Logger log = Logging.getLogger(ModelApi.class.getName());

    // Constructors for classes that are generated by compiling the
    // ABS standard library.  They will be available when starting a
    // model, but do not exist when we compile this file.
    private static final Constructor<?> makeNil;
    private static final Constructor<?> makeCons;
    private static final Constructor<?> makeEmptyMap;
    private static final Constructor<?> makeInsertAssoc;
    private static final Constructor<?> makePair;
    static {
        try {
            makeCons = Class.forName("ABS.StdLib.List_Cons").getDeclaredConstructors()[0];
            makeNil = Class.forName("ABS.StdLib.List_Nil").getDeclaredConstructors()[0];
            makeInsertAssoc = Class.forName("ABS.StdLib.Map_InsertAssoc").getDeclaredConstructors()[0];
            makeEmptyMap = Class.forName("ABS.StdLib.Map_EmptyMap").getDeclaredConstructors()[0];
            makePair = Class.forName("ABS.StdLib.Pair_Pair").getDeclaredConstructors()[0];
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Failed to find a class from the ABS standard library: " + e.getMessage(), e);
        }
    }

    // This lets us guess MIME types, given a filename
    private static final FileNameMap mimeTypes = URLConnection.getFileNameMap();

    // This object is stateless and expensive to construct (according
    // to the Jackson documentation), so get us a static instance
    private static final ObjectMapper mapper = new ObjectMapper()
        .enable(SerializationFeature.INDENT_OUTPUT)
        // ordered keys give us more readable method info (name, parameters, return)
        .enable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)
        // quality-of-life feature: allow "{'param': 'value' }"
        .enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);

    private static final ConcurrentHashMap<String, ABSObject> registeredObjects = new ConcurrentHashMap<>();
    /**
     * Register an object that is created or assigned via a {@code
     * [HTTPName: "name"]} annotation, or override the previous entry
     * for {@code "name"}.
     */
    public static void registerObject(String name, ABSObject object) {
        registeredObjects.put(name, object);
    }
    /**
     * Get the object most recently associated with the given {@code
     * [HTTPName: "name"]} annotation, or {@code null}.
     */
    public static ABSObject getRegisteredObject(String name) {
        return registeredObjects.getOrDefault(name, null);
    }

    /**
     * Start the Model API on the given port.
     *
     * @param port The port to use, 0 for a random port.
     * @throws IOException if the server could not be started.
     */
    public static void startModelApi(int port) throws IOException {
        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);
        server.createContext("/static/", new ModelApi.StaticFileHandler());
        server.createContext("/o", new ModelApi.ObjectHandler());
        server.createContext("/call", new ModelApi.CallHandler());
        server.createContext("/quit", new ModelApi.QuitHandler());
        server.createContext("/clock", new ModelApi.ClockHandler());
        server.createContext("/dcs", new ModelApi.DCHandler());
        server.createContext("/sparql", new ModelApi.SparqlHandler());
        // this is a catch-all handler so should be last
        server.createContext("/", new ModelApi.RootHandler());
        server.setExecutor(Executors.newCachedThreadPool(r -> {
                Thread t = Executors.defaultThreadFactory().newThread(r);
                t.setUncaughtExceptionHandler((thread, ex) -> {
                        ex.printStackTrace(System.out);
                    });
                return t;
            }));
        server.start();
        log.config(() -> "ModelApi server started on port " + port);
    }

    /**
     * A handler that serves the contents of the /static directory.
     */
    // The files come from `resources/java/modelapi/static` but can be
    // overridden by the `--modelapi-static-dir` parameter
    private static class StaticFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String path = exchange.getRequestURI().getPath();
            byte[] response = loadResource("/java/modelapi" + path);
            if (response != null) {
                String mimeType = mimeTypes.getContentTypeFor(path);
                if (mimeType == null) mimeType = "application/octet-stream";
                sendResponse(exchange, 200, mimeType, response);
            } else {
                send404(exchange);
            }
        }
    }

    /**
     * A handler that just terminates the model.
     */
    private static class QuitHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            // Handlers match on string prefixes of the URL path, so
            // check that we didn't get called with "/exitwhatever"
            if (exchange.getRequestURI().getPath().equals("/quit")) {
                sendResponse(exchange, 200, "text/plain", "ok");
                System.exit(0);
            } else {
                send404(exchange);
            }
        }
    }

    /**
     * A handler that implements a SPARQL endpoint.
     */
    private static class SparqlHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            // For the format of sparql queries over http, see
            // https://www.w3.org/TR/sparql11-protocol/#query-operation
            String queryString;
            if (exchange.getRequestMethod().equals("GET")) {
                // https://www.w3.org/TR/sparql11-protocol/#query-via-get
                URI uri = exchange.getRequestURI();
                queryString = Arrays.stream(uri.getQuery().split("&"))
                    .filter(param -> param.startsWith("query="))
                    .map(param -> param.substring("query=".length()))
                    .findFirst()
                    .orElse("");
            } else if (exchange.getRequestMethod().equals("POST")) {
                // https://www.w3.org/TR/sparql11-protocol/#query-via-post-direct
                queryString = new String(exchange.getRequestBody().readAllBytes());
                // TODO: implement
                // https://www.w3.org/TR/sparql11-protocol/#query-via-post-urlencoded
                // if necessary
            } else {
                exchange.getResponseHeaders().set("Allow", "GET POST");
                exchange.sendResponseHeaders(405, 0);
                exchange.close();
                return;
            }
            Lang lang = negotiateContentType(exchange.getRequestHeaders().getFirst("Accept"));
            String solution = GraphObserver.runQuery(GraphObserver.getModel(), queryString, lang);
            sendResponse(exchange, 200, lang.getHeaderString(), solution);
        }

        Lang negotiateContentType(String acceptHeader) {
            if (acceptHeader == null) acceptHeader = "application/sparql-results+json";
            String[] mediaTypes = acceptHeader.split(",");
            for (String mediaType : mediaTypes) {
                // Remove quality values and whitespace
                String cleanType = mediaType.split(";")[0].trim();
                Lang lang = RDFLanguages.contentTypeToLang(cleanType);
                if (lang != null) {
                    return lang;
                }
            }
            return Lang.RDFJSON; // should never be reached
        }

    }

    /**
     * A handler that serves the /index.html file.  Also serves as
     * catch-all handler and will return 404 for unmatched paths.
     */

    // `index.html` is `resources/java/modelapi/index.html` but can be
    // overridden by the `--modelapi-index-file` parameter
    private static class RootHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            byte[] response = null;
            String path = exchange.getRequestURI().getPath();
            if (path.equals("/") || path.equals("/index.html")) {
                response = loadResource("/java/modelapi/index.html");
            }
            if (response != null) {
                sendResponse(exchange, 200, "text/html", response);
            } else {
                sendResponse(exchange, 404, "text/plain", "404 (Not Found)");
            }
        }
    }

    private static class ClockHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            Aprational now = ABSRuntime.getRuntime().getClock();
            final List<String> paths = Arrays.stream(exchange.getRequestURI().getPath().split("/"))
                .filter(p -> !p.isEmpty())
                .collect(Collectors.toList());
            if (!"clock".equals(paths.getFirst())) {
                send404(exchange);
            } else if (paths.size() == 1) {
                String response = "Now: " + now.toString()  + "\n";
                sendResponse(exchange, 200, "text/plain", response);
            } else if (paths.size() == 2 && "now".equals(paths.get(1))) {
                String response = mapper.writeValueAsString(Map.of("result", absToJson(now)));
                sendResponse(exchange, 200, "text/json", response);
            } else if (paths.size() == 2 && "advance".equals(paths.get(1))) {
                // decode an Int in the `by` URL parameter
                Apint by = null;
                String errorResponse = mapper.writeValueAsString(Map.of("error", "Need parameter \"by\" with positive integer"));
                String uriParams = exchange.getRequestURI().getQuery();
                if (uriParams != null) {
                    String[] urlParams = exchange.getRequestURI().getQuery().split(";");
                    for (String urlParam : urlParams) {
                        int split = urlParam.indexOf('=');
                        if (split == -1) {
                            sendResponse(exchange, 400, "text/json", errorResponse);
                        }
                        String param = urlParam.substring(0, split);
                        if (!param.equals("by")) {
                            sendResponse(exchange, 400, "text/json", errorResponse);
                            return;
                        } else {
                            try {
                                by = (Apint)convertUrlParameter("by", urlParam.substring(split + 1), "ABS.StdLib.Int");
                            } catch (ParameterConversionException e) {
                                sendResponse(exchange, 400, "text/json", errorResponse);
                            }
                            if (BinOp.lt(by, Apint.ZERO)) {
                                sendResponse(exchange, 400, "text/json", errorResponse);
                                return;
                            }
                        }
                    }
                }
                if (by != null) {
                    Object limit = ABSRuntime.getRuntime().addToClockLimit(by.longValue());
                    String response = mapper.writeValueAsString(Map.of("result", limit));
                    sendResponse(exchange, 200, "text/json", response);
                } else {
                    sendResponse(exchange, 400, "text/json", errorResponse);
                    return;
                }
            } else {
                send404(exchange);
            }
        }
    }

    private static class DCHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            final List<String> paths = Arrays.stream(exchange.getRequestURI().getPath().split("/"))
                .filter(p -> !p.isEmpty())
                .collect(Collectors.toList());
            if (paths.size() == 1 && "dcs".equals(paths.getFirst())) {
                List<ABSDCMirror> dcs = ABSRuntime.getRuntime().getDeploymentComponents();
                List<Map<String, Object>> result = dcs.stream()
                    .map(dc -> Map.of("name", dc.getDescription(), "values", dc.getCpuHistories()))
                    .collect(Collectors.toList());
                sendResponse(exchange, 200, "text/json", mapper.writeValueAsString(result));
            } else {
                send404(exchange);
            }
        }
    }

    private static class ObjectHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            final List<String> paths = Arrays.stream(exchange.getRequestURI().getPath().split("/"))
                .filter(p -> !p.isEmpty())
                .collect(Collectors.toList());
            if (!"o".equals(paths.getFirst())) {
                // Did someone request "/oneortheother"?  Refuse to
                // handle that.  Note that we only ever get asked to
                // handle a non-empty path.
                send404(exchange);
            } else if (paths.size() == 1) {
                // /o or /o/
                Set<String> objectNames = registeredObjects.keySet();
                String response = mapper.writeValueAsString(objectNames);
                sendResponse(exchange, 200, "text/json", response);
            } else if (paths.size() == 2) {
                // /o/objectname
                final ABSObject o = getRegisteredObject(paths.get(1));
                if (o == null) {
                    send404(exchange);
                } else {
                    HashMap<String, Object> objectState = new HashMap<>();
                    o.getFieldNames().forEach(f -> {
                            try {
                                objectState.put(f, absToJson(o.getFieldValue(f)));
                            } catch (NoSuchFieldException e) {
                                objectState.put(f, null); // shouldn't happen
                            }
                        });
                    String response = mapper.writeValueAsString(objectState);
                    sendResponse(exchange, 200, "text/json", response);
                }
            } else if(paths.size() == 3) {
                // /o/objectname/fieldname
                final ABSObject o = getRegisteredObject(paths.get(1));
                final String fieldName = paths.get(2);
                if (o == null) {
                    send404(exchange);
                } else {
                    try {
                        sendResponse(exchange, 200, "text/json",
                            mapper.writeValueAsString(absToJson(o.getFieldValue(fieldName))));
                    } catch (NoSuchFieldException e) {
                        send404(exchange);
                    }
                }
            } else {
                // malformed path
                send404(exchange);
            }
        }
    }

    private static class CallHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            final List<String> paths = Arrays.stream(exchange.getRequestURI().getPath().split("/"))
                .filter(p -> !p.isEmpty())
                .collect(Collectors.toList());
            if (!paths.getFirst().equals("call")) {
                // Did someone request "/callorthis"?  Refuse to
                // handle that.  Note that we only ever get asked to
                // handle a non-empty path.
                send404(exchange);
            } else if (paths.size() == 1) {
                // /call or /call/
                Set<String> objectNames = registeredObjects.keySet();
                String response = mapper.writeValueAsString(objectNames);
                sendResponse(exchange, 200, "text/json", response);
            } else if (paths.size() == 2) {
                // /call/objectname
                final ABSObject o = getRegisteredObject(paths.get(1));
                if (o == null) {
                    send404(exchange);
                } else {
                    String response = mapper.writeValueAsString(o.getHttpCallableMethodInfo());
                    sendResponse(exchange, 200, "text/json", response);
                }
            } else if(paths.size() == 3) {
                // /call/objectname/methodname
                final ABSObject o = getRegisteredObject(paths.get(1));
                if (o == null) {
                    send404(exchange);
                    return;
                }
                final String methodName = paths.get(2);
                final Map<String, Object> methodEntry = o.getHttpCallableMethodInfo().stream()
                    .filter(e -> methodName.equals(e.get("name")))
                    .findFirst()
                    .orElse(null);
                if (methodEntry == null) {
                    // unknown method
                    sendResponse(exchange, 404, "text/plain",
                        "Method " + methodName + " not found");
                    return;
                }
                final List<Object> parameters = (List)methodEntry.get("parameters");
                final Map<String, Object> bindings;
                try {
		    bindings = extractParameterBindings(exchange, parameters);
		} catch (IOException | ParameterConversionException | ReflectiveOperationException e1) {
                    sendResponse(exchange, 422, "text/plain", "Could not process method invocation: " + e1.getMessage());
                    return;
		}
                final List<Object> arguments = parameters.stream()
                    .map(p -> bindings.get(((Map)p).get("name")))
                    .collect(Collectors.toList());
                ABSFut<? extends Object> f = o.invokeMethod(methodName, arguments);
                if (f == null) {
                    sendResponse(exchange, 500, "text/plain", "Internal error while executing method call");
                } else {
                    f.awaitForModelApi();
                    Object result = f.get();
                    Object jsonResult = absToJson(result);
                    sendResponse(exchange, 200, "text/json",
                        // note that `null` is a valid ABSValue :-)
                        mapper.writeValueAsString(Map.of("result", jsonResult)));
                }
            } else {
                // malformed path
                send404(exchange);
            }
        }
    }

    private static class ParameterConversionException extends Exception {
        public ParameterConversionException(String paramName, Object value, String type) {
            super(String.format("Could not parse value for %s: %s cannot be parsed as %s",
                paramName, value, type));
        }
        public ParameterConversionException(String message) {
            super(message);
        }
    }

    @Nonnull
    private static Map<String, Object> extractParameterBindings(HttpExchange exchange,
        List<Object> parameterList) throws StreamReadException, DatabindException, IOException, ParameterConversionException, ReflectiveOperationException {
        Map<String, String> parameters = parameterList.stream()
            .map(o -> (Map)o)
            .collect(Collectors.toMap(
                e -> e.get("name").toString(),
                e -> e.get("type").toString()));
        HashMap<String, Object> result = new HashMap<>();
        if (exchange.getRequestMethod().equalsIgnoreCase("POST")) {
            // Read the request body
            InputStream requestBody = exchange.getRequestBody();
            Map<String, Object> jsonMap = mapper.readValue(requestBody, new TypeReference<Map<String, Object>>() {});
            for (Map.Entry<String, Object> e : jsonMap.entrySet()) {
                String name = e.getKey();
                Object value = e.getValue();
                if (!parameters.containsKey(name)) {
                    throw new ParameterConversionException("Unknown parameter given in request body: " + name);
                }
                result.put(name, convertParameter(name, value, parameters.get(name)));
            }
        }
        String uriParams = exchange.getRequestURI().getQuery();
        if (uriParams != null) {
            String[] urlParams = exchange.getRequestURI().getQuery().split(";");
            for (String urlParam : urlParams) {
                int split = urlParam.indexOf('=');
                if (split == -1) {
                    throw new ParameterConversionException("Invalid syntax for parameter in URL: " + urlParam);
                }
                String param = urlParam.substring(0, split);
                if (!parameters.containsKey(param)) {
                    throw new ParameterConversionException("Unknown parameter given in URL: " + param);
                }
                result.put(param, convertUrlParameter(param, urlParam.substring(split + 1), parameters.get(param)));
            }
        }
        if (!result.keySet().containsAll(parameters.keySet())) {
            // We check during reading if the parameter is known to
            // the method.  Here we check if we have all of the
            // method's parameters.
            throw new ParameterConversionException("Missing method parameters: "
                                                   + parameters.keySet().stream()
                                                       .filter(p -> !result.keySet().contains(p))
                                                       .collect(Collectors.joining(", ")));
        }
        return result;
    }

    private static Object convertParameter(String name, Object value, String type) throws ParameterConversionException, ReflectiveOperationException {
        if (type.equals("ABS.StdLib.String") && value instanceof String s) {
            return s;
        } else if (type.equals("ABS.StdLib.Float") && value instanceof Double d) {
            return d;
        } else if (type.equals("ABS.StdLib.Int") && value instanceof Integer i) {
            return new Apint(i);
        } else if (type.equals("ABS.StdLib.Int") && value instanceof BigInteger i) {
            return new Apint(i);
        } else if (type.equals("ABS.StdLib.Bool") && value instanceof Boolean b) {
            return b;
        } else if (type.startsWith("ABS.StdLib.Map") && value instanceof Map<?, ?> m) {
            // always a Map<String,...> -- only extract the value type, key is always String
            String valueType = type.substring(type.indexOf(',') + 1, type.length() - 1);
            ABSValue result = (ABSValue)makeEmptyMap.newInstance();
            if (!m.isEmpty()) {
                for (Map.Entry<?,?> e : m.entrySet()) {
                    Object k = convertParameter(name, e.getKey(), "ABS.StdLib.String");
                    Object v = convertParameter(name, e.getValue(), valueType);
                    result = (ABSValue)makeInsertAssoc.newInstance((ABSValue)makePair.newInstance(k, v), result);
                }
            }
            return result;
        } else if (type.startsWith("ABS.StdLib.List") && value instanceof List<?> l) {
            String valueType = type.substring(type.indexOf('<') + 1, type.length() - 1);
            ABSValue result = (ABSValue)makeNil.newInstance();
            if (!l.isEmpty()) {
                for (Object item : l.reversed()) {
                    result = (ABSValue)makeCons.newInstance(convertParameter(name, item, valueType), result);
                }
            }
            return result;
        } else {
            throw new ParameterConversionException(name, value, type);
        }
    }

    private static Object convertUrlParameter(String name, String value, String type) throws ParameterConversionException {
        if (type.equals("ABS.StdLib.String")) {
            return value;
        } else if (type.equals("ABS.StdLib.Float")) {
            try {
                return Double.parseDouble(value);
            } catch (NumberFormatException e) {
                throw new ParameterConversionException("Could not parse " + value + " as Double for parameter '" + name + "'");
            }
        } else if (type.equals("ABS.StdLib.Int")) {
            try {
                return new Apint(value);
            } catch (NumberFormatException e) {
                throw new ParameterConversionException("Could not parse " + value + " as Int for parameter '" + name + "'");
            }
        } else if (type.equals("ABS.StdLib.Bool")) {
            if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
                return Boolean.valueOf(value);
            } else {
                throw new ParameterConversionException("Could not parse " + value + " as Bool for parameter '" + name + "'");
            }
        }  else {
            throw new ParameterConversionException(name, value, type);
        }
    }

    /**
     * Common method to send back a response, encoding it properly etc.
     *
     * @param exchange the HTTP request to answer
     * @param status the HTTP status (200, 404, ...)
     * @param contentType {@code "text/plain"}, {@code "text/html"},
     *  {@code "text/json"}, ... -- note that we append {@code ";
     *  charset=UTF-8"} so the charset should not be specified.
     * @param response the response body to send
     * @throws IOException
     */
    private static void sendResponse(HttpExchange exchange, int status, String contentType, byte[] response) throws IOException {
        // we close the inputstream as well so it gets cleared
        // properly -- see
        // https://docs.oracle.com/en/java/javase/21/docs/api/jdk.httpserver/com/sun/net/httpserver/HttpExchange.html#getRequestBody()
        try (InputStream is = exchange.getRequestBody();
             OutputStream os = exchange.getResponseBody()) {
            exchange.getResponseHeaders().set("Content-Type", contentType + "; charset=UTF-8");
            exchange.sendResponseHeaders(status, response.length);
            os.write(response);
        }
    }

    /**
     * Send back a response.
     *
     * @see #sendResponse(HttpExchange, int, String, byte[])
     */
    private static void sendResponse(HttpExchange exchange, int status, String contentType, String response) throws IOException {
        sendResponse(exchange, status, contentType, response.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Send a generic 404 response.
     *
     * @see #sendResponse(HttpExchange, int, String, byte[])
     */
    private static void send404(HttpExchange exchange) throws IOException {
        sendResponse(exchange, 404, "text/plain",
            "404 (Not Found)".getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Returns the contents of the named resource or null.
     */
    private static byte[] loadResource(String path) {
        try (InputStream is = ModelApi.class.getResourceAsStream(path)) {
            if (is == null) return null;
            return is.readAllBytes();
        } catch (IOException e) {
            return null;
        }
    }

    public static Object absToJson(Object value) {
        switch (value) {
            case null: return null;
            case ABSObject o: return o.toString();
            case ABSFut<?> f: return f.toString();
            case ABSUnit u: return "Unit";
            case Boolean b: return b;
            case String s: return s;
            case Apint i: return i.toBigInteger();
            case Aprational r: return r.doubleValue();
            case Double f: return f;
            case ABSAlgebraicDataType d:
                return d.toJson();
            default:
                throw new RuntimeException("Trying to serialize a value of type " + value.getClass().getName() + "; this should never happen");
        }
    }

}
