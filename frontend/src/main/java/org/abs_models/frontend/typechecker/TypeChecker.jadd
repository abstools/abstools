/* $Id$ */
import org.abs_models.common.*;

import org.abs_models.frontend.analyser.ErrorMessage;
import org.abs_models.frontend.analyser.TypeError;
import org.abs_models.frontend.typechecker.*;

import org.abs_models.frontend.typechecker.TypeCheckerHelper;

import java.util.HashMap;

aspect TypeChecker {

    /* typeCheck() is already cached, no need to cache this simple getter. */
    public boolean Model.hasTypeErrors() { return typeCheck().containsErrors(); }

    syn lazy SemanticConditionList Model.typeCheck() {
        SemanticConditionList res = new SemanticConditionList();
        typeCheck(res);
        return res;
    }

    /**
     * @see #typeCheck()
     */
    public SemanticConditionList Model.getTypeErrors() {
        return typeCheck();
    }

    public void Model.typeCheck(SemanticConditionList errors) {
        try {
            TypeCheckerHelper.checkForDuplicateModulesAndDeltas(errors, getCompilationUnits());
            TypeCheckerHelper.checkForDuplicateProducts(errors, getCompilationUnits());
            for (CompilationUnit u : getCompilationUnits()) {
                u.typeCheck(errors);
            }
        } catch (TypeCheckerException e) {
            errors.add(e);
        }
    }

    public void ModuleDecl.typeCheck(SemanticConditionList e) {
        for (Import i : getImports()) {
            i.typeCheck(e);
        }

        for (Export ex : getExports()) {
            ex.typeCheck(e);
        }

        TypeCheckerHelper.checkForDuplicateDecls(this,e);

        for (Decl d : getDecls()) {
            if (d.getName().indexOf('.') != -1) {
                e.add(new TypeError(d, ErrorMessage.NO_QUALIFIED_NAMES_IN_CORE_DECLARATION, d.getName()));
            }
            d.typeCheck(e);
        }

        if (hasBlock()) {
            getBlock().typeCheck(e);
        }
    }

    public void CompilationUnit.typeCheck(SemanticConditionList e) {
        for (ModuleDecl d : getModuleDecls()) {
            d.typeCheck(e);
        }
    }

    public abstract void Import.typeCheck(SemanticConditionList e);

    public void NamedImport.typeCheck(SemanticConditionList e) {
        for (Name name : getNames()) {
            if (name.isSimple()) {
                e.add(new TypeError(this, ErrorMessage.ONLY_QUALIFIED_NAMES_ALLOWED, name.getName()));
                continue;
            }

            ModuleDecl d = lookupModule(name.getModuleName());
            if (d == null) {
                e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, name.getModuleName()));
                continue;
            }

            if (!d.exportsName(name.getSimpleName())) {
                e.add(new TypeError(this, ErrorMessage.NAME_NOT_EXPORTED_BY_MODULE, name.getSimpleName(), name.getModuleName()));
            }
        }
    }

    public void StarImport.typeCheck(SemanticConditionList e) {
        ModuleDecl d = lookupModule(getModuleName());
        if (d == null) {
            e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
        }
    }

    public void FromImport.typeCheck(SemanticConditionList e) {
        ModuleDecl d = lookupModule(getModuleName());
        if (d == null) {
            e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
            return;
        }

        for (Name name : getNames()) {
            if (!name.isSimple()) {
                e.add(new TypeError(name, ErrorMessage.ONLY_UNQUALIFIED_NAMES_ALLOWED_IN_IMPORT, name.getName()));
            } else {
                if (!d.exportsName(name.getName())) {
                    e.add(new TypeError(name, ErrorMessage.NAME_NOT_EXPORTED_BY_MODULE, name.getName(), getModuleName()));
                }
            }
        }
    }

    public abstract void Export.typeCheck(SemanticConditionList e);

    public void NamedExport.typeCheck(SemanticConditionList e) {
        ModuleDecl mod = getModuleDecl();
        for (Name name: getNames()) {
            String s = name.getName();
            if (name.isSimpleName()) {
                if (!mod.isDefined(s)) {
                    ResolvedMap m = mod.getVisibleNames().getAllNames(s);
                    if (m.isEmpty()) {
                        e.add(new TypeError(name, ErrorMessage.NAME_NOT_RESOLVABLE, s));
                    } else {
                        ResolvedName n = m.values().iterator().next();
                        // give a hint on how to re-export
                        e.add(new SemanticWarning(name, ErrorMessage.NO_IMPLICIT_NAME_REEXPORT, s, s, n.getQualifiedName().getModuleName()));
                    }
                }
            } else {
                if (!mod.isVisible(s)) {
                    e.add(new TypeError(name, ErrorMessage.NAME_NOT_RESOLVABLE, s + " as qualified name, not visible"));
                }
            }
        }
    }

    public void FromExport.typeCheck(SemanticConditionList e) {
        ModuleDecl d = lookupModule(getModuleName());
        if (d == null) {
            e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
            return;
        }

        ModuleDecl mod = getModuleDecl();
        for (Name name: getNames()) {
            if (name.isQualifiedName()) {
                e.add(new TypeError(name, ErrorMessage.ONLY_UNQUALIFIED_NAMES_ALLOWED_IN_EXPORT, name.getName()));
            } else {
                String s = d.getName()+"."+name.getName();
                if (!mod.isVisible(s)) {
                    e.add(new TypeError(name, ErrorMessage.NAME_NOT_RESOLVABLE, s));
                }
            }
        }
    }

    public void StarExport.typeCheck(SemanticConditionList e) {
        if (hasModuleName()) {
            ModuleDecl d = lookupModule(getModuleName().getName());
            if (d == null) {
                e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName().getName()));
                return;
            }
        }
    }

    public Collection<MethodSig> ClassDecl.getAllMethodSigs() {
        HashMap<String, MethodSig> sigs = new HashMap<String, MethodSig>();
        for (MethodImpl m : getMethods()) {
            String name = m.getMethodSig().getName();
            sigs.put(name,m.getMethodSig());
        }
        return sigs.values();
    }

    public Collection<MethodSig> InterfaceDecl.getAllMethodSigs() {
        HashMap<String, MethodSig> sigs = new HashMap<String, MethodSig>();
        addAllMethodSigs(sigs, new HashSet<InterfaceDecl>());
        return sigs.values();
    }

    // DECLS
    public void InterfaceDecl.addAllMethodSigs(HashMap<String, MethodSig> sigs, HashSet<InterfaceDecl> visitedDecls) {
        if (visitedDecls.contains(this))
            return;
        visitedDecls.add(this);

        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            Decl d = u.getDecl();
            if (d.isInterface()) {
                InterfaceDecl id = (InterfaceDecl) d;
                id.addAllMethodSigs(sigs,visitedDecls);
            }
        }

        for (MethodSig s : getBodys()) {
            sigs.put(s.getName(),s);
        }
    }

    public void ClassDecl.addAllMethodSigs(HashMap<String, MethodSig> sigs, SemanticConditionList e) {
        for (InterfaceTypeUse u : getImplementedInterfaceUses()) {
            Decl d = u.getDecl();
            if (d.isInterface()) {
                InterfaceDecl id = (InterfaceDecl) d;
                HashMap<String, MethodSig> mysigs = new HashMap<String, MethodSig>();
                id.addAllMethodSigs(mysigs, new HashSet<InterfaceDecl>());
                checkOverloading(sigs,mysigs,u,e);
                mysigs.putAll(sigs);
                sigs.clear();
                sigs.putAll(mysigs);
            }
        }
    }

    protected void Decl.checkOverloading(HashMap<String, MethodSig> sigs, HashMap<String, MethodSig> mysigs, InterfaceTypeUse u, SemanticConditionList e) {
        for (Map.Entry<String, MethodSig> entry : mysigs.entrySet()) {
            MethodSig s = sigs.get(entry.getKey());
            if (s != null) {
                boolean overloads = false;
                MethodSig ms = entry.getValue();
                if (s.getNumParam() != ms.getNumParam()) {
                    overloads = true;
                } else {
                    for (int i = 0; i < s.getNumParam(); i++) {
                        Type texpected = s.getParam(i).getType();
                        Type t = ms.getParam(i).getType();
                        overloads |= !texpected.equals(t);
                    }
                }

                Type expectedReturnType = s.getReturnType().getType();
                Type actualReturnType = ms.getReturnType().getType();
                overloads |= !expectedReturnType.equals(actualReturnType);
                if (overloads) {
                    e.add(new TypeError(u, ErrorMessage.CANNOT_IMPL_INTERFACE, u.getName(), s.getName()));
                }
            }
        }

    }

    public abstract void Decl.typeCheck(SemanticConditionList e);

    public void ClassDecl.typeCheck(SemanticConditionList e) {
        Set<String> fields = new HashSet<String>();
        for (ParamDecl d : getParams()) {
            d.typeCheck(e);
            if (!fields.add(d.getName())) {
                e.add(new TypeError(d, ErrorMessage.DUPLICATE_FIELD_NAME, d.getName()));
            }
        }

        for (InterfaceTypeUse i : getImplementedInterfaceUses()) {
            i.typeCheck(e);
        }

        for (FieldDecl f : getFields()) {
            f.typeCheck(e);
            if (!fields.add(f.getName())) {
                e.add(new TypeError(f, ErrorMessage.DUPLICATE_FIELD_NAME, f.getName()));
            }
        }

        if (hasInitBlock()) {
            getInitBlock().typeCheck(e);
            getInitBlock().checkLegalInit(e, ErrorMessage.NOT_ALLOWED_IN_INIT_CODE);
        }
        for (CaseBranchStmt recoverBranch : getRecoverBranchList()) {
            recoverBranch.getLeft().typeCheck(e, getModel().getExceptionType());
            recoverBranch.getRight().typeCheck(e);
            recoverBranch.getRight().checkLegalInit(e, ErrorMessage.NOT_ALLOWED_IN_RECOVER_CODE);
        }

        HashMap<String, MethodSig> sigs = new HashMap<String, MethodSig>();
        addAllMethodSigs(sigs,e);

        HashMap<String, MethodImpl> methodImpls = new HashMap<String, MethodImpl>();

        for (MethodImpl m : getMethods()) {
            m.typeCheck(e);
            String name = m.getMethodSig().getName();
            if (methodImpls.put(name,m) != null) {
                e.add(new TypeError(m, ErrorMessage.DUPLICATE_METHOD_NAME, name));
            }
            MethodSig s = sigs.get(name);
            if (s != null) {
                MethodSig ms = m.getMethodSig();
                InterfaceDecl d = (InterfaceDecl) s.getParent().getParent();
                if (s.getNumParam() != ms.getNumParam()) {
                    e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_NUM_PARAMS, name, d.getName(), ""+s.getNumParam(), ""+ms.getNumParam()));
                } else {
                    for (int i = 0; i < s.getNumParam(); i++) {
                        Type texpected = s.getParam(i).getType();
                        Type t = ms.getParam(i).getType();
                        if (!texpected.equals(t)) {
                            e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_PARAM_TYPE,
                                    ms.getParam(i).getName(), name, d.getName(),
                                    texpected.toString(), t.toString()));
                        }
                    }
                }

                Type expectedReturnType = s.getReturnType().getType();
                Type actualReturnType = ms.getReturnType().getType();
                if (!expectedReturnType.equals(actualReturnType)) {
                    e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_RETURN_TYPE,
                            name, d.getName(),
                            expectedReturnType.toString(), actualReturnType.toString()));

                }
            }
        }

        for (MethodSig s : sigs.values()) {
            if (!methodImpls.containsKey(s.getName())) {
                ASTNode<?> location = this;
                InterfaceDecl d = (InterfaceDecl) s.getParent().getParent();
                // find the location where the error should be marked:
                for (InterfaceTypeUse implementedInterface : getImplementedInterfaceUses()) {
                    if (implementedInterface.getDecl().getType().isAssignableTo(d.getType())) {
                        location = implementedInterface;
                        break;
                    }
                }
                e.add(new TypeError(location, ErrorMessage.METHOD_NOT_IMPLEMENTED, s.getName(), d.getName(), getName()));
            }
        }

    }

    public void FunctionDecl.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        TypeCheckerHelper.typeCheckParamList(e,this);
        getTypeUse().typeCheck(e);
        if (getFunctionDef() instanceof ExpFunctionDef) {
            ExpFunctionDef def = (ExpFunctionDef)getFunctionDef();
            def.getRhs().typeCheck(e);
            if (nerrors == e.getErrorCount()) {
                TypeCheckerHelper.checkAssignment(e,this,getTypeUse().getType(), def.getRhs());
            }
        } else {
	    BuiltinFunctionDef def = (BuiltinFunctionDef)getFunctionDef();
	    // do not use def.isSQLiteQuery() here since we want to
	    // detect incorrect argument counts etc.
	    if (def.getNumArgument() > 0
		&& def.getArgument(0) instanceof VarOrFieldUse
		&& ((VarUse)def.getArgument(0)).getName().equals("sqlite3"))
	    {
		// check function result type: must be a list of basic type or type with constructor.
		if (!TypeCheckerHelper.isValidSQLite3ReturnType(getTypeUse().getType())) {
		    e.add(new TypeError(getTypeUse(), ErrorMessage.SQLITE3_INCORRECT_RETURN_TYPE, ""));
		}
		// check `builtin' parameters
		if (def.getNumArgument() < 3) {
		    e.add(new TypeError(def, ErrorMessage.SQLITE3_INCORRECT_ARGUMENTS, ""));
		} else if (!(def.getArgument(1) instanceof StringLiteral)) {
		    e.add(new TypeError(def.getArgument(1), ErrorMessage.SQLITE3_INCORRECT_ARGUMENTS, ""));
		} else if ((!(def.getArgument(2) instanceof StringLiteral))) {
		    e.add(new TypeError(def.getArgument(2), ErrorMessage.SQLITE3_INCORRECT_ARGUMENTS, ""));
		}
                for (int i = 3; i < def.getNumArgument(); i++) {
                    if (!(def.getArgument(i) instanceof PureExp)) {
                        e.add(new TypeError(def.getArgument(i), ErrorMessage.SQLITE3_INCORRECT_QUERY_ARGUMENT, ""));
                        continue;
                    }
                    PureExp arg = (PureExp)def.getArgument(i);
                    if (!TypeCheckerHelper.isValidSQLite3ArgumentType(arg.getType())) {
                        e.add(new TypeError(def.getArgument(i), ErrorMessage.SQLITE3_INCORRECT_QUERY_ARGUMENT, ""));
                    }
                }
	    }
        }
    }

    public void ParametricFunctionDecl.typeCheck(SemanticConditionList e) {
        // Selectors are generated, and assumed to be type correct.
        if (isSelector()) {
            return;
        }
        super.typeCheck(e);
        HashSet<String> names = new HashSet<String>();
        for (TypeParameterDecl d : getTypeParameters()) {
            d.typeCheck(e);
            if (!names.add(d.getName())) {
                e.add(new TypeError(d, ErrorMessage.DUPLICATE_DATATYPE_PARAMETER, d.getName()));
            }
            if (!lookup(new KindedName(Kind.TYPE_DECL,d.getName())).isUnknown()) {
                e.add(new TypeError(d, ErrorMessage.EXISTING_DATATYPE_PARAMETER,
                                    d.getName()));
            }
        }
    }

    public void PartialFunctionDecl.typeCheck(SemanticConditionList e) {}
    public void ParFnApp.typeCheck(SemanticConditionList e) {}

    public void InterfaceDecl.checkCycle(SemanticConditionList e, InterfaceDecl d) {
        if (this == d) {
            e.add(new TypeError(d, ErrorMessage.CYCLIC_INHERITANCE, getName()));
        } else {
            for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
                Decl id = u.getDecl();
                if (id.isInterface()) {
                    ((InterfaceDecl)id).checkCycle(e,d);
                }
            }
        }
    }

    public void TraitDecl.typeCheck(SemanticConditionList e) {}

    public void InterfaceDecl.typeCheck(SemanticConditionList e) {
        HashMap<String, MethodSig> names = new HashMap<String, MethodSig>();
        for (MethodSig s : getBodys()) {
            if (names.put(s.getName(),s) != null)
                e.add(new TypeError(s, ErrorMessage.DUPLICATE_METHOD_NAME, s.getName()));
            if (s.getName().equals("run")) {
                TypeCheckerHelper.typeCheckRunMethodSig(e, s);
            }
            s.typeCheck(e);
        }

        HashMap<String, MethodSig> sigs = new HashMap<String, MethodSig>();
        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            Decl d = u.getDecl();
            if (!d.isInterface()) {
                e.add(new TypeError(u, ErrorMessage.ONLY_INTERFACE_EXTEND, d.getName()));
            } else {
                InterfaceDecl id = (InterfaceDecl) d;
                id.checkCycle(e,this);

                HashMap<String, MethodSig> mysigs = new HashMap<String, MethodSig>();
                id.addAllMethodSigs(mysigs, new HashSet<InterfaceDecl>());
                checkOverloading(sigs,mysigs,u,e);
                mysigs.putAll(sigs);
                sigs.clear();
                sigs.putAll(mysigs);

                for (MethodSig s : id.getBodys()) {
                    if (names.containsKey(s.getName())) {
                        e.add(new TypeError(names.get(s.getName()), ErrorMessage.NO_METHOD_OVERRIDE, s.getName(), id.getName()));
                    }
                }
            }
        }
    }

    public void MethodSig.typeCheck(SemanticConditionList e) {
        getReturnType().typeCheck(e);
        TypeCheckerHelper.typeCheckParamList(e,this);
    }

    public void DataTypeDecl.typeCheck(SemanticConditionList e) {
        HashSet<String> names = new HashSet<String>();
        HashMap<String, Type> argumentType = new HashMap<String, Type>();
        for (DataConstructor c : getDataConstructors()) {
            c.typeCheck(e);
            if (!names.add(c.getName())) {
                e.add(new TypeError(c, ErrorMessage.DUPLICATE_CONSTRUCTOR, c.getName(),
                                    // TODO add " at file:line" with location of first constructor
                                    ""));
            }
            // Record the type associated with each selector name, and ensure
            // it is the same for every selector with the same name
            for (ConstructorArg ca : c.getConstructorArgs()) {
                if (!ca.hasSelectorName())
                    continue;
                String argName = ca.getSelectorName().getName();
                Type t1 = ca.getType();
                Type t2 = argumentType.get(argName);
                if (t2 != null && !t1.equals(t2)) {
                    e.add(new TypeError(ca, ErrorMessage.ACESSOR_INCOMPARABLE_TYPE, t1, t2));
                } else {
                    argumentType.put(argName, t1);
                }
            }
        }
    }

    public void ParametricDataTypeDecl.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        HashSet<String> names = new HashSet<String>();
        for (TypeParameterDecl d : getTypeParameters()) {
            d.typeCheck(e);
            if (!names.add(d.getName())) {
                e.add(new TypeError(d, ErrorMessage.DUPLICATE_DATATYPE_PARAMETER, d.getName()));
            }
            if (!lookup(new KindedName(Kind.TYPE_DECL,d.getName())).isUnknown()) {
                e.add(new TypeError(d, ErrorMessage.EXISTING_DATATYPE_PARAMETER,
                                    d.getName()));
            }
        }
    }

    public void DataConstructor.typeCheck(SemanticConditionList e) {
        for (ConstructorArg d : getConstructorArgs()) {
            d.typeCheck(e);
        }
    }

    public void ExceptionConstructor.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
    }

    public void ConstructorArg.typeCheck(SemanticConditionList e) {
        getTypeUse().typeCheck(e);
    }

    public void ExceptionDecl.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
    }

    public void TypeSynDecl.typeCheck(SemanticConditionList e) {
        if (getValue().getName().equals(getName()))
            e.add(new TypeCheckerException(new TypeError(getValue(), ErrorMessage.CIRCULAR_TYPESYN, getName())));
        else
            getValue().typeCheck(e);
    }

    public void TypeParameterDecl.typeCheck(SemanticConditionList e) {
        /* nothing to check */ }

    public void UnknownDecl.typeCheck(SemanticConditionList e) {
    /* nothing to check */ }

    public void Block.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        for (Stmt s : getStmts()) {
            s.typeCheck(e);
        }
    }

    public void MainBlock.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        if (getNumStmt() > 0) {
            Stmt lastStmt = getStmt(getNumStmt()-1);
            if (lastStmt instanceof ReturnStmt) {
                e.add(new TypeError(lastStmt, ErrorMessage.MAIN_BLOCK_RETURN_STMT, "dummy"));
            }
        }
    }

    /**
     * Proxy.
     * @see MethodImpl#getType()
     */
    public Type MethodImpl.getType() { return getMethodSig().getType(); }

    public boolean MethodImpl.hasReturnStmt() {
        Block b = getBlock();
        if (b.getNumStmt() > 0) {
            Stmt lastStmt = b.getStmt(b.getNumStmt() - 1);
            return lastStmt instanceof ReturnStmt;
        } else {
            return false;
        }
    }

    public void MethodImpl.typeCheck(SemanticConditionList e) {
        Block b = getBlock();
        MethodSig sig = getMethodSig();
        sig.typeCheck(e);
        b.typeCheck(e);

        if (sig.getName().equals("run")) {
            TypeCheckerHelper.typeCheckRunMethodSig(e, sig);
        }

        Type lastType = getMethodSig().getReturnType().getType();
        if (hasReturnStmt()) {
            Stmt lastStmt = b.getStmt(b.getNumStmt() - 1);
            ReturnStmt rs = (ReturnStmt) lastStmt;
            Type rht = rs.getRetExp().getType();
            // if UnknownType, ReturnStmt.typeCheck will report an error already
            if (!rht.isUnknownType() && !rht.isAssignableTo(lastType)) {
                e.add(new TypeError(rs,ErrorMessage.WRONG_RETURN_STMT_TYPE,rht.toString(),sig.getName(),lastType.toString()));
            }
        } else {
            if (!lastType.isUnitType()) {
                // need return stmt
                e.add(new TypeError(this,ErrorMessage.METHOD_IMPL_MISSING_RETURN_STMT, sig.getName()));
            }
        }
    }

    public void VarDecl.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getTypeUse().typeCheck(e);
        if (e.getErrorCount() > nerrors) return;

        Type t = getTypeUse().getType();
        if (hasInitExp()) {
            getInitExp().typeCheck(e);
            if (e.getErrorCount() > nerrors) return;
            TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
        } else {
            if (!t.isReferenceType() && !t.isFutureType()) {
                e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
            }
        }
    }

    public void FieldDecl.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getTypeUse().typeCheck(e);
        if (e.getErrorCount() > nerrors) return;

        Type t = getTypeUse().getType();
        if (hasInitExp()) {
            getInitExp().typeCheck(e);
            if (e.getErrorCount() > nerrors) return;
            TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
        } else {
            if (!t.isReferenceType() && !t.isFutureType()) {
                e.add(new TypeError(this, ErrorMessage.FIELD_INIT_REQUIRED, new String[0]));
            }
        }
    }

    public void ParamDecl.typeCheck(SemanticConditionList e) {
        getTypeUse().typeCheck(e);
    }

    /**
     * checks if a declaration is unknown and adds an appropriate error message to the semantic error list
     * @param use the use of the declaration (this is where the error will be shown)
     * @param e the semantic error list
     * @param errorMessage the error message for unknown declarations
     * @param name the name of the declaration (used in the error message)
     * @return true if the declaration is unknown, false otherwise
     */
    protected boolean Decl.checkDecl(ASTNode<?> use, SemanticConditionList e, ErrorMessage errorMessage, String name) {
        return true;
    }
    @Override
    protected boolean UnknownDecl.checkDecl(ASTNode<?> use, SemanticConditionList e, ErrorMessage errorMessage, String name) {
        e.add(new TypeError(use, errorMessage, name));
        return false;
    }
    @Override
    protected boolean AmbiguousDecl.checkDecl(ASTNode<?> use, SemanticConditionList e, ErrorMessage errorMessage, String name) {
        e.add(new TypeError(use, ErrorMessage.AMBIGIOUS_USE, name, TypeCheckerHelper.getAlternativesAsString(this)));
        return false;
    }

    // STMTS

    public void Stmt.typeCheck(SemanticConditionList e) {
    }

    public void ExpressionStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getExp().typeCheck(e);
    }

    public void VarDeclStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getVarDecl().typeCheck(e);
        TypeCheckerHelper.checkForDuplicatesOfVarDecl(e, this);
    }

    public void AssignStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        int nerrors = e.getErrorCount();
        getValue().typeCheck(e);
        getVar().typeCheck(e);

        if (e.getErrorCount() > nerrors)
            return;
        TypeCheckerHelper.checkAssignment(e,this,getVar().getType(),getValue());
    }

    public void MoveCogToStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        int nerrors = e.getErrorCount();
        getTarget().typeCheck(e);
        if (e.getErrorCount() > nerrors) return;
        Type t = getTarget().getType();
        Decl d = t.getDecl();
        if (d == null) {
          e.add(new TypeError(this, ErrorMessage.EXPECTED_DC, t));
          return;
        }
        if (!"DeploymentComponent".equals(d.getName())) {
            e.add(new TypeError(this, ErrorMessage.EXPECTED_DC, t));
        }
    }

    public void ReturnStmt.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        super.typeCheck(e);
        getRetExp().typeCheck(e);

        MethodImpl m = getContextMethod();
        Block block = getContextBlock();

        if (m != null) {
            block = m.getBlock();
        }

        Stmt lastStmt = block.getStmt(block.getNumStmt()-1);
        if (lastStmt != this) {
            // this also catches a return statement in the middle of a main
            // block, when we don't have an enclosing method (m == null)
            e.add(new TypeError(this, ErrorMessage.RETURN_STMT_MUST_BE_LAST, new String[0]));
        }
    }

    public void AwaitStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getGuard().typeCheck(e);
    }

    public void SuspendStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
    }

    public void DurationStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getMin().typeCheck(e);
        getMax().typeCheck(e);
        getMin().assertHasType(e, getModel().getRatType());
        getMax().assertHasType(e, getModel().getRatType());
    }

    public void IfStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getCondition().typeCheck(e);
        getCondition().assertHasType(e,getModel().getBoolType());
        getThen().typeCheck(e);
        if (hasElse())
            getElse().typeCheck(e);

    }

    public void WhileStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getCondition().typeCheck(e);
        getCondition().assertHasType(e,getModel().getBoolType());
        getBody().typeCheck(e);
    }

    public void ForeachStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);

        getListExp().typeCheck(e);
        // assertHasType() is too specific -- we need to check that ListExp is
        // a list, not its specific type (List<Int>)
        if (!getListExp().getType().isUnknownType()
            && !getListExp().getType().getDecl().getQualifiedName()
                .equals(getModel().getListType().getDecl().getQualifiedName())) {
            e.add(new TypeError(getListExp(), ErrorMessage.EXPECTED_TYPE,
                                getModel().getListType().getDecl().getQualifiedName(),
                                getListExp().getType().getDecl().getQualifiedName()));
        }
        if (hasIndexVar() && getIndexVar().getName().equals(getValueVar().getName())) {
            e.add(new SemanticError(getIndexVar(), ErrorMessage.LOOP_VARIABLE_ALREADY_IN_USE, getIndexVar().getName()));
        }
        getBody().typeCheck(e);
    }

    public void CaseStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getExpr().typeCheck(e);
        Type et = getExpr().getType();
        if (!et.isDataType()) {
           e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
           return;
        }
        Type t = getType();
        for (CaseBranchStmt b : getBranchs()) {
          b.typeCheck(e,(DataTypeType) et);
        }
    }

    public void CaseStmtOld.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        e.add(new SemanticWarning(this, ErrorMessage.DEPRECATED_CASE_STMT, ""));
    }



    public void CaseBranchStmt.typeCheck(SemanticConditionList e, DataTypeType t) {
        getLeft().typeCheck(e,t);
        getRight().typeCheck(e);
    }

    public void TryCatchFinallyStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        Type exc = getModel().getExceptionType();
        getBody().typeCheck(e);
        for (CaseBranchStmt b : getCatchs()) {
            b.getLeft().typeCheck(e, exc);
            b.getRight().typeCheck(e);
            for (PatternVarUse pv : b.getLeft().getBoundPatternVars()) {
                e.add(new TypeError(pv, ErrorMessage.MATCHING_NOT_ALLOWED_IN_CATCH, pv.getName()));
            }
        }
        if (hasFinally()) {
            getFinally().typeCheck(e);
            getFinally().checkLegalInit(e, ErrorMessage.NOT_ALLOWED_IN_FINALLY_CODE);
        }
    }

    public void SkipStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
    }

    public void AssertStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getCondition().typeCheck(e);
        getCondition().assertHasType(e,getModel().getBoolType());
    }

    // GUARDS
    public abstract void Guard.typeCheck(SemanticConditionList e);
    public void AndGuard.typeCheck(SemanticConditionList e) {
        getLeft().typeCheck(e);
        getRight().typeCheck(e);
    }

    public void ClaimGuard.typeCheck(SemanticConditionList e) {
        getVar().typeCheck(e);
        Type t = getVar().getType();
        if (!t.isFutureType()) {
            e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
        }
    }
    public void ExpGuard.typeCheck(SemanticConditionList e) {
        PureExp exp = getPureExp();
        // We'll only run "deeper" checks if the types check out.
        int size = e.getErrorCount();
        exp.typeCheck(e);
        getPureExp().assertHasType(e,getModel().getBoolType());
        if (e.getErrorCount() == size) {
            // A guard expression must contain at least one field, or it can
            // never change.  "await True" and "await False" are explicit
            // special cases.
            final PureExp pe = getPureExp();
            final FieldUseInfo info = getFields();
            if (info.fields.isEmpty()
                && !info.usesBuiltin
                && (!(pe instanceof DataConstructorExp
                      && ("True".equals(((DataConstructorExp)pe).getConstructor())
                          || "False".equals(((DataConstructorExp)pe).getConstructor())))))
            {
                e.add(new SemanticWarning(this,ErrorMessage.AWAIT_TOO_PURE, ""));
            }
        }
    }
    public void DurationGuard.typeCheck(SemanticConditionList e) {
        getMin().typeCheck(e);
        getMax().typeCheck(e);
        getMin().assertHasType(e, getModel().getRatType());
        getMax().assertHasType(e, getModel().getRatType());
    }

    // EXPRESSIONS

    public void Exp.typeCheck(SemanticConditionList e) { }

    public void ThisExp.typeCheck(SemanticConditionList e) {
      if (getContextDecl().isUnknown())
        e.add(new TypeError(this,ErrorMessage.THIS_STATIC,""));
    }

    public void OriginalCall.typeCheck(SemanticConditionList e) {
        /* We are never typeChecking method bodies within deltas at the moment. #386*/
        e.add(new TypeError(this,ErrorMessage.ORIGINAL_NOT_IN_DELTA,""));
    }

    public void TypeUse.typeCheck(SemanticConditionList e) {
        getDecl().checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName());
    }

    public void DataTypeUse.typeCheck(SemanticConditionList e) {
        if (! getDecl().checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName())) {
            return;
        }
        TypeCheckerHelper.checkDataTypeUse(e, this);
    }

    public void InterfaceTypeUse.typeCheck(SemanticConditionList e) {
        Decl d = getDecl();
        if (! d.checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName())) {
            return;
        }
        if (d instanceof TypeSynDecl) {
            int nerrors = e.getErrorCount();
            d.typeCheck(e);
            if (e.getErrorCount() != nerrors) return; // detect circularity
            while (d instanceof TypeSynDecl) d = ((TypeSynDecl)d).getValue().getDecl();
        }
        if (!(d instanceof InterfaceDecl)) {
            e.add(new SemanticError(this,ErrorMessage.UNKOWN_INTERFACE,getName()));
        }
    }

    public void UnresolvedTypeUse.typeCheck(SemanticConditionList e) {
        e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
    }

    public void VarOrFieldUse.typeCheck(SemanticConditionList e) {
        TypeCheckerHelper.checkDefBeforeUse(e, this);
    }

    public void Call.typeCheck(SemanticConditionList e) {
        getCallee().typeCheck(e);
        if (!getCallee().getType().isReferenceType()) {
            e.add(new TypeError(this, ErrorMessage.EXPECTED_REFERENCE_TYPE, getCallee().getType()));
            return;
        }
        if (getCallee().getType().isNullType()) {
            e.add(new TypeError(this, ErrorMessage.NULL_NOT_HERE, ""));
            return;
        }
        Type t = getType();
        if (t.isUnknownType() || getMethodSig() == null) {
            e.add(new TypeError(this, ErrorMessage.NO_METHOD_DECL, getMethod()));
        } else {
            typeCheckEqualParams(e,getMethodSig());
        }
    }

    public void NewExp.typeCheck(SemanticConditionList e) {
        Decl decl = lookup(new KindedName(Kind.CLASS,getClassName()));
        if (!decl.isClass()) {
            e.add(new TypeError(this, ErrorMessage.NO_CLASS_DECL, getClassName()));
        } else {
            ClassDecl cd = (ClassDecl) decl;
            typeCheckEqualParams(e,cd);
        }
    }

    public void ImplementsExp.typeCheck(SemanticConditionList e) {
        getInterfaceTypeUse().typeCheck(e);
        // TODO: check that getExp() is a reference type
        getExp().typeCheck(e);
        // if (!getExp().getType().isReferenceType()) {
        //     e.add(new TypeError(this, ErrorMessage.UNKOWN_INTERFACE, getInterfaceName()));
        // }
    }

    public void AsExp.typeCheck(SemanticConditionList e) {
        getInterfaceTypeUse().typeCheck(e);
        // TODO: check that getExp() is a reference type
        getExp().typeCheck(e);
        // if (!getExp().getType().isReferenceType()) {
        //     e.add(new TypeError(this, ErrorMessage.UNKOWN_INTERFACE, getInterfaceName()));
        // }
    }


    public void GetExp.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getPureExp().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            if (!getPureExp().getType().isFutureType()) {
                e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType()));
            }
        }
    }

    public void AddAddExp.typeCheck(SemanticConditionList e) {
        // Special case: can also "add" strings.
        int nerrors = e.getErrorCount();
        getLeft().typeCheck(e);
        getRight().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            Type lt = getLeft().getType();
            Type rt = getRight().getType();

            if (! (lt.isNumericType() || lt.isStringType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, lt));
            }
            if (! (rt.isNumericType() || rt.isStringType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, rt));
            }
            if (!lt.isAssignableTo(rt) && !rt.isAssignableTo(lt)) {
                e.add(new TypeError(this, ErrorMessage.ADD_INCOMPARABLE_TYPE, lt, rt));
            }
        }
    }
    public void ArithmeticExp.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getLeft().typeCheck(e);
        getRight().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            Type lt = getLeft().getType();
            Type rt = getRight().getType();

            if (! (lt.isNumericType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_NUMERIC_TYPE, lt));
            }
            if (! (rt.isNumericType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_NUMERIC_TYPE, rt));
            }
            if (!lt.isAssignableTo(rt) && !rt.isAssignableTo(lt)) {
                e.add(new TypeError(this, ErrorMessage.ARITHMETIC_INCOMPATIBLE_TYPE, lt, rt));
            }
        }
    }

    public void BoolExp.typeCheck(SemanticConditionList e) {
        TypeCheckerHelper.typeCheckBinary(e,this,getModel().getBoolType());
    }

    public void RelationalExpr.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getLeft().typeCheck(e);
        getRight().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            Type tl = getLeft().getType();
            Type tr = getRight().getType();
            if (!tl.isAssignableTo(tr) && !tr.isAssignableTo(tl)) {
                e.add(new TypeError(this, ErrorMessage.COMPARISON_INCOMPARABLE_TYPE, tl, tr));
            }
        }
    }

    public void IfExp.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getCondExp().typeCheck(e);
        getThenExp().typeCheck(e);
        getElseExp().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            getCondExp().assertHasType(e,getModel().getBoolType());
            Type tt = getThenExp().getType();
            Type et = getElseExp().getType();
            if (!(et.isAssignableTo(tt) || tt.isAssignableTo(et))) {
                e.add(new TypeError(this, ErrorMessage.IF_DIFFERENT_TYPE, tt, et));
            }
        }
    }

    public void IfExpOld.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        e.add(new SemanticWarning(this, ErrorMessage.DEPRECATED_IF_EXPRESSION, ""));
    }

    public void CaseExp.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getExpr().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            Type et = getExpr().getType();
            if (et.isDataType())  {
                // we do not type-check the branches if we cannot determine
                // our own type
                Type t = getType();
                for (CaseBranch b : getBranchs()) {
                    nerrors = e.getErrorCount();
                    b.typeCheck(e,(DataTypeType) et);
                    if (nerrors == e.getErrorCount()) {
                        Type t2 = b.getType();
                        if (!t2.isAssignableTo(t)) {
                            e.add(new TypeError(this,ErrorMessage.BRANCH_INCOMPARABLE_TYPE,t,t2));
                        }
                    }
                }
            } else {
                e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
            }
        }
    }

    public void CaseBranch.typeCheck(SemanticConditionList e, DataTypeType t) {
        int size = e.getErrorCount();
        getLeft().typeCheck(e,t);
        /* If the LHS is botched, we can't reliably use any variables bound therein. */
        if (e.getErrorCount() == size)
          getRight().typeCheck(e);
    }

    public void FnApp.typeCheck(SemanticConditionList e) {
        Decl d = getDecl();
        if (!d.isFunction()) {
            e.add(new TypeError(this,ErrorMessage.FUNCTION_NOT_RESOLVABLE,getName()));
        } else {
            int size = e.getErrorCount();
            for (PureExp p : getParams()) {
                p.typeCheck(e);
            }
            if (e.getErrorCount() == size) {
                ((FunctionDecl)d).typeCheckParams(e, this);
            }
        }
    }

    void FunctionDecl.typeCheckParams(SemanticConditionList e, FnApp fa) {
        fa.typeCheckEqualParams(e,this);
    }

    void ParametricFunctionDecl.typeCheckParams(SemanticConditionList e, FnApp fa) {
        TypeCheckerHelper.typeCheckMatchingParams(e,fa,this);
    }

    public Map<TypeParameter, Type> FnApp.getTypeParamBindingFromParamDecl(ParametricFunctionDecl node) {
        return getTypeParamBinding(this, node);
    }

    public void DataConstructorExp.typeCheck(SemanticConditionList e) {
        Decl decl = getDecl();
        if (!(decl instanceof DataConstructor)) {
            e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
        } else {
            DataConstructor c = (DataConstructor) decl;
            String cname = c.getQualifiedName();
            // Warn about using constructors that should not have been
            // exported from their module
            if (TypeCheckerHelper.deprecatedConstructors.contains(cname)
                && !(cname.startsWith(getModuleDecl().getName()))) {
                e.add(new SemanticWarning(this, ErrorMessage.DEPRECATED_CONSTRUCTOR, c.getQualifiedName()));
            }

            if (c.getDataTypeDecl() instanceof ParametricDataTypeDecl) {
                TypeCheckerHelper.typeCheckMatchingParams(e,this,c);
            } else {
                TypeCheckerHelper.typeCheckEqual(e,this,c.getTypes());
            }
        }

    }
    public void LetExp.typeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getVar().typeCheck(e);
        getVal().typeCheck(e);
        getExp().typeCheck(e);
        if (nerrors == e.getErrorCount()) {
            TypeCheckerHelper.checkAssignment(e,this,getVar().getTypeUse().getType(),getVal());
        }
    }

    public void MinusExp.typeCheck(SemanticConditionList e) {
         int size = e.getErrorCount();
         getOperand().typeCheck(e);
         if (e.getErrorCount() == size) {
             if (!getOperand().getType().isNumericType()) {
                 e.add(new TypeError(getOperand(), ErrorMessage.EXPECTED_NUMERIC_TYPE,
                                     getOperand().getType()));
             }
         }
    }

    public void NegExp.typeCheck(SemanticConditionList e) {
        int size = e.getErrorCount();
        getOperand().typeCheck(e);
        if (e.getErrorCount() == size) {
            getOperand().assertHasType(e,getModel().getBoolType());
        }
    }

    public void ListLiteral.typeCheck(SemanticConditionList e) {
        int size = e.getErrorCount();
        for (PureExp exp : getPureExps()) {
            exp.typeCheck(e);
        }
        if (e.getErrorCount() != size) return;
        Type acc = UnknownType.INSTANCE;
        for (PureExp exp : getPureExps()) {
            Type expt = exp.getType();
            if (acc.isUnknownType())  {
                // looking at first param
                acc = expt;
            } else {
                if (!expt.isAssignableTo(acc) && !acc.isAssignableTo(expt)) {
                    e.add(new TypeError(exp, ErrorMessage.LIST_LITERAL_TYPE_MISMATCH, acc, expt));
                    break;
                }
                if (acc.isAssignableTo(expt)) {
                    acc = expt;
                }
            }
        }
    }

    // PATTERNS

    public void Pattern.typeCheck(SemanticConditionList e, Type t) {  }

    public void PatternVarUse.typeCheck(SemanticConditionList e, Type t) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }

    public void LiteralPattern.typeCheck(SemanticConditionList e, Type t) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }

    public void ConstructorPattern.typeCheck(SemanticConditionList e, Type t) {
        TypeCheckerHelper.typeCheck(this,e,t);
    }

    public void Exp.assertHasType(SemanticConditionList l, Type t) {
        if (!getType().isAssignableTo(t)) {
            l.add(new TypeError(this, ErrorMessage.EXPECTED_TYPE, t, getType()));
        }
    }
    //ASPECT
    public void ThrowStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getReason().typeCheck(e);
        getReason().assertHasType(e,getModel().getExceptionType());
    }

    public void DieStmt.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        getReason().typeCheck(e);
        getReason().assertHasType(e,getModel().getExceptionType());
    }


}

aspect TypeCheckProductline {

    refine TypeChecker public void CompilationUnit.typeCheck(SemanticConditionList e) {
        refined(e);
        for (DeltaDecl d : getDeltaDecls()) {
            d.typeCheck(e);
        }
        for (ProductDecl p : getProductDecls()) {
            p.typeCheck(e);
        }
        if (hasProductLine())
            getProductLine().typeCheck(e);
    }

    protected void DeltaDecl.typeCheck(SemanticConditionList e) {
        if (hasImportedModule()) {
            getImportedModule().typeCheck(e);
        }
        for (ModuleModifier mod : getModuleModifiers())
            mod.typeCheck(e);
    }

    public void DeltaAccess.typeCheck(SemanticConditionList e) {
        ModuleDecl d = lookupModule(getModuleName());
        if (d == null) {
            e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
        }
    }

    protected void ModuleModifier.typeCheck(SemanticConditionList e) {
        // Just check the module, the rest is done in the subclass
        ModuleDecl d = lookupModule(targetModuleName());
        if (d == null) {
            if (new Name(getName()).isSimple()) {
                e.add(new TypeError(this, ErrorMessage.SIMPLE_NAME_IN_DELTA_WITHOUT_USE, getName()));
            } else {
                e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, targetModuleName()));
            }
        }
    }

    protected void AddClassModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO
    }
    protected void RemoveClassModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void ModifyClassModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void AddInterfaceModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void RemoveInterfaceModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void ModifyInterfaceModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void AddDataTypeModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void ModifyDataTypeModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void AddFunctionModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void AddTypeSynModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }
    protected void ModifyTypeSynModifier.typeCheck(SemanticConditionList e) {
        super.typeCheck(e);
        //TODO

    }


    protected void ProductDecl.typeCheck(SemanticConditionList e) {
        Map<String,Feature> featureNames = null;
        Model m = getModel();
        if (m.hasProductLine()) {
            featureNames = new HashMap<String,Feature>();
            for (Feature f : m.getProductLine().getFeatures()) {
                featureNames.put(f.getName(),f);
            }
        }
        HashSet<String> productNames = new HashSet<String>();
        for (ProductDecl prod : m.getProductDecls()) {
            productNames.add(prod.getName());
        }
        TypeCheckerHelper.typeCheckProductDecl(this, featureNames, productNames, m.getDeltaDeclsMap(), e);
    }

    protected void ProductLine.typeCheck(SemanticConditionList e) {
        Set<String> definedFeatures = getDeclaredFeatures();
        // TODO: check for undeclared features?

        Set<String> seenDeltas = new HashSet<String>();
        HashSet<String> deadDeltas = new HashSet<String>(getModel().getDeltaDeclsMap().keySet());
        for (DeltaClause dc : getDeltaClauses()) {
            if (! seenDeltas.add(dc.getDeltaspec().getDeltaID()))
                e.add(new SemanticError(dc, ErrorMessage.DUPLICATE_DELTA_CLAUSE, dc.getDeltaspec().getDeltaID(), this.getName()));
            dc.typeCheck(getModel().getDeltaDeclsMap(), definedFeatures, e);
            deadDeltas.remove(dc.getDeltaspec().getDeltaID());
        }
        // Warn about DeltaDecls missing a DeltaClause in the ProductLine declaration
        if (! deadDeltas.isEmpty())
            e.add(new SemanticWarning(this, ErrorMessage.MISSING_DELTA_CLAUSE, getName(), StringUtils.join(",", deadDeltas)));

        Set<String> fs = new HashSet<String>();
        for (Feature f : getFeatures()) {
            if (!fs.add(f.getName()))
                e.add(new SemanticError(f, ErrorMessage.DUPLICATE_FEATURE, f.getName()));
        }
    }

	public abstract boolean Value.isAssignableTo(Type t);
	public boolean BoolVal.isAssignableTo(Type t) {
		return t.isBoolType();
	}
	public boolean StringVal.isAssignableTo(Type t) {
            return t.isStringType();
	}
	public boolean IntVal.isAssignableTo(Type t) {
		return t.isNumericType();
	}
        public boolean UnknownVal.isAssignableTo(Type t) {
            return false;
	}


    protected void DeltaClause.typeCheck(Map<String,DeltaDecl> ds, Set<String> definedFeatures, SemanticConditionList e) {
        TypeCheckerHelper.typeCheckDeltaClause(this, ds, definedFeatures, e);
    }

    public abstract void AppCond.typeCheck(Set<String> definedFeatures, SemanticConditionList e);
    public void AppCondAnd.typeCheck(Set<String> definedFeatures, SemanticConditionList e) {
        getLeft().typeCheck(definedFeatures, e);
        getRight().typeCheck(definedFeatures, e);
    }
    public void AppCondOr.typeCheck(Set<String> definedFeatures, SemanticConditionList e) {
        getLeft().typeCheck(definedFeatures, e);
        getRight().typeCheck(definedFeatures, e);
    }
    public void AppCondNot.typeCheck(Set<String> definedFeatures, SemanticConditionList e) {
        getAppCond().typeCheck(definedFeatures, e);
    }
    public void AppCondFeature.typeCheck(Set<String> definedFeatures, SemanticConditionList e) {
        if (! definedFeatures.contains(getName()))
            e.add(new TypeError(this, ErrorMessage.NAME_NOT_RESOLVABLE, getName()));
    }

    syn Type DeltaParamDecl.getType();
    eq DeltaClassParam.getType() = UnknownType.INSTANCE; // XXX
    eq DeltaFieldParam.getType() = getParamDecl().getType();

	public abstract boolean DeltaParamDecl.accepts(Value val);
	public boolean DeltaClassParam.accepts(Value val) { return true; /* XXX NYI? */ }
	public boolean DeltaFieldParam.accepts(Value val) {
      return val.isAssignableTo(getType());
	}

	syn boolean DeltaClause.refersTo(Feature f) = !hasAppCond() || getAppCond().refersTo(f);
	syn boolean AppCond.refersTo(Feature f);
	eq AppCondFeature.refersTo(Feature f) = getName().equals(f.getName());
	eq AppCondAnd.refersTo(Feature f) = getLeft().refersTo(f) || getRight().refersTo(f);
	eq AppCondOr.refersTo(Feature f) = getLeft().refersTo(f) || getRight().refersTo(f);
	eq AppCondNot.refersTo(Feature f) = getAppCond().refersTo(f);
}

// Local Variables:
// mode: java
// End:
