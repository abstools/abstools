import org.abs_models.frontend.typechecker.nullable.NullableInfo;
import org.abs_models.frontend.typechecker.nullable.SimpleSet;

aspect NonNull {
  // == NonNull in ==
  syn SimpleSet<VarOrFieldDecl> CFGNode.nonNull_in() circular [SimpleSet.<VarOrFieldDecl>empty()] {
    SimpleSet<VarOrFieldDecl> s = new SimpleSet();
    for (CFGNode n : pred()) {
      s = s.union(n.nonNull_out());
    }

    for (CFGNode n : pred()) {
      s = s.intersection(n.nonNull_out());

      // Handle conditions
      if (n instanceof IfStmt) {
        IfStmt ifStmt = (IfStmt) n;
        PureExp cond = ifStmt.getCondition();
        CFGNode self = this;

        boolean assumeTrue = false;
        if (self == ifStmt.getThen()) {
          assumeTrue = true;
        }
        // TODO: Expand and put in own method/attribute
        if (cond instanceof EqualityExpr) {
          if (cond instanceof NotEqExp) {
            assumeTrue = !assumeTrue;
          }
          EqualityExpr ee = (EqualityExpr) cond;
          PureExp left = ee.getLeft();
          PureExp right = ee.getRight();
          if (left instanceof NullExp) {
            PureExp e = left;
            left = right;
            right = e;
          }
          if (right instanceof NullExp && left instanceof VarOrFieldUse) {
            VarOrFieldDecl d = ((VarOrFieldUse) left).getDecl();
            if (assumeTrue) {
              // If cond is true, then left must be null
              // We can safely do this without intersection, because we know we are in an IfStmt
              s = s.comp(d);
            } else {
              s = s.union(d);
            }
            continue;
          }
        }
      }
    }
    return s;
  }
  

  // == NonNull out ==
  // For most stmts out = in
  syn SimpleSet<VarOrFieldDecl> CFGNode.nonNull_out() = nonNull_in();

  // TODO: AssertStmt

  eq AssignStmt.nonNull_out() {
    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    Exp e = getValue();
    VarOrFieldUse var = getVar();

    VarOrFieldDecl d = var.getDecl();

    if (e.nonNull()) {
      return in.union(d);
    } else {
      return in.comp(d);
    }
  }

  eq ExpressionStmt.nonNull_out() = getExp().nonNull_out();

  eq VarDeclStmt.nonNull_out() {
    VarDecl d = getVarDecl();

    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    if (!(d.getType().isReferenceType())) {
      return in;
    }

    if (!d.hasInitExp()) {
      // Because we have no init, the value is null
      return in;
    }

    Exp init = d.getInitExp();
    if (init.nonNull()) {
      return init.nonNull_out().union(d);
    } else {
      // We don't have to remove d, as it has not existed yet
      return init.nonNull_out();
    }
  }

  eq AssertStmt.nonNull_out() {
    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    PureExp cond = getCondition();

    boolean assumeTrue = true;
    // TODO: Expand and put in own method/attribute
    if (cond instanceof EqualityExpr) {
      if (cond instanceof NotEqExp) {
        assumeTrue = !assumeTrue;
      }
      EqualityExpr ee = (EqualityExpr) cond;
      PureExp left = ee.getLeft();
      PureExp right = ee.getRight();
      if (left instanceof NullExp) {
        PureExp e = left;
        left = right;
        right = e;
      }
      if (right instanceof NullExp && left instanceof VarOrFieldUse) {
        VarOrFieldDecl d = ((VarOrFieldUse) left).getDecl();
        if (assumeTrue) {
          // If cond is true, then left must be null
          // We can safely do this without intersection, because we know we are in an IfStmt
          in = in.comp(d);
        } else {
          in = in.union(d);
        }
      }
    }

    return in;
  }

  // == Exp ==

  syn SimpleSet<VarOrFieldDecl> Exp.nonNull_in() = parentStmt().nonNull_in();

  syn SimpleSet<VarOrFieldDecl> Exp.nonNull_out();

  eq Exp.nonNull_out() = nonNull_in();

  eq Call.nonNull_out() {
    SimpleSet<VarOrFieldDecl> in = nonNull_in();
    PureExp callee = getCallee();

    // TODO: Add more cases? Actually, only Paren would make sense, right?
    if (callee instanceof VarOrFieldUse) {
      VarOrFieldUse c = (VarOrFieldUse) callee;
      return in.union(c.getDecl());
    }

    return in;
  }
  
  syn boolean Exp.nonNull();

  // TODO: refine using annotations
  eq Call.nonNull() = false;

  // TODO: refine using annotations
  eq GetExp.nonNull() = false;

  eq NewExp.nonNull() = true;

  // TODO: refine using annotations (Is that even possible?)
  eq OriginalCall.nonNull() = false;

  eq Access.nonNull() = false;
  eq VarOrFieldUse.nonNull() = nonNull_in().contains(getDecl());

  eq AsExp.nonNull() = false;

  // Binary expr can't be a reference
  eq Binary.nonNull() = true;

  // TODO
  eq CaseExp.nonNull() = false;

  // Can't be a reference
  eq DataConstructorExp.nonNull() = true;

  // Can't be a reference
  eq FnApp.nonNull() = true;

  eq IfExp.nonNull() = getThenExp().nonNull() && getElseExp().nonNull();

  eq ImplementsExp.nonNull() = true;

  // TODO
  eq LetExp.nonNull() = false;

  eq LiteralExp.nonNull() = true;

  eq NullExp.nonNull() = false;

  eq ParFnApp.nonNull() = true;

  eq ThisExp.nonNull() = true;

  eq Unary.nonNull() = true;
}