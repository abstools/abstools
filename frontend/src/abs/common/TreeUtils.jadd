aspect TreeUtils {

    /**
     * This method finds the closest parent conforming to `type`, starting from this
     * object's parent. May return null.
     */
    @CheckForNull
    public <N extends ASTNode<?>> N ASTNode.closestParent(Class<N> type) {
        ASTNode<?> n = getParent();
        while (n != null) {
            if (type.isInstance(n))
                return type.cast(n);
            else
                n = n.getParent();
        }
        return null;
    }

    /**
     * Finds all children of this node with the specified <code>type</code>. If this node has the
     * specified type, it will be included in the result.
     *
     * @param type the type to search for
     * @return an unmodifiable list of nodes, never null
     * @throws NullPointerException if <code>type</code> is null
     */
    public <N extends ASTNode<?>> java.util.List<N> ASTNode.findChildren(Class<N> type) {
        return findChildren(type, false);
    }

    /**
     * Finds all children of this node with the specified <code>type</code>. If this node has the
     * specified type, it will be included in the result.
     *
     * @param type the type to search for
     * @param lazy if true, children of found N nodes will not be included
     * @return an unmodifiable list of nodes, never null
     * @throws NullPointerException if <code>type</code> is null
     */
    public <N extends ASTNode<?>> java.util.List<N> ASTNode.findChildren(Class<N> type, boolean lazy) {
        java.util.List<N> result = new LinkedList<>();
        findChildren(result, this, Objects.requireNonNull(type), lazy);
        return Collections.unmodifiableList(result);
    }

    private <N extends ASTNode<?>> void ASTNode.findChildren(
        java.util.List<N> list,
        ASTNode<?> node,
        Class<N> type,
        boolean lazy) {
        if (node != null) {
            if (type.isInstance(node)) {
                list.add(type.cast(node));
                if (lazy) {
                    return;
                }
            }

            for (int index = 0; index < node.getNumChildNoTransform(); ++index) {
                findChildren(list, node.getChildNoTransform(index), type, lazy);
            }
        }
    }

    /**
     * Replaces this node with the <code>newNode</code> in this node's parent node.
     *
     * <p>The (former) parent of this node will be set to non-final and its cache will be flushed.
     * However, this method will not attempt to invoke any rewrites.<p>
     *
     * @param newNode a node to insert instead
     * @throws NullPointerException if newNode is null
     * @throws IllegalArgumentException if <code>newNode</code> is not detached or this node is detached
     */
    public void ASTNode.replaceWith(ASTNode<?> newNode) {
        Objects.requireNonNull(newNode);
        ASTNode<?> parent = this.getParent();
        if (parent == null || newNode.getParent() != null) {
            String message = parent == null
                ? "this is detached"
                : "newNode is not detached";
            throw new IllegalArgumentException(message);
        }
        int index = parent.getIndexOfChild(this);
        parent.setChild(newNode, index);
        this.setParent(null);

        parent.is$Final(false);
        parent.flushCache();
    }

    /**
     * Removes the specified node from this list.
     *
     * <p>If the specified node is not a child of this list, this method will return false.</p>
     *
     * @param child a child node of this list
     * @return true, if the specified child was a child of this list
     * @throws NullPointerException if child is null
     */
    public boolean List.removeChild(ASTNode<?> child) {
        Objects.requireNonNull(child);
        int index = getIndexOfChild(child);
        if (index == -1) {
            return false;
        }
        removeChild(index);
        return true;
    }
}
