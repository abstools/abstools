***
*** An ABS interpreter on the Maude platform
***
*** Copyright (c) 2010 Rudolf Schlatte
***
*** Based upon `creol-interpreter.maude' by Marcel Kyas, Olaf Owe, Einar Broch
*** Johnsen, which was generated from interpreter.m4, Copyright (c) 2007, 2008
*** Marcel Kyas
***
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 3 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program.  If not, see <http://www.gnu.org/licenses/>.
***



*** The basic concepts of Abs's data type.
***
fmod ABS-DATA-SIG is

  sorts Expr Data .
  subsort Data < Expr .

  op null : -> Data [ctor format (! o)] .

  sorts   NeExprList ExprList NeDataList DataList .
  subsort Expr < NeExprList < ExprList .
  subsort Data < NeDataList < DataList .
  subsort DataList < ExprList .
  subsort NeDataList < NeExprList .

  op emp : -> DataList [ctor] .

  op _::_ : ExprList ExprList -> ExprList
    [ctor assoc id: emp prec 27 format (d r os d)] .
  op _::_ : NeExprList ExprList -> NeExprList [ctor ditto] .
  op _::_ : ExprList NeExprList -> NeExprList [ctor ditto] .
  op _::_ : DataList DataList  -> DataList [ctor ditto] .
  op _::_ : NeDataList DataList  -> NeDataList [ctor ditto] .
  op _::_ : DataList NeDataList  -> NeDataList [ctor ditto] .

endfm

view Data from TRIV to ABS-DATA-SIG is
  sort Elt to Data .
endv

view Expr from TRIV to ABS-DATA-SIG is
  sort Elt to Expr .
endv


fmod ABS-DATA-VID is
  extending ABS-DATA-SIG .
  protecting STRING .
  protecting QID .

  sort Vid .
  subsort Qid < Vid < Expr .

  *** Variable references are named by Qids directly.

  *** Instance variable references are decorated:

  op @_ : Qid -> Vid [ctor] .
endfm

view Vid from TRIV to ABS-DATA-VID is
  sort Elt to Vid .
endv

fmod ABS-DATA-VIDLIST is
  protecting LIST{Vid} * (sort List{Vid} to VidList,
                          sort NeList{Vid} to NeVidList,
                          op nil : -> List{Vid} to noVid,
                          op __ : List{Vid} List{Vid} -> List{Vid} to _`,_ [format (d r os d)]) .
endfm



*** Specification of all Abs expressions.  This is the abstract syntax.
*** Semantics will be provided by the different modules.
***
fmod ABS-EXPRESSION is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-DATA-SIG .
  protecting STRING .

  sorts CaseBranch CaseBranchList .
  subsort CaseBranch < CaseBranchList .
  *** KLUDGE (rs 2010-04-20) Only certain kinds of expressions can be used as
  *** pattern: literals and variable references.  We should introduce a sort
  *** `Pattern' and use it.  For now, we rely on the compiler to only produce
  *** valid pattern expressions.
  op _=>_ : Expr Expr -> CaseBranch [ctor prec 39] .
  op _;_ : CaseBranchList CaseBranchList -> CaseBranchList
    [ctor assoc id: noBranch format (d b os d)] .
  op noBranch : -> CaseBranch .

  *** function application
  op _(_) : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  *** Helpers for function application, generated for each function.
  op fparams : String -> VidList .
  op fdefn : String -> Expr .
  *** Translation from Abs to Maude expressions for basic datatypes (Int,
  *** Bool, String etc).
  op $builtin : String -> Expr [ctor format (r o)] .
  *** constructor terms
  op _[_] : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  op _[_] : String DataList -> Data [ctor prec 12 format (! o d d d)] .
  *** conditional
  op if_th_el_fi : Expr Expr Expr -> Expr [ctor] .
  *** case expression
  op case_of {_} : Expr CaseBranchList -> Expr [ctor] .
  *** let expression
  op let_=_in_ : VidList ExprList Expr -> Expr [ctor] .
  *** guard expression
  op ?(_)  : Expr -> Expr [ctor format (! o d d d)] .
  *** duration guard expression
  op ?duration(_;_) : Expr Expr -> Expr [ctor format (! o d d d d d) ] .
  *** Component Model Extension: consistency guard
  op cr(_) : Expr -> Expr  [ctor format (! o d d d)] .
  *** Error terms
  op $error : String -> Expr [ctor format (r o)] .

endfm

*** Specification of the Bool datatype.
***
fmod ABS-DATA-BOOL is

  protecting ABS-EXPRESSION .

  vars B B' : Bool .
  vars D D' : Data .
  vars E : Expr .


  op _asBool : Data -> Bool .
  eq "ABS.StdLib.True"[ emp ] asBool = true .
  eq "ABS.StdLib.False"[ emp] asBool = false .
  op _asAbsBool : Bool -> Data .
  eq true asAbsBool = "ABS.StdLib.True"[ emp ] .
  eq false asAbsBool = "ABS.StdLib.False"[ emp ] .

  eq fparams("==") = 'D1, 'D2 .
  eq fdefn("==") = $builtin("==") .
  eq fparams("/=") = 'D1, 'D2 .
  eq fdefn("/=") = $builtin("/=") .

  eq fparams("~") = 'D .
  eq fdefn("~") = $builtin("~") .
  eq fparams("&&") = 'D1, 'D2 .
  eq fdefn("&&") = $builtin("&&") .
  eq fparams("||") = 'D1, 'D2 .
  eq fdefn("||") = $builtin("||") .

  eq fparams("<") = 'I1, 'I2 .
  eq fdefn("<") = $builtin("<") .
  eq fparams("<=") = 'I1, 'I2 .
  eq fdefn("<=") = $builtin("<=") .
  eq fparams(">") = 'I1, 'I2 .
  eq fdefn(">") = $builtin(">") .
  eq fparams(">=") = 'I1, 'I2 .
  eq fdefn(">=") = $builtin(">=") .

endfm



*** Specification of floats and functions on floats.
***
fmod ABS-DATA-FLOAT is
  extending ABS-DATA-BOOL .
  protecting FLOAT .

  op _[_] : String Float -> Data [ctor prec 12 format (! o d d d)] .

  vars F F' : Float .

  op _asFloat : Data -> Float .
  eq "float"[F] asFloat = F .

  eq "-" ("float"[F]) = "float"[-(F)] .
  eq "+" ("float"[F] :: "float"[F']) = "float"[F + F'] .
  eq "-" ("float"[F] :: "float"[F']) = "float"[ _-_(F, F')] .
  eq "*" ("float"[F] :: "float"[F']) = "float"[F * F'] .
  eq "/" ("float"[F] :: "float"[F']) = "float"[F / F'] .
  eq "%" ("float"[F] :: "float"[F']) = "float"[F rem F'] .
  eq "**" ("float"[F] :: "float"[F']) = "float"[F ^ F'] .

  eq "<"  ("float"[F] :: "float"[F']) = (F < F') asAbsBool .
  eq "<=" ("float"[F] :: "float"[F']) = (F <= F') asAbsBool .
  eq ">"  ("float"[F] :: "float"[F']) = (F > F') asAbsBool .
  eq ">=" ("float"[F] :: "float"[F']) = (F >= F') asAbsBool .

endfm



*** Specification of integers and functions on integers.
***
fmod ABS-DATA-INT is
  extending ABS-DATA-FLOAT .

  protecting INT .
  protecting CONVERSION .

  op _[_] : String Int -> Data [ctor prec 12 format (! o d d d)] .

  vars I I' : Int .
  var N : Nat .

  op _asInt : Data -> Int .
  eq "num"[I] asInt = I .

  op _asNat : Data -> Nat .
  eq "num"[N] asNat = N .
  eq "Time"["num"[N]] asNat = N .
  eq "Time"["num"[I]] asInt = I .

  eq fparams("--") = 'I .
  eq fdefn("--") = $builtin("--") .
  eq fparams("+") = 'I1, 'I2 .
  eq fdefn("+") = $builtin("+") .
  eq fparams("-") = 'I1, 'I2 .
  eq fdefn("-") = $builtin("-") .
  eq fparams("*") = 'I1, 'I2 .
  eq fdefn("*") = $builtin("*") .
  eq fparams("/") = 'I1, 'I2 .
  eq fdefn("/") = $builtin("/") .
  eq fparams("%") = 'I1, 'I2 .
  eq fdefn("%") = $builtin("%") .

  *** eq "**" ("num"[I] :: "num"[I']) = "num"[I ^ I'] .
  *** eq "real_of_int" ("int"[I]) = "float"[float(I)] .

  *** We're punning here: random has one argument, but the code generator adds
  *** a second one that gets one of the pre-generated random numbers.  Random
  *** numbers are stored in '.random and modified via $pushrandom /
  *** $poprandom.
  eq fparams("ABS.StdLib.random") = 'Range, 'Position .
  eq fdefn("ABS.StdLib.random") = $builtin("random") .

  eq fparams("ABS.StdLib.truncate") = 'I .
  eq fdefn("ABS.StdLib.truncate") = $builtin("truncate") .

endfm

fmod ABS-DATA-RAT is
  extending ABS-DATA-INT .
  protecting RAT .

  op _[_] : String Rat -> Data [ctor prec 12 format (! o d d d)] .

  var R : Rat .
  op _asRat : Data -> Rat .
  eq "num"[R] asRat = R .
  eq "Time"["num"[R]] asRat = R .
  
endfm


*** Specification of strings and functions on strings.
***
fmod ABS-DATA-STRING is
  extending ABS-DATA-INT .

  protecting STRING .

  op _[_] : String String -> Data [ctor prec 12 format (! o d d d)] .

  vars S S' : String .
  vars M N : Nat .

  op _asString : Data -> String .
  eq "str"[S] asString = S .

  eq "+" ("str"[S] :: "str"[S']) = "str"[S + S'] .
  eq "#" ("str"[S]) = "num"[length(S)] .
  eq "ascii" ("str"[S]) = "num"[ascii(S)] .
  eq "char" ("num"[N]) = "str"[char(N)] .
  eq fparams("ABS.StdLib.substr") = 'S, 'L, 'R .
  eq fdefn("ABS.StdLib.substr") = $builtin("substr") .
  eq fparams("ABS.StdLib.strlen") = 'S .
  eq fdefn("ABS.StdLib.strlen") = $builtin("strlen") .
  eq fparams("ABS.StdLib.toString") = 'S .
  eq fdefn("ABS.StdLib.toString") = $builtin("toString") .
  eq "find" ("str"[S] :: "str"[S'] :: "num"[N]) = "num"[find(S, S', N)] .
  eq "rfind" ("str"[S] :: "str"[S'] :: "num"[N]) = "num"[rfind(S, S', N)] .

  eq "<" ("str"[S]:: "str"[S']) = (S < S') asAbsBool .
  eq "<=" ("str"[S]:: "str"[S']) = (S <= S') asAbsBool .
  eq ">" ("str"[S]:: "str"[S']) = (S > S') asAbsBool .
  eq ">=" ("str"[S]:: "str"[S']) = (S >= S') asAbsBool .


  --- Conversions.  Since Abs does not support rational numbers yet,
  --- we may have failures here which will remain unchecked.
  protecting CONVERSION .
  var I : Int .
  var F : Float .

  eq "string_of_int" ("num"[I]) = "str"[string(I, 10)] .
  eq "int_of_string" ("str"[S]) = "num"[rat(S, 10)] .
  eq "string_of_real" ("float"[F]) = "str"[string(F)] .
  eq "real_of_string" ("str"[S]) = "float"[float(S)] .

endfm


*** Specification of times and functions on times.
***
fmod ABS-DATA-TIME is
  extending ABS-DATA-SIG .
  extending ABS-DATA-INT .

  *** The central problem is to evaluate this function, since the clock is
  *** floating around in the global state.
  eq fparams("ABS.StdLib.currentms") = noVid .
  eq fdefn("ABS.StdLib.currentms") = $builtin("currentms") .
  eq fparams("ABS.StdLib.lowlevelDeadline") = noVid .
  eq fdefn("ABS.StdLib.lowlevelDeadline") = $builtin("lowlevelDeadline") .
  eq fparams("ABS.DC.thisDC") = noVid .
  eq fdefn("ABS.DC.thisDC") = $builtin("thisDC") .

  eq fparams("ABS.Scheduler.method") = 'P .
  eq fdefn("ABS.Scheduler.method") = $builtin("method") .
  eq fparams("ABS.Scheduler.arrival") = 'P .
  eq fdefn("ABS.Scheduler.arrival") = $builtin("arrival") .
  eq fparams("ABS.Scheduler.cost") = 'P .
  eq fdefn("ABS.Scheduler.cost") = $builtin("cost") .
  eq fparams("ABS.Scheduler.procDeadline") = 'P .
  eq fdefn("ABS.Scheduler.procDeadline") = $builtin("procDeadline") .
  eq fparams("ABS.Scheduler.start") = 'P .
  eq fdefn("ABS.Scheduler.start") = $builtin("start") .
  eq fparams("ABS.Scheduler.finish") = 'P .
  eq fdefn("ABS.Scheduler.finish") = $builtin("finish") .
  eq fparams("ABS.Scheduler.crit") = 'P .
  eq fdefn("ABS.Scheduler.crit") = $builtin("crit") .
  eq fparams("ABS.Scheduler.value") = 'P .
  eq fdefn("ABS.Scheduler.value") = $builtin("value") .
  
endfm



***************************************************************************
***
*** Signature of programs and states.
***
***************************************************************************

*** The sort of a class identifier.
***
mod ABS-CID is
  protecting CONFIGURATION .
  protecting QID .
  subsort Qid < Cid .

  op Class : -> Cid [ctor] .
  op None : -> Cid [ctor] .
endm

view Cid from TRIV to ABS-CID is
  sort Elt to Cid .
endv


*** The sort of an object identifier.
***
mod ABS-OID is
  protecting ABS-CID .
  protecting NAT .
  protecting CONVERSION .
  extending ABS-DATA-SIG .

  subsort Oid < Data .

  --- Constructor of object names
  op ob : Cid Int -> Oid [ctor] .
endm

view Oid from TRIV to ABS-OID is
  sort Elt to Oid .
endv

*** Method names.
mod ABS-MID is
  protecting QID .

  sort Mid .
  subsort Qid < Mid .
endm

mod ABS-DATA-LABEL is

  extending ABS-DATA-SIG .
  protecting ABS-OID .

  sort Label .
  subsort Label < Data .

  --- A label consists of the id of the sending object plus a unique number.
  --- This is used in the $cont statement to find the object which should
  --- continue execution after a synchronously-called process terminates.
  op label : Oid Nat -> Label [ctor format (o o)] .
endm

view Label from TRIV to ABS-DATA-LABEL is
  sort Elt to Label .
endv

*** The DATATYPES module collects all predefined data types into one module.
mod ABS-DATATYPES is
    extending ABS-DATA-SIG .
    extending ABS-EXPRESSION .
    extending ABS-DATA-BOOL .
    extending ABS-DATA-LABEL .
    extending ABS-DATA-FLOAT .
    extending ABS-DATA-INT .
    extending ABS-DATA-RAT .
    extending ABS-DATA-STRING .
    extending ABS-DATA-TIME .
    extending ABS-OID .

  op toAbsString : Data -> String .
  eq toAbsString("num"[N:Rat]) = string(N:Rat, 10) .
  eq toAbsString("str"[S:String]) = S:String .
  eq toAbsString(null) = "null" .
  eq toAbsString(ob(C:Cid, N:Int))
  = "< REF " + string(C:Cid) + " " + string(N:Int, 10) + " >" .
  eq toAbsString(label(O:Oid, N:Int))
  = "< FUT " + toAbsString(O:Oid) + string(N:Int, 10) + " >" .
  eq toAbsString(N:String[ emp ]) = N:String .
  eq toAbsString(N:String[ A:NeDataList ])
  = N:String + "(" + toAbsString(A:NeDataList) + ")" .

  op toAbsString : DataList -> String .
  eq toAbsString(D:Data :: N:NeDataList)
  = toAbsString(D:Data) + ", " + toAbsString(N:NeDataList) .
endm


***
*** Binding variables to values.
***
*** Uses MAP from prelude.
***
mod ABS-SUBST is
  protecting ABS-DATATYPES .
  extending MAP{Vid, Data} * (sort Map{Vid,Data} to SSubst,
                              sort Entry{Vid,Data} to Binding,
                              op empty : -> Map{Vid,Data} to noSubst,
                              op insert : Vid Data Map{Vid,Data} -> Map{Vid,Data} to $insert ) .

  sort Subst .
  subsort SSubst < Subst .
  vars A A' : Vid .
  var AL : VidList .
  vars D D' : Data .
  var DL : DataList .
  var S1 : Subst .
  var S2 : SSubst .

  *** Lazy composition operator for substitutions
  *** FIXME: make this operator have less precedence than |->

  op _::_ : Subst Subst -> Subst [assoc] .
  eq (S1 :: S2)[A] = if $hasMapping(S2, A) then S2[A] else S1[A] fi .

  op hasMapping : Subst Vid -> Bool .
  eq hasMapping(S2, A) = $hasMapping(S2, A) .
  eq hasMapping(S1 :: S2, A) = $hasMapping(S2, A) or hasMapping(S1, A) .

  op insert : Vid Data Subst -> Subst .
  eq insert(A, D, S2) = $insert(A, D, S2) .
  eq insert(A, D, S1 :: S2) = S1 :: $insert(A, D, S2) .

  *** Replace an existing binding even in the middle of the SSubst stack.
  op update : Vid Data Subst -> Subst .
  eq update(A, D, S1 :: S2) = if $hasMapping(S2, A) then S1 :: $insert(A, D, S2)
      else update(A, D, S1) :: S2 fi .
  ceq update(A, D, S2) = $insert(A, D, S2)
  if $hasMapping(S2, A) .       *** Block if no mapping exists.

  --- Create a substitution from a list of identifiers and data values.
  op createSubst : VidList DataList -> SSubst .
  eq createSubst(AL, DL) = $createSubst(noSubst, AL, DL) .
  op $createSubst : SSubst VidList DataList -> SSubst .
  eq $createSubst(S2, noVid, emp) = S2 .
  eq $createSubst(S2, (A, AL), (D :: DL)) =
    $createSubst($insert(A, D, S2), AL, DL) .
endm



*** Abs Statements
***
*** The following module defines all elementary statements of Abs.
***
*** Colouring rules: Statements from the programmer syntax are displayed
*** in blue.  Statements inserted by the compiler only are displayed in
*** cyan.  Statements inserted by the run-time system are displayed in
*** red.  It may indicate a problem if a red term appears in a
*** configuration.

mod ABS-STATEMENT is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-EXPRESSION .
  protecting ABS-SUBST .
  protecting ABS-CID .
  protecting ABS-MID .

  sort Stmt .

  *** Cost expression wrapper for statements.
  op [_]_ : Expr Stmt -> Stmt [ctor prec 40 format (b o b o o)] .

  op skip : -> Stmt [ctor format (b o)] .
  op suspend : -> Stmt [ctor format (b o)] .
  op duration(_;_) : Expr Expr -> Stmt [ctor format (b d o b o b o)] .
  op $duration(_;_) : Rat Rat -> Stmt [ctor format (r d o r o r o) ] .
  op await_ : Expr -> Stmt [ctor format (b o d)] .
  op assert_ : Expr -> Stmt [ctor format (b o d)] .
  op assign(_;_) : Vid Expr -> Stmt [ctor format (b d o b o b o)] .
  op new(_;_;_) : Vid Cid ExprList -> Stmt [ctor format (b d o b o b o b o)] .
  op newcog(_;_;_;_) : Vid Cid ExprList Expr -> Stmt [ctor format (b d o b o b o b o b o)] .
  op newcog(_;_;_;_;_) : Vid Cid ExprList Expr Expr -> Stmt [ctor format (b d o b o b o b o b o b o)] .
  op asynccall(_;_;_;_;_) : Vid Expr Mid ExprList Expr -> Stmt [ctor format (b d o b o b o b o b o b o)] .
  op synccall(_;_;_;_;_) : Vid Expr Mid ExprList Expr -> Stmt [ctor format (b d o b o b o b o b o b o)] .
  op original(_;_) : Vid ExprList -> Stmt [ctor format (b d o b o b o)] .
  op $call(_;_;_;_;_;_) : Label Oid Mid DataList Bool Data -> Stmt [ctor format (r d o r o r o r o r o r o r o)] .
  op get(_;_)  : Vid Vid -> Stmt [ctor format (b d o b o b o)] .
  op get(_;_)  : Label Vid -> Stmt [ctor ditto] .
  op movecogto(_) : Expr -> Stmt [ctor format (c d o b o)] .

  op return(_) : Expr -> Stmt [ctor format (c d o b o)] .
  op $mark(_) : Expr -> Stmt [ctor format (r d o r o)] .
  op $release(_) : Expr -> Stmt [ctor format (r d o r o)] .

  op $cont_ : Label -> Stmt [ctor format (r o d)] .

  op $beginscope : -> Stmt [ctor format (r o)] .
  op $vardecl(_;_) : Vid Expr -> Stmt [ctor format (r d o r o r o) ] .
  op $endscope : -> Stmt [ctor format(r o)] .

  op $pushrandom : -> Stmt [ctor format (r o)] .
  op $poprandom : -> Stmt [ctor format (r o)] .

  *** Component Model Extension: rebind et subloc
  op rebind(_;_;_) : Expr Vid Expr -> Stmt [ctor format (b d o b o b o b o)] .
  op newloc(_) : Vid -> Stmt [ctor format (r d o r o)] .
  op getloc(_;_) : Vid Expr -> Stmt [ctor format (b d o b o b o)] .
  op getfather(_;_) : Vid Expr -> Stmt [ctor format (b d o b o b o)] .
  op subloc(_;_) : Expr Expr -> Stmt [ctor format (b d o b o b o)] .

  --- Assertion Failure.
  --- This `statement' represents an assertion failure.  It
  --- stops evaluation of the executing object at that point.
  op failure_ : Expr -> [Stmt] [ctor format (r! o d)] .

endm

view Stmt from TRIV to ABS-STATEMENT is
  sort Elt to Stmt .
endv



*** Specification of compound statements.
***
mod ABS-STM-LIST is
  protecting ABS-STATEMENT .
  protecting LIST{Stmt} * (sort List{Stmt} to StmtList,
                           sort NeList{Stmt} to NeStmtList,
                           op nil : -> List{Stmt} to noStmt,
                           op __ : List{Stmt} List{Stmt} -> List{Stmt} to _;_ [format (d r o d)]) .

  op if_th_el_fi : Expr StmtList StmtList -> Stmt [ctor format (b o b o b o b o)] .
  op while_do_od : Expr StmtList -> Stmt [ctor format (b o b o b o)] .

  var SL : StmtList .
  var E : Expr .

endm


mod ABS-PROCESS is
  protecting ABS-STM-LIST .

  var L : Subst .
  var SL : StmtList .

  sort Process .

  op idle : -> Process [ctor format (!b o)] .
  op notFound : -> Process [ctor format (!b o)] .
  op {_|_} : Subst StmtList -> Process [ctor format (r o rni o r o)] .

  *** FIXME: re-instate InfTime, or wrap finishing time in a Maybe
  op liftProcess : Process -> Data .
  eq liftProcess({ L | SL }) = "ABS.Scheduler.Process"[ L['.label] :: L['.method] :: L['.r] :: if hasMapping(L, '.c) then L['.c] else "ABS.StdLib.Duration"["num"[0]] fi :: L['.deadline] :: if hasMapping(L, '.s) then L['.s] else "InfTime"[emp] fi :: "InfTime"[emp] :: if hasMapping(L, '.crit) then L['.crit] else "ABS.StdLib.False"[emp] fi :: if hasMapping(L, 'value) then L['value] else "num"[0] fi ] .

endm

view Process from TRIV to ABS-PROCESS is
  sort Elt to Process .
endv


*** Specifies a process pool, here a multiset of Processes
***
mod ABS-PROCESS-POOL is
  protecting ABS-PROCESS .

  var P : Process .
  var W : MProc .
  var N : Label .
  var L : SSubst .
  var S : Subst .
  var SL : StmtList .

  sort MProc .
  subsort Process < MProc .
  op noProc : -> MProc [ctor] .
  op _,_ : MProc MProc -> MProc
    [ctor assoc comm id: noProc prec 41 format (d r osni d)] .

  op _minus_ : MProc Process -> MProc .
  eq (P, W) minus P = W .
  eq W minus idle = W .


  op liftMProc : MProc -> Data .
  eq liftMProc(noProc) = "ABS.StdLib.Nil"[emp] .
  eq liftMProc(P, W) = "ABS.StdLib.Cons"[liftProcess(P) :: liftMProc(W)] .

  op findProcess : MProc Label -> Process .
  eq findProcess(({ '.label |-> N, L | SL}, W), N) = { '.label |-> N, L | SL} .
  eq findProcess(({ ('.label |-> N, L) :: S | SL}, W), N) = { ('.label |-> N, L) :: S | SL} .

endm


*** A method declaration
***
mod ABS-METHOD is
  protecting ABS-STM-LIST .
  protecting ABS-MID .

  sort Method .
  op <_: Method | Param:_, Cost:_, Code:_> :
    Mid VidList Expr StmtList -> Method
    [ctor format (nib ! ob o d sb o d sb o d sb o b o)] .

endm

view Method from TRIV to ABS-METHOD is
  sort Elt to Method .
endv


*** Abs's state configuration.
***
*** Modeled after the CONFIGURATION module in "prelude.maude"
***
mod ABS-CONFIGURATION is
  protecting ABS-DATA-LABEL .
  protecting ABS-PROCESS-POOL .
  protecting ABS-OID .
  protecting ABS-MID .
  protecting SET{Method} * (sort Set{Method} to MMtd,
                            op empty : -> Set{Method} to noMethod) .
  protecting SET{String} * (sort Set{String} to StringSet) .

  --- Define object identifiers.
  protecting CONVERSION .
  protecting COUNTER .
  protecting RANDOM .

  sorts Future Class Clock Cog .
  subsorts Class Future Clock Cog < Configuration .
  vars B M : String .
  var C : Cid .
  vars O O' : Oid .
  vars L S S1 : Subst .
  vars P P' : Process .
  vars MS MS1 : MMtd .
  var W : MProc .
  var AL : VidList .
  vars SL SL1 : StmtList .
  var EL : ExprList .
  var D : Data .
  var DL : DataList .
  var N : Label .
  vars F F' : Nat .
  var CN : Configuration .
  var T : Rat .
  vars LIM RAND : Nat .

  --- Invocation protocol.
  ---
  --- Invocation message generated by the calling object:
  ---    invoc(R,N,M,DL,S,AUX)
  --- R: The receiver.
  --- N: The label.
  --- M: The called method.
  --- DL: The actual arguments.
  --- S: Flag indicating whether the call was made synchronously, i.e. whether
  ---    a $cont statement should be generated at the end.
  --- AUX: additional process variables, currently .deadline (deadline)
  op invoc(_,_,_,_,_,_) : Oid Label Mid DataList Bool SSubst -> Msg
    [ctor format (b d o  b so  b so  b so  b so  b so b on)] .

  --- Process creation in target object:
  --- M: the method.
  --- N: the future (label).
  --- DL: the parameters (already evaluated by the caller).
  --- B: whether to continue at caller or not.
  --- AUX: additional process variables, currently .deadline (deadline)
  --- T: arrival time
  --- S: the object state, needed for calculation of method cost
  op makeProcess(_,_,_,_,_,_,_) : Method Label DataList Bool SSubst Nat Subst -> Process .


  --- Error and warning messages are intended to stop the machine.
  --- For now, nothing is emitting these.
  --- op error(_) : String -> [Msg] [ctor format (nnr r o! or onn)] .
  op warning(_) : String -> [Msg] [ctor format (nnr! r! r! or onn)] .

  --- Terms of sort Object represent objects in the run-time configuration.
  ---
  op <_:_ | Cog:_, Att:_, Lcnt:_> :
    Oid Cid Cogid Subst Nat -> Object
    [ctor format (nr d d g ++r nir o  r ni o  r ni o--  r on)] .

  --- Terms that represent futures.
  ---
  op <_: Future | Name:_, Completed:_, References:_, Value:_> :
    Label Mid Bool Nat Data -> Future
    [ctor format (nr d d g ++r ir o  r i o  r i o  r i o--  r on)] .

  --- Define Classes.
  --- Class declaration.
  ---
  op <_: Class | Param:_, Att:_, Sched:_, Mtds:_, Ocnt:_> :
    Cid VidList Subst Expr MMtd Nat -> Class
    [ctor format (ng ! og o d  sg o d  sg o d  sg o d  sg++ o o  gni o-- g on)] .

  op <_: Clock | Limit:_> : Int Nat -> Clock
    [ctor format(nb m! ob b b b m! b n)] .
  op <_: Clock | Limit:_, Random:_> : Int Nat Nat -> Clock
    [ctor format(nb m! ob b b b m! b b m! b n)] .
  rl < T : Clock | Limit: LIM > => < T : Clock | Limit: LIM, Random: random(counter) > .


  *** Cogs.  The second argument (the currently active object) is of type Data
  *** since it can be an Oid (the currently active object) or null.  The first
  *** argument is a unique identifier - we re-use the Oid of the primary
  *** object of the cog (no object can be inside two cogs, and no object can
  *** move between cogs).  The last argument is the scheduler to use.
  sort Cogid .
  subsort Oid < Cogid .
  op <_: Cog | Object:_, DC:_, Sched:_, Pr:_, PrQ:_ > : Cogid Data Oid Expr Process MProc -> Cog
    [ctor format (nc d d c d d o! d d o! d n o! d n o! d n o!++ c-- on ) ] .

  *** Component Model Extension: Location
  sort Location .
  subsort Location  < Data .
  sort LocInfo .
  subsort LocInfo  < Configuration .
  
  op loc-top     : -> Location [ctor] .
  op loc-cog(_)  : Cogid -> Location [ctor format (b o b o o)] .
  op loc-comp(_) : Nat -> Location [ctor format (b o b o o)] .

  op < LocId | _ > : Nat -> LocInfo [ctor] .
  op < locRel | _ ; _ > : Data Data -> LocInfo [ctor] .


  *** Useful for real-time maude, and in general for accessing the whole
  *** configuration.  FIXME: We should use another name, since State is used
  *** in LOOP-MODE.
  sort State .

  op {_} : Configuration -> State [ctor] .

endm


*** Definition of the family of evaluation functions.
***
mod ABS-EVAL is
  protecting ABS-CONFIGURATION .
  protecting ABS-DATA-VID .
  protecting COUNTER .
  protecting RANDOM .

  vars L L' : Label .
  vars E E' E'' : Expr .
  vars D D' : Data .
  vars DL DL1 DL2 CDL1 CDL2 : DataList .
  var EL : ExprList .
  var NeEL : NeExprList .
  var CBL : CaseBranchList .
  vars A A' : Vid .
  var AL : VidList .
  vars Q C : String .
  vars Q1 Q2 : String .
  vars R1 R2 : Rat .
  vars I1 I2 : Rat .
  var QID : Qid .
  var M : Mid .
  vars S S' : Subst .
  var R : MatchResult .
  var SS : SSubst .
  vars ST ST' : Stmt .
  vars SL SL1 SL2 : StmtList .
  var CN : Configuration .
  var CL : Class .
  var OB : Object .
  var O : Oid .
  var CG : Cogid .
  var MS : Msg .
  vars N N1 N2 : Nat .
  var B : Bool .
  vars MIN MAX : Rat .
  var MAC : SSubst .
  var W : MProc .
  var COST : Expr .
  
  var OID : Oid .
  vars CID CID1 CID2 : Cid .
  var COGID : Cogid .

  --- Check if a message is in the queue.
  op completed : Label Configuration -> Bool .
  eq completed(L, < L : Future | Name: M, Completed: B, References: N, Value: D > CN) = B .
  eq completed(L, CN) = false [owise] .

  *** evaluate `Expr' with variable bindings `Subst', configuration
  *** `Configuration' and other parameters `SSubst' (time, deadline).
  op eval : Expr Subst Configuration SSubst -> Data .
  op evalList : ExprList Subst Configuration SSubst -> DataList [strat (1 4 0)] .
  op executable : StmtList Subst Configuration SSubst -> Bool .
  op schedulable : StmtList Subst Configuration SSubst -> Bool .

  eq eval(D, S, CN, MAC) = D .

  *** Normal variable lookup.  Can be either instance or local variable.
  eq eval(QID, S, CN, MAC) =  S [QID] .
  *** Instance variable lookup.  The distinction between @ and raw qids needs
  *** to be made in all lookup operations.
  eq eval(@ QID, (SS :: S), CN, MAC) =  SS [QID] .
  *** Function expansions are expressions, subject to further evaluation.
  *** They are not evaluated in the current environment but in the environment
  *** in which they are defined (which is currently always empty).
  eq eval(Q(EL), S, CN, MAC) = eval(fdefn(Q),
      createSubst(fparams(Q), evalList(EL, S, CN, MAC)), CN, MAC) .
  eq eval(Q [EL], S, CN, MAC) = Q [ evalList(EL, S, CN, MAC) ] .
  eq eval(?(QID), S, CN, MAC) = completed(S[QID], CN) asAbsBool .
  eq eval(?(@ QID), (SS :: S), CN, MAC) = completed(SS[QID], CN) asAbsBool .
  eq eval(?(L), S, CN, MAC) = completed(L, CN) asAbsBool .
  eq eval(?duration(E ; E'), S, CN, MAC) = (if (MAC['.time]) asRat >= 0 then ((eval(E, S, CN, MAC) asRat) <= 0) else true fi) asAbsBool .
  eq eval(if E th E' el E'' fi, S, CN, MAC) =
    if eval(E, S, CN, MAC) asBool
    then eval(E', S, CN, MAC)
    else eval(E'', S, CN, MAC) fi .
  eq eval(let AL = EL in E, S, CN, MAC) =
    eval(E, S :: createSubst(AL, evalList(EL, S, CN, MAC)), CN, MAC) .

  *** Component Model Extension: Guard
  *** Component Model Extension: Check if an object is not in critical section
  op isntcritical : Oid Configuration -> Bool .
  eq isntcritical(OID, < OID : CID | Cog: COGID, Att: S, Lcnt: N > CN) = ((S ['.nbcr]) asInt == 0) .
  eq isntcritical(OID, CN) = false [owise] .

  eq eval(cr( E ), S, CN, MAC) = isntcritical( eval(E, S, CN, MAC) , CN) asAbsBool .


  *** evaluate a case statement.  If the pattern matches, augment environment
  *** with the resulting bindings.
  sort MatchResult .
  subsort Subst < MatchResult .
  op noMatch : -> MatchResult [ctor] .
  op match : Data Expr Subst -> MatchResult .
  eq match(D, E, S) = $match(D, E, S, noSubst) .
  op $match : Data Expr Subst MatchResult -> MatchResult .
  eq $match(D, E, S, noMatch) = noMatch .
  eq $match(D, D, S, R) = R .           *** matching two literals
  eq $match(D, '_, S, R) = R .       *** "Don't care" placeholder
  eq $match(D, A, S, R) =               *** Create / check variable binding
    if hasMapping(S, A)
    then
      $match(D, S[A], S, R)
    else
      if hasMapping(R, A)
      then $match(D, R[A], S, R)       *** Match against existing binding
      else insert(A, D, R)             *** Generate new binding
      fi
    fi .
  eq $match(Q[D :: DL], Q[E :: EL], S, R) = *** Destructure constructor pattern
    $match(Q[DL], Q[EL], S, $match(D, E, S, R)) .
  eq $match(D, E, S, R) = noMatch [owise] .

  *** internal operator $case avoids endless loop between "case D of" and
  *** "case E of" when first case branch doesn't match
  op $case : Data CaseBranchList -> Expr .
  ceq eval($case(D, (E => E') ; CBL), S, CN, MAC) =
    if R == noMatch
    then eval($case(D, CBL), S, CN, MAC)
    else eval(E', S :: R, CN, MAC) fi
  if R := match(D, E, S) .
  *** eq eval($case(D, noBranch), S, CN) = $error("No match in case expression") .

  eq eval(case E of { CBL }, S, CN, MAC) =
    eval($case(eval(E, S, CN, MAC), CBL), S, CN, MAC) .

  --- Evaluate lists of expressions.
  eq evalList(emp, S, CN, MAC) = emp .
  eq evalList(noVid, S, CN, MAC) = emp .
  eq evalList(DL, S, CN, MAC) = DL .
  eq evalList(E, S, CN, MAC) = eval(E, S, CN, MAC) .
  eq evalList(E :: NeEL, S, CN, MAC) =
    eval(E, S, CN, MAC) :: evalList(NeEL, S, CN, MAC) .

  --- Executableness
  *** Do we have enough resources?
  eq executable([COST]ST:Stmt ; SL, S, CN, MAC)
  = hasEnoughResources(MAC['.comp], CN, eval(COST, S, CN, MAC) asRat)
  and executable(ST:Stmt ; SL, S, CN, MAC) .
  eq executable(await E ; SL, S, CN, MAC) = eval(E, S, CN, MAC) asBool .
  *** Note that "get" is always deemed to be executable, so that it can block
  *** the cog properly (this is intentional).
  eq executable($duration(MIN ; MAX) ; SL, S, CN, MAC) = MIN <= 0 .
  eq executable(SL, S, CN, MAC) = true [owise] .

  --- The schedulable predicate holds, if a statement is schedulable for
  --- execution, i.e., the corresponding process may be waken up.
  *** We schedule at all costs; ST may take more than one time unit to execute
  eq schedulable([COST]ST:Stmt ; SL, S, CN, MAC)
  = schedulable(ST:Stmt ; SL, S, CN, MAC) .
  eq schedulable(get(QID ; A') ; SL , S, CN, MAC)
  = completed(S[QID], CN) .
  eq schedulable(get(@ QID ; A') ; SL , (SS :: S), CN, MAC)
  = completed(SS[QID], CN) .
  eq schedulable(get(L ; A') ; SL , S, CN, MAC) = completed(L, CN) .
  *** This is only for the untimed case -- in the timed interpreter, duration
  *** is reduced to $duration via an equation.
  eq schedulable(duration(E ; E') ; SL, S, CN, MAC) = true .
  eq schedulable(SL, S, CN, MAC) = executable(SL, S, CN, MAC) [owise] .

  *** minimum time elapse.  Only evalutes guards.  Returns a number between 0
  *** and 1 (the clock only advances to the next integer, since resources are
  *** replenished then).
  op mte : Expr Subst Configuration SSubst -> Rat .
  eq mte("&&"(E' :: E''), S, CN, MAC) = max(mte(E', S, CN, MAC), mte(E'', S, CN, MAC)) .
  eq mte(?duration(E ; E'), S, CN, MAC) = if (MAC['.time]) asRat >= 0 then eval(E, S, CN, MAC) asRat else 0 fi .
  eq mte(E, S, CN, MAC) = if eval(E, S, CN, MAC) asBool then 0 else 1 fi [owise] .

  op mte : StmtList Subst Configuration SSubst -> Rat .
  eq mte([COST]ST:Stmt ; SL, S, CN, MAC)
  = if hasEnoughResources(MAC['.comp], CN, eval(COST, S, CN, MAC) asRat)
    then mte(ST:Stmt ; SL, S, CN, MAC)
    else 1 fi .
  eq mte(get(QID ; A') ; SL , S, CN, MAC) = if completed(S[QID], CN) then 0 else 1 fi .
  eq mte(get(@ QID ; A') ; SL , (SS :: S), CN, MAC) = if completed(SS[QID], CN) then 0 else 1 fi .
  eq mte(get(L ; A') ; SL , S, CN, MAC) = if completed(L, CN) then 0 else 1 fi .
  *** This is only for the untimed case -- in the timed interpreter, duration
  *** is reduced to $duration via an equation.
  eq mte(duration(E ; E') ; SL, S, CN, MAC) = 0 .
  eq mte(await E ; SL, S, CN, MAC) = mte(E, S, CN, MAC) . *** reduce to mte of guard
  eq mte($duration(MIN ; MAX) ; SL, S, CN, MAC) = max(MIN, 0) . *** do we want max(0, min(MAX, 1)) instead?
  eq mte($cont L ; SL, S, CN, MAC) = 0 . *** If $cont can't execute, something
                                         *** is wrong
  eq mte(SL, S, CN, MAC) = 0 [owise] .

  *** Evaluate various builtin functions.

  *** ABS-DATA-BOOL
  eq eval($builtin("=="), S, CN, MAC) = (S['D1] == S['D2]) asAbsBool .
  eq eval($builtin("/="), S, CN, MAC) = (S['D1] =/= S['D2]) asAbsBool .
  eq eval($builtin("~"), S, CN, MAC) = (not ((S['D]) asBool)) asAbsBool .
  eq eval($builtin("&&"), S, CN, MAC) = ((S['D1]) asBool and (S['D2]) asBool) asAbsBool .
  eq eval($builtin("||"), S, CN, MAC) = ((S['D1]) asBool or (S['D2]) asBool) asAbsBool .

  op dataLessThan : DataList DataList -> Bool .
  eq dataLessThan(emp, emp) = false .
  eq dataLessThan("num"[R1] :: DL1, "num"[R2] :: DL2) =
  R1 < R2 or-else (R1 == R2 and dataLessThan(DL1, DL2)) .
  eq dataLessThan("str"[Q1] :: DL1, "str"[Q2] :: DL2) = Q1 < Q2 or-else (Q1 == Q2 and dataLessThan(DL1, DL2)) .
  eq dataLessThan(Q1[CDL1] :: DL1, Q2[CDL2] :: DL2) =
  Q1 < Q2 or-else ((Q1 == Q2 and dataLessThan(CDL1, CDL2)) or-else dataLessThan(DL1, DL2)) .
  eq dataLessThan(ob(CID1, I1) :: DL1, ob(CID2, I2) :: DL2) =
    string(CID1) < string(CID2)
    or-else (CID1 == CID2 and I1 < I2)
    or-else (CID1 == CID2 and I1 == I2 and dataLessThan(DL1, DL2)) .
  eq dataLessThan(label(ob(CID1, I1), N1) :: DL1, label(ob(CID2, I2), N2) :: DL2) =
    string(CID1) < string(CID2)
    or-else (CID1 == CID2 and I1 < I2)
    or-else (CID1 == CID2 and I1 == I2 and N1 < N2)
    or-else (CID1 == CID2 and I1 == I2 and N1 == N2 and dataLessThan(DL1, DL2)) .

  eq eval($builtin("<"), S, CN, MAC) = dataLessThan(S['I1], S['I2]) asAbsBool .
  eq eval($builtin("<="), S, CN, MAC) = ((S['I1] == S['I2]) or-else dataLessThan(S['I1], S['I2])) asAbsBool .
  eq eval($builtin(">"), S, CN, MAC) = dataLessThan(S['I2], S['I1]) asAbsBool .
  eq eval($builtin(">="), S, CN, MAC) = ((S['I1] == S['I2]) or-else dataLessThan(S['I2], S['I1])) asAbsBool .


  *** ABS-DATA-RAT
  eq eval($builtin("--"), S, CN, MAC) = "num"[-(S['I]) asRat] .
  ceq eval($builtin("+"), S, CN, MAC) = "num"[I1:Rat + I2:Rat]
  if "num"[I1:Rat] := S['I1] /\ "num"[I2:Rat] := S['I2] .
  eq eval($builtin("-"), S, CN, MAC) = "num"[(S['I1]) asRat - (S['I2]) asRat] .
  eq eval($builtin("*"), S, CN, MAC) = "num"[(S['I1]) asRat * (S['I2]) asRat] .
  *** ceq eval($builtin("/"), S, CN, N) = "num"[I1:Int quo I2:Int] .
  *** if "num"[I1:Int] := S['I1] /\ "num"[I2:Int] := S['I2] .
  eq eval($builtin("/"), S, CN, MAC) = "num"[(S['I1]) asRat / (S['I2]) asRat] .
  eq eval($builtin("%"), S, CN, MAC) = "num"[(S['I1]) asRat rem (S['I2]) asRat] .
  --- 4294967296 == 2^32
  ceq eval($builtin("random"), S, CN, MAC) = "num"[ trunc(((S['Range]) asRat) * (N:Rat / 4294967296)) ]
  if N:Rat := eval("ABS.StdLib.nth"(MAC['.random] :: 'Position), S, CN, MAC) asRat .
  eq eval($builtin("truncate"), S, CN, MAC) = "num"[trunc((S['I]) asRat)] .

  *** ABS-DATA-STRING
  ceq eval($builtin("+"), S, CN, MAC) = "str"[I1:String + I2:String]
  if "str"[I1:String] := S['I1] /\ "str"[I2:String] := S['I2] .
  eq eval($builtin("substr"), S, CN, MAC) =
    "str"[substr((S['S]) asString, (S['L]) asInt, (S['R]) asInt)] .
  eq eval($builtin("strlen"), S, CN, MAC) =
    "num"[length((S['S]) asString)] .
  eq eval($builtin("toString"), S, CN, MAC) = "str"[toAbsString(S['S])] .
  *** ABS-DATA-TIME
  --- N will be 0 in the untimed case.
  eq eval($builtin("currentms"), S, CN, MAC) = MAC['.time] .
  eq eval($builtin("lowlevelDeadline"), S, CN, MAC) =
    eval((case MAC['.deadline] of { ("ABS.StdLib.Duration"[ 'v ] => 'v) ; ("ABS.StdLib.InfDuration"[ emp ] => "num"[ -1 ]) }), S, CN, MAC) .
  eq eval($builtin("thisDC"), S, CN, MAC) = MAC['.comp] .

  *** Processes
  eq eval($builtin("method"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = METHOD:Data .
  eq eval($builtin("arrival"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = ARRIVAL:Data .
  eq eval($builtin("cost"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = COST:Data .
  eq eval($builtin("procDeadline"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = DEADLINE:Data .
  eq eval($builtin("start"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = START:Data .
  eq eval($builtin("finish"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = FINISH:Data .
  eq eval($builtin("crit"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = CRIT:Data .
  eq eval($builtin("value"), ('P |-> "ABS.Scheduler.Process"[ PID:Data :: METHOD:Data :: ARRIVAL:Data :: COST:Data :: DEADLINE:Data :: START:Data :: FINISH:Data :: CRIT:Data :: VALUE:Data ], S), CN, MAC) = VALUE:Data .

  op markFutures : DataList -> StmtList .
  ceq markFutures(D) = $mark(D) if D : Label .
  eq markFutures(Q[DL]) = markFutures(DL) .
  eq markFutures(D) = noStmt [owise] .
  ceq markFutures(D :: DL) = markFutures(D) ; markFutures(DL)
  if DL =/= emp .
  eq markFutures(emp) = noStmt .

  op freeFutures : DataList -> StmtList .
  ceq freeFutures(D) = $release(D) if D : Label .
  eq freeFutures(Q[DL]) = freeFutures(DL) .
  eq freeFutures(D) = noStmt [owise] .
  ceq freeFutures(D :: DL) = freeFutures(D) ; freeFutures(DL)
  if DL =/= emp .
  eq freeFutures(emp) = noStmt .

  op freeFutures : SSubst -> StmtList .
  eq freeFutures(noSubst) = noStmt .
  eq freeFutures((A |-> D, SS)) = freeFutures(D) ; freeFutures(SS) .

  op getSchedulableProcesses : MProc Configuration SSubst -> MProc .
  eq getSchedulableProcesses(noProc, CN, MAC) = noProc .
  ceq getSchedulableProcesses(({ S' | SL }, W), < O : C:Cid | Cog: CG, Att: S, Lcnt: N > CN, MAC) =
    if schedulable(SL, (S :: S'), < O : C:Cid | Cog: CG, Att: S, Lcnt: N > CN, (MAC, '.deadline |-> S'['.deadline]))
    then { S' | SL }, getSchedulableProcesses(W, < O : C:Cid | Cog: CG, Att: S, Lcnt: N > CN, MAC)
    else getSchedulableProcesses(W, < O : C:Cid | Cog: CG, Att: S, Lcnt: N > CN, MAC)
    fi
  if O := S'['this] .

  *** Misc: update resource status of a deployment component.  Pass in a set
  *** of names and numbers once we properly support multiple resource types.
  *** Result type is Expr not Data so that we can advance time on insufficient
  *** resources.
  op consumeDCResource : Data Rat -> Expr .
  eq consumeDCResource("num"[RA:Rat], AMOUNT:Rat)
  = "num"[RA:Rat + AMOUNT:Rat] .

  op findDC : Oid Configuration -> Object .
  eq findDC(DC:Oid, < DC:Oid : 'ABS.DC.DeploymentComponent
      | Cog: CG:Cogid, Att: S, Lcnt: F:Nat > CN)
  = < DC:Oid : 'ABS.DC.DeploymentComponent
      | Cog: CG:Cogid, Att: S, Lcnt: F:Nat > .

  op hasEnoughResources : Oid Configuration Rat -> Bool .
  eq hasEnoughResources(DC:Oid,
      < DC:Oid : 'ABS.DC.DeploymentComponent
      | Cog: CG:Cogid, Att: ('cpu |-> "ABS.DC.InfCPU"[emp], S), Lcnt: F:Nat >
      CN, CO:Rat)
  = true .
  eq hasEnoughResources(DC:Oid,
      < DC:Oid : 'ABS.DC.DeploymentComponent
      | Cog: CG:Cogid, Att: ('cpu |-> "ABS.DC.CPU"["num"[RA:Rat]], 'internalState |-> "num"[STATE:Rat], S), Lcnt: F:Nat > CN, CO:Rat)
  = CO:Rat + STATE:Rat <= RA:Rat  .

  op getFreeResources : Data Data Rat -> Rat .
  eq getFreeResources("num"[RA:Rat], "ABS.DC.CPU"["num"[TOTAL:Rat]], CO:Rat) = TOTAL:Rat - RA:Rat .
  *** The DC is unlimited -- return exactly what's asked for
  eq getFreeResources("num"[RA:Rat], "ABS.DC.InfCPU"[emp], CO:Rat)
  = CO:Rat .

endm

mod ABS-MSG-TRANSPORT is
  protecting ABS-CONFIGURATION .
  protecting ABS-EVAL .

  vars CG CG1 : Cogid .  var MIS : MMtd .          vars AL AL' : VidList .
  vars S S1 L : Subst .  vars SL SL1 : StmtList .  var N : Label .
  var DL : DataList .    vars C C1 : Cid .
  vars F F1 G : Nat .    vars O O1 : Oid .         vars P P1 : Process .
  vars W W1 : MProc .    var MI : Method .
  var MS : StringSet .   var B : Bool .
  var SS : SSubst .
  var DE : Data .
  var M : Mid .
  var SC : Expr .
  var T : Rat .
  vars LIM RAND : Nat .
  var CO : Expr .
  var AUX : SSubst .

  --- message generation
  eq
    < CG : Cog | Object: O1, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $call(N ; O ; M ; DL ; B ; DE) ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O1, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(DL) ; SL }, PrQ: W >
    invoc(O, N, M, DL, B, ('.deadline |-> DE))
      [label call-internal] .


  --- transport
  ---
  --- Receive an invocation message to bind the method body.  We never make
  --- this a rule -- scheduling is done elsewhere.
  ---
  eq
    < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr, Pr: P, PrQ: Q:MProc >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < C : Class | Param: AL', Att: S1, Sched: SC,
                  Mtds: (MIS, < M : Method | Param: AL, Cost: CO, Code: SL >), Ocnt: G >
    invoc(O, N, M, DL, B, AUX)
  =
    < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr, Pr: P, PrQ: (Q:MProc, makeProcess(< M : Method | Param: AL, Cost: CO, Code: SL >, N, DL, B, (AUX, 'this |-> O), T, S)) >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < C : Class | Param: AL', Att: S1, Sched: SC,
                  Mtds: (MIS, < M : Method | Param: AL, Cost: CO, Code: SL >), Ocnt: G >
    [label transport-imsg] .

  ceq makeProcess(< M : Method | Param: AL, Cost: CO, Code: SL >, N, DL, B, AUX, T, S)
  =
    { AUX, '.c |-> eval(CO, S :: L, none, ('.time |-> "num"[T])), '.label |-> N, '.method |-> "str"[ string(M) ], '.r |-> "ABS.StdLib.Time"["num"[T]], '.random |-> "ABS.StdLib.Nil"[emp], '.staticfuture |-> null, '_ |-> null, L | SL ; if B then $cont(N) else noStmt fi }
  if L := createSubst(AL, DL) .

  op recordStartTime : Process Rat -> Process .
  *** This will only ever be evaluated with a simple substitution SS.
  eq recordStartTime({ SS | SL}, T:Rat) =
  if $hasMapping(SS, '.s) then { SS | SL }
  else { $insert('.s, "ABS.StdLib.Time"["num"[T:Rat]], SS) | SL } fi .

endm

*** The machine.
***
*** We have one module per statement per evaluation strategy, and combine them
*** in the end.


*** Some common functionality: scheduling, trivial statements that are always
*** equations, etc.  This is split into a common part (time-neutral) and some
*** machinery that depends on timed behavior.
mod ABS-MACHINE-BASICS-COMMON is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .
  protecting RANDOM .
  protecting COUNTER .

  vars O O1 : Oid .         vars C B : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G X : Nat .
  var CN : Configuration .  var P : Process .    vars A A' : Vid .
  var E : Expr .            var AL : VidList .   var N : Label .
  var Q : String .          var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  var M : Mid .
  var CG : Cogid .
  var T : Rat .
  vars LIM RAND : Nat .
  var SC : Expr .
  var COST : Expr .

  --- Process teardown: first release all futures, then release the Cog.  (We
  --- assume correct beginscope / endscope statements).
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | noStmt }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { noSubst | freeFutures(L) }, PrQ: W >
  if L =/= noSubst
    [label Process-terminate-1] .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { noSubst | noStmt }, PrQ: W >
  =
    < CG : Cog | Object: null, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W >
    [label Process-terminate-2] .

  *** Handle synchronous self-calls
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | get(A ; A') ; SL }, PrQ: W, {L1 | SL1} >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O1, DC: DC:Data, Sched: SCH:Expr, Pr: {L1 | SL1}, PrQ: W, { L | get(A ; A') ; SL } >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if  (S :: L)[A] = L1['.label]
      /\ O1 := L1['this]
    [label schedule-self] .

  --- Skip the $release instruction if the variable is uninitialized.  This
  --- helps the code generator.
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $release(A) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if null = (S :: L)[A]
      [label free-uninitialized] .

  --- Completed futures without references can be removed.
  ---
  eq < N : Future | Name: M, Completed: true, References: 0, Value: D > = none .

  --- Create a new environment.  This is for supporting local declarations in
  --- blocks etc.
  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $beginscope ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L :: noSubst | SL }, PrQ: W >
    [label $beginscope] .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L :: S2 | $endscope ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | freeFutures(S2) ; SL }, PrQ: W >
    [label $endscope-1] .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { S2 | $endscope ; SL }, PrQ: W >
  =
    *** Shouldn't happen, but can't harm
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { S2 | SL }, PrQ: W >
    [label $endscope-2] .

  *** must be a rewrite rule since we use counter.
  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $pushrandom ; SL }, PrQ: W >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign('.random ; "ABS.StdLib.Cons"["num"[random(counter)] :: '.random]) ; SL }, PrQ: W > .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $poprandom ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign('.random ; "ABS.StdLib.tail"('.random)) ; SL }, PrQ: W > .

  --- Schedule a new process for execution, if it is schedulable.
  ---
  --- Must be a rule to preserve confluence.
  ---
  --- We capture the entire state here since the condition E can depend
  --- on the state of Futures contained in CN.  The scheduler of the cog
  --- is called to determine the process to be run.  Note that the
  --- object state comes from the "main" object, i.e., the one that was
  --- created along with the cog and has the same id.
  --- 
  --- We also consume a random value, just to be on the safe side -- the
  --- scheduling function might use random().
  crl
    { < CG : Cog | Object: null, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W >
      < CG : C | Cog: CG, Att: S, Lcnt: F >
      < T : Clock | Limit: LIM, Random: RAND >
      CN  }
  =>
    { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W minus { L | SL } >
      < CG : C | Cog: CG, Att: S, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  if W1 := getSchedulableProcesses(W, < CG : C | Cog: CG, Att: S, Lcnt: F > CN, ('.time |-> "num"[T], '.comp |-> DC:Data))
      /\ W1 =/= noProc
      /\ "ABS.Scheduler.Process"[N :: DL] := eval(SCH:Expr, ('queue |-> liftMProc(W1), '.random |-> "ABS.StdLib.Cons"["num"[RAND] :: "ABS.StdLib.Nil"[emp]] , S), none, ('.time |-> "num"[T], '.comp |-> DC:Data, '.random |-> "ABS.StdLib.Cons"["num"[RAND] :: "ABS.StdLib.Nil"[emp]]))
      /\ { L | SL } := findProcess(W1, N)
      /\ O := L['this]
      [label PrQ-schedulable] .

    *** A common initial configuration.  The timed version differs in that the
    *** clock has value 0 instead of -1.
  op initConf : Configuration Cid DataList Int Int -> Configuration .
  eq initConf(CN:Configuration, CID:Cid, DL:DataList, INIT:Int, LIM:Int) =
    CN:Configuration
    < INIT:Int : Clock | Limit: LIM:Int >
    < ob('main, 0) : Cog | Object: ob('main, 0), DC: ob('ABS.DC.DeploymentComponent, -1), Sched: "ABS.Scheduler.defaultscheduler"('queue),
      Pr: { '.deadline |-> "ABS.StdLib.InfDuration"[ emp ], '_ |-> null, '.random |-> "ABS.StdLib.Nil"[emp], '.staticfuture |-> null, 'x |-> null, 'this |-> ob('main, 0) | new('x ; CID:Cid ; DL:DataList) },
      PrQ: noProc >
    < ob('ABS.DC.DeploymentComponent, -1) : 'ABS.DC.DeploymentComponent |
      Cog: ob('main, 0),
      Att: 'cpu |-> "ABS.DC.InfCPU"[emp], 'creationTime |-> "ABS.StdLib.Time"["num"[0]], 'description |-> "str"["Environment"], 'history |-> "ABS.StdLib.Nil"[emp], 'initialized |-> "ABS.StdLib.True"[ emp ], 'internalState |-> "num"[0], 'nextcpu |-> "ABS.DC.InfCPU"[emp], 'totalhistory |-> "ABS.StdLib.Nil"[emp],
      Lcnt: 0 >
    < ob('main, 0) : '... | Cog: ob('main, 0), Att: noSubst, Lcnt: 0 >
    < LocId | 0 > . *** Component Model Extension

  *** evaluate cost expression only once.
  ceq < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: O, DC: ODC, Sched: SCH:Expr, Pr: { L | [COST]ST:Stmt ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: O, DC: ODC, Sched: SCH:Expr, Pr: { L | [COSTN:Data]ST:Stmt ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if not COST :: Data
      /\ COSTN:Data := eval(COST, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> ODC, '.random |-> L['.random])) .
    
  --- Resource consumption.  Must be a rewrite rule for confluence.
  *** DC variables:
  var ODC : Oid .    var CG1 : Cogid . var STATE : Data .
  var F1 : Nat .    vars COSTNAT DCRES MINCOST : Rat .
  crl < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < CG : Cog | Object: O, DC: ODC, Sched: SCH:Expr, Pr: { L | ["num"[COSTNAT]]ST:Stmt ; SL }, PrQ: W >
    < ODC : 'ABS.DC.DeploymentComponent |
      Cog: CG1,
      Att: 'cpu |-> CPU:Data, 'internalState |-> STATE, 'initialized |-> "ABS.StdLib.True"[ emp ], S1, Lcnt: F1 >
  => < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < CG : Cog | Object: O, DC: ODC, Sched: SCH:Expr, Pr: { L | ["num"[COSTNAT - MINCOST]]ST:Stmt ; SL }, PrQ: W >
    < ODC : 'ABS.DC.DeploymentComponent |
      Cog: CG1,
      Att: 'cpu |-> CPU:Data, 'internalState |-> STATE':Data, 'initialized |-> "ABS.StdLib.True"[ emp ], S1, Lcnt: F1 >
  if COSTNAT > 0
      /\ DCRES := getFreeResources(STATE, CPU:Data, COSTNAT)
      /\ DCRES > 0
      /\ MINCOST := min(COSTNAT, DCRES)
      /\ STATE':Data := consumeDCResource(STATE, MINCOST)
  [label consume-resources] .
  

  eq < CG : Cog | Object: O1, DC: DC:Data, Sched: SCH:Expr, Pr: { L | ["num"[0]]ST:Stmt ; SL }, PrQ: W >
  =  < CG : Cog | Object: O1, DC: DC:Data, Sched: SCH:Expr, Pr: { L | ST:Stmt ; SL }, PrQ: W >
  [label remove-annotation] .


endm
mod ABS-MACHINE-BASICS-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .
  protecting ABS-MACHINE-BASICS-COMMON .

  vars O O1 : Oid .         vars C B : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G X : Nat .
  var CN : Configuration .  var P : Process .    vars A A' : Vid .
  var E : Expr .            var AL : VidList .   var N : Label .
  var Q : String .      var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  var M : Mid .
  var CG : Cogid .
  var MAC : SSubst .
  var SC : Expr .
  var COST : Expr .

  --- mark
  ---
  --- Mark a label in use.  We don't bother to make this a rule until we need
  --- it.
  ceq
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: CO, References: G, Value: D >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $mark(E) ; SL }, PrQ: W >
  =
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: CO, References: G + 1, Value: D >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
  if N := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      [label mark] .

  --- Ignore superfluous $mark instructions -- these are generated for code
  --- fragments that are not type-checked (e.g. within deltas) since the
  --- method signature is not available there.
  ceq
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $mark(E) ; SL }, PrQ: W >
  =
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
  if not eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) :: Label
      [label ignored-mark] .

  --- free
  ---
  --- Free a Future.
  ---
  ceq
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $release(E) ; SL }, PrQ: W >
    < N : Future | Name: M, Completed: CO, References: G, Value: D >
  =
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    < N : Future | Name: M, Completed: CO,
                   References: if G == 0 then 0 else sd(G, 1) fi,
                   Value: D >
    *** HACK: L can be noSubst, so we might not be able to look up the deadline
  if N := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> "ABS.StdLib.InfDuration"[ emp ], '.comp |-> DC:Data))
      [label free] .

  --- Introduce a new variable into the local scope.
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $vardecl( A ; E ) ; SL}, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { insert(A, D, L) | markFutures(D) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if D := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    [label $vardecl] .

  --- assert
  ---
  eq
    { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assert(E) ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F > CN  }
  =
    { if eval(E, (S :: L), CN, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) asBool
      then
        < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
      else
        < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | failure(E) ; SL }, PrQ: W >
      fi
      < O : C | Cog: CG, Att: S, Lcnt: F > 
      CN  }
    [label assert] .
endm
mod ABS-MACHINE-BASICS-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .
  protecting ABS-MACHINE-BASICS-COMMON .

  vars O O1 : Oid .         vars C B : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G : Nat .
  var CN : Configuration .  var P : Process .    vars A A' : Vid .
  vars E E' : Expr .        var AL : VidList .   var N : Label .
  var Q : String .      var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  var T : Rat .
  var CN' : Configuration .
  vars LIM RAND : Nat .
  vars MIN MAX : Rat .
  var MAC : SSubst .
  var M : Mid .
  var CG : Cogid .
  var COST : Expr .

  --- mark
  ---
  --- Mark a label in use.  We don't bother to make this a rule until we need
  --- it.
  ceq
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: CO, References: G, Value: D >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $mark(E) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
  =
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: CO, References: G + 1, Value: D >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
  if N := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      [label mark] .

  --- free
  ---
  --- Free a Future.
  ---
  ceq
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: CO, References: G, Value: D >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $release(E) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
  =
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: CO,
                   References: if G == 0 then 0 else sd(G, 1) fi,
                   Value: D >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W:MProc >
    < T : Clock | Limit: LIM, Random: RAND >
    *** HACK: L can be noSubst, so we might not be able to look up the deadline
  if N := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> "ABS.StdLib.InfDuration"[ emp ], '.comp |-> DC:Data))
      [label free] .

  --- Introduce a new variable into the local scope.
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $vardecl( A ; E ) ; SL}, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { insert(A, D, L) | markFutures(D) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if D := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    [label $vardecl] .

  --- assert
  ---
  eq
    { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assert(E) ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F > 
      < T : Clock | Limit: LIM, Random: RAND >
      CN  }
  =
    { if eval(E, (S :: L), CN, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) asBool
      then
        < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
      else
        < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | failure(E) ; SL }, PrQ: W >
      fi
      < O : C | Cog: CG, Att: S, Lcnt: F > 
      < T : Clock | Limit: LIM, Random: RAND >
      CN  }
    [label assert] .

  *** Clock advancement.

  *** 0 <= mte <= 1 since the clock has to stop at integer boundaries so
  *** deployment components refill.
  op mte : MProc Configuration SSubst -> Rat .
  ceq mte((W, { L | SL }), < O : C | Cog: CG, Att: S, Lcnt: F > CN, MAC) =
    if MTE:Rat == 0 then 0
    else min(MTE:Rat, mte(W, < O : C | Cog: CG, Att: S, Lcnt: F > CN, MAC)) fi
  if O := L['this]
  /\ MTE:Rat := mte(SL, (S :: L), < O : C | Cog: CG, Att: S, Lcnt: F > CN, $insert('.deadline, L['.deadline], MAC)) .
  eq mte(noProc, CN, MAC) = 1 .

  op mte : Configuration Configuration SSubst -> Rat .
  *** Don't advance clock if a method invocation is on its way.
  eq mte (m:Msg CN, CN', MAC) = 0 .
  *** Don't advance clock if cog is idle but has processes that can run now
  ceq mte (
      < CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W >
      CN, CN', MAC) =
    if MTE:Rat == 0 then 0
    else min(MTE:Rat, mte (CN,
          < CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W > CN', MAC))
    fi
    *** pass in cog, it's needed to find the deployment component
  if MTE:Rat := mte(W, < CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W > CN CN', ('.comp |-> DC:Data, MAC)) .
  *** Don't advance clock if process is executing and can execute. "can execute" means
  *** "schedulable" in this case since a get-operation should not block time
  *** advance, even though it _is_ allowed to block the cog (which is the
  *** difference between executable and schedulable)
  ceq mte (
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F >
      CN, CN', MAC)
  =
    if MTE:Rat == 0 then 0
    else min(MTE:Rat, mte(< O : C | Cog: CG, Att: S, Lcnt: F > CN, < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W > CN', MAC))
    fi
  if MTE:Rat := mte(SL, S :: L,
        < O : C | Cog: CG, Att: S, Lcnt: F > < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W > CN CN',
        ('.deadline |-> L['.deadline], '.comp |-> DC:Data, MAC)) .
  *** Maximum time advance == 1.
  eq mte(CN, CN', MAC) = 1 [owise] .
  

  *** Advance time by T steps: decrement durations in blocked processes and
  *** waiting processes.  If third parameter = true, replenish resources in
  *** deployment component as well.
  op advance : Configuration Rat Bool -> Configuration .
  eq advance(< O : 'ABS.DC.DeploymentComponent
                 | Cog: CG, Att: ('cpu |-> CPU:Data, 'history |-> HI:Data, 'internalState |-> "num"[IS:Rat], 'nextcpu |-> NCPU:Data, 'totalhistory |-> THI:Data, S),
                   Lcnt: F > CN, T, true)
  =
    < O : 'ABS.DC.DeploymentComponent
        | Cog: CG, Att: (
            'cpu |-> NCPU:Data,
            'history |-> "ABS.StdLib.Cons"["num"[IS:Rat] :: HI:Data],
            'internalState |-> "num"[0], 'nextcpu |-> NCPU:Data,
            'totalhistory |-> advanceTotalsHistory(CPU:Data, THI:Data),
            S),
    Lcnt: F >
    advance(CN, T, true) .

  eq advance(< CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr, Pr: P, PrQ: W >
      CN, T, RES:Bool)
  =
    < CG : Cog | Object: X:Data, DC: DC:Data, Sched: SCH:Expr,
    Pr: advanceActiveProcess(P, T),
    PrQ: advanceProcesses(W, CN, T) >
    advance(CN, T, RES:Bool) .

  eq advance(CN, T, RES:Bool) = CN [owise] .


  op advanceTotalsHistory : Data Data -> Data .
  eq advanceTotalsHistory("ABS.DC.InfCPU"[emp], THI:Data) = THI:Data .
  eq advanceTotalsHistory("ABS.DC.CPU"[T:Data], THI:Data) = "ABS.StdLib.Cons"[T:Data :: THI:Data] .

  op reduceDeadline : Subst Rat -> Subst .
  eq reduceDeadline(L, T) = update('.deadline, eval("ABS.StdLib.subtractFromDuration"((L['.deadline] :: "num"[T])), noSubst, none, noSubst), L) .
  op reduceCost : Subst Rat -> Subst .
  eq reduceCost(L, T) = update('.c, eval("ABS.StdLib.subtractFromDuration"((L['.deadline] :: "num"[T])), noSubst, none, noSubst), L) .

  op advanceProcesses : MProc Configuration Rat -> MProc .
  ceq advanceProcesses((P, W), CN, T) =
    advanceProcess(P, CN, T), advanceProcesses(W, CN, T)
  if W =/= noProc .
  eq advanceProcesses(P, CN, T) = advanceProcess(P, CN, T) .
  eq advanceProcesses(noProc, CN, T) = noProc .

  op advanceProcess : Process Configuration Rat -> Process .
  ceq advanceProcess({ L | await E ; SL }, < O : C | Cog: CG, Att: S, Lcnt: F > CN, T) =
    { reduceDeadline(L, T) | await advanceDelays(E, (S :: L), ('.deadline |-> L['.deadline], '.time |-> "num"[T]), T) ; SL }
  if O := L['this] .
  eq advanceProcess({ L | SL }, CN, T) = { reduceDeadline(L, T) | SL } [owise] .

  op advanceActiveProcess : Process Rat -> Process .
  eq advanceActiveProcess(idle, T) = idle .
  eq advanceActiveProcess({ L | $duration( MIN ; MAX ) ; SL }, T) =
      { reduceCost(reduceDeadline(L, T), T) | $duration( max(MIN - T, 0) ; max(MAX - T, 0) ) ; SL } .
  eq advanceActiveProcess({ L | SL }, T) =
      { reduceCost(reduceDeadline(L, T), T) | SL }
    [owise] .
  

  op advanceDelays : Expr Subst SSubst Rat -> Expr .
  eq advanceDelays("&&"(E :: E'), S, MAC, T) =
    "&&"(advanceDelays(E, S, MAC, T) :: advanceDelays(E', S, MAC, T)) .
  ceq advanceDelays(?duration(E ; E'), S, MAC, T) =
    ?duration("num"[max(MIN - T, 0)] ; "num"[max(MAX - T, 0)])
  if MIN := eval(E, S, none, MAC) asRat
      /\ MAX := eval(E', S, none, MAC) asRat .
  eq advanceDelays(E, S, MAC, T) = E [owise] .

  *** Now advance the clock.
  crl
    { CN < T : Clock | Limit: LIM, Random: RAND > }
  =>
    { advance(CN, TICK:Rat, (T + TICK:Rat) :: Nat)
      < T + TICK:Rat : Clock | Limit: LIM, Random: RAND >  }
  if MTE:Rat := mte(CN, none, '.time |-> "num"[T]) *** 0 <= MTE <= 1
      /\ MTE:Rat > 0
      /\ TICK:Rat := if T :: Nat then MTE:Rat else trunc(T + MTE:Rat) - T fi
      /\ T + TICK:Rat <= LIM
      [ label tick ] .
      
endm



*** The Skip statement.
mod ABS-STMT-SKIP-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : Cogid .
  var COST : Expr .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | skip ; SL }, PrQ: W >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    [label skip] .
endm
mod ABS-STMT-SKIP-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : Cogid .
  var COST : Expr .
  var T : Rat .
  vars LIM RAND : Nat .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | skip ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    [label skip] .
endm

*** The Assign statement.

*** Execute an assignment.  The expression on the right hand side of the
*** assignment is evaluated and stored as new value for the left hand side
*** identifier.
mod ABS-STMT-ASSIGN-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var CG : Cogid .
  var Q : Qid .
  var D' : Data .
  var COST : Expr .

  *** Variable or field assignment
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(Q ; E) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>
    if hasMapping(L, Q) then
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { update(Q, D, L) |  markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F >
    else
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: insert(Q, D, S), Lcnt: F >
    fi
    if D := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ D' := (S :: L)[Q]
    [label assignment] .

  *** Field assignment
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: insert(Q, D, S), Lcnt: F >
  if  D := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ D' := S[Q]
    [label field-assignment] .
endm
mod ABS-STMT-ASSIGN-EQ-TIMED is
  protecting ABS-EVAL .
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var CG : Cogid .
  var T : Rat .        var Q : Qid .
  var D' : Data .
  vars LIM RAND : Nat .
  var COST : Expr .

  *** Variable or field assignment.
  ceq
    < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(Q ; E) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < T : Clock | Limit: LIM, Random: RAND >
    if hasMapping(L, Q) then
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { update(Q, D, L) |  markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F >
    else
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: insert(Q, D, S), Lcnt: F >
    fi
    if D := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ D' := (S :: L)[Q]
    [label assignment] .

  *** Field assignment.
  ceq
    < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < T : Clock | Limit: LIM, Random: RAND >
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: insert(Q, D, S), Lcnt: F >
  if D := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ D' := S[Q]
    [label field-assignment] .
endm

mod ABS-STMT-GOTO-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .
  var CONF : Configuration .
  var CG : Cogid .
  var T : Rat .
  vars LIM RAND : Nat .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | movecogto(E) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>
    < CG : Cog | Object: O, DC: TARGET:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if TARGET:Data := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    [label goto] .
endm
mod ABS-STMT-GOTO-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .
  var CONF : Configuration .
  var CG : Cogid .
  var T : Rat .
  vars LIM RAND : Nat .

  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | movecogto(E) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: TARGET:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if TARGET:Data := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    [label goto] .
endm

*** The conditional (if_then_else) statement.
mod ABS-STMT-COND-RL is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .      vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .                var CG : Cogid .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>
    if eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) asBool then
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL1 ; SL }, PrQ: W >
    else
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL2 ; SL }, PrQ: W >
    fi
    < O : C | Cog: CG, Att: S, Lcnt: F >
    [label if-then-else] .
endm
mod ABS-STMT-COND-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .       vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .     var F : Nat .
  var E : Expr .                var T : Rat .       var CG : Cogid .
  vars LIM RAND : Nat .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    if eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) asBool then
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL1 ; SL }, PrQ: W >
    else
      < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL2 ; SL }, PrQ: W >
    fi
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    [label if-then-else] .
endm

*** The looping (while) statement.
mod ABS-STMT-WHILE-RL is
  protecting ABS-EVAL .
  var O : Oid .             var C : Cid .      vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .            var CG : Cogid .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | while E do SL1 od ; SL }, PrQ: W >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el noStmt fi ; SL },
              PrQ: W >
    [label while] .
endm
mod ABS-STMT-WHILE-EQ is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .      vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .    var F : Nat .
  var E : Expr .            var CG : Cogid .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | while E do SL1 od ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el noStmt fi ; SL },
              PrQ: W >
    [label while] .
endm

*** The Suspend statement.
***
*** The suspend statement is an unconditional processor release point.
mod ABS-STMT-SUSPEND-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : Cogid .
  var COST : Expr .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | suspend ; SL }, PrQ: W >
  =>
    < CG : Cog | Object: null, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W , { L | SL } >
    [label suspend] .
endm
mod ABS-STMT-SUSPEND-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : Cogid .
  var COST : Expr .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | suspend ; SL }, PrQ: W >
  =
    < CG : Cog | Object: null, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W , { L | SL } >
    [label suspend] .
endm

*** The Duration statement.
***
*** The duration statement blocks the object (or cog) for a period between the
*** minimum and maximum given.  In the untimed interpreter, it is equivalent
*** to a skip statement.
mod ABS-STMT-DURATION-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : Cogid .
  vars E1 E2 : Expr .
  var COST : Expr .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | duration( E1 ; E2 ) ; SL }, PrQ: W >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    [label duration] .
endm
mod ABS-STMT-DURATION-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var CG : Cogid .
  vars E1 E2 : Expr .
  var T : Rat .
  vars LIM RAND : Nat .
  vars MIN MAX : Rat .
  var COST : Expr .

  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | duration( E1 ; E2 ) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $duration( MIN ; MAX ) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  if MIN := (eval(E1, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) asRat)
      /\ MAX := (eval(E2, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])) asRat)
    [label duration] .

  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $duration( MIN ; MAX ) ; SL }, PrQ: W >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
  if MIN <= 0 [label duration-finished] .

endm

*** The Await statement.

*** These rules capture the entire state CN since the condition E can depend
*** on the state of Futures (and therefore CN needs to be passed to
*** "executable").
mod ABS-STMT-AWAIT-RL is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   var Q : String .
  var CG : Cogid .

  rl
    { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | await E ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F >
      CN  }
  =>
    if executable(await E, (S :: L), (< O : C | Cog: CG, Att: S, Lcnt: F > CN), ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data)) then
      { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
        < O : C | Cog: CG, Att: S, Lcnt: F >
        CN  }
    else
      { < CG : Cog | Object: null, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W , { L | await E ; SL} >
        < O : C | Cog: CG, Att: S, Lcnt: F >
        CN  }
    fi
      [label await] .
endm
mod ABS-STMT-AWAIT-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   var Q : String .
  var T : Rat .
  vars LIM RAND : Nat .
  var CG : Cogid .

  eq
    { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | await E ; SL }, PrQ: W >
      < O : C | Cog: CG, Att: S, Lcnt: F >
      < T : Clock | Limit: LIM, Random: RAND >
      CN  }
  =
    if executable(await E, (S :: L), CN, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data)) then
      { < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
        < O : C | Cog: CG, Att: S, Lcnt: F >
        < T : Clock | Limit: LIM, Random: RAND >
        CN  }
    else
      { < CG : Cog | Object: null, DC: DC:Data, Sched: SCH:Expr, Pr: idle, PrQ: W , { L | await E ; SL} >
        < O : C | Cog: CG, Att: S, Lcnt: F >
        < T : Clock | Limit: LIM, Random: RAND >
        CN  }
    fi
      [label await] .
endm

*** METHOD CALLS
mod ABS-CALLSTMTS-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .            vars C C1 : Cid .    vars S S1 L : Subst .
  var SL : StmtList .          vars W W1 : MProc .  vars F F1 G : Nat .
  var CN : Configuration .     var E : Expr .       var Q : String .
  var A : Vid .                var EL : ExprList .  var AL : VidList .
  var N : Label .              var DL : DataList .  var MS : MMtd .
  var SS : SSubst .
  var MIS : MMtd .             var P1 : Process .
  var DE : Expr .
  var M : Mid .
  vars CG CG1 : Cogid .
  var COST : Expr .

  --- async-call
  ---
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | asynccall(A ; E ; M ; EL ; DE); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; N) ; $call(N ; O1 ; M ; DL ; false ; eval(DE, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
  if DL :=  evalList(EL, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ O1 := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ N := label(O, F)
      [label async-call] .

  --- sync-call
  ---
  --- Create a $cont at end of called process if both objects are in the same
  --- cog (CG == CG1)
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | synccall(A ; E ; M ; EL ; DE); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < O1 : C1 | Cog: CG1, Att: S1, Lcnt: F1 >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; N) ; $call(N ; O1 ; M ; DL ; (CG == CG1) ; eval(DE, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < O1 : C1 | Cog: CG1, Att: S1, Lcnt: F1 >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
  if DL :=  evalList(EL, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ O1 := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ N := label(O, F)
      [label sync-call] .

  --- sync-selfcall
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | synccall(A ; E ; M ; EL ; DE); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; N) ; $call(N ; O ; M ; DL ; true ; eval(DE, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
  if DL :=  evalList(EL, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ O := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ N := label(O, F)
      [label sync-selfcall] .
endm
mod ABS-CALLSTMTS-EQ-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .            vars C C1 : Cid .     vars S S1 L : Subst .
  var SL : StmtList .          vars W W1 : MProc .   vars F F1 G : Nat .
  var CN : Configuration .     var E : Expr .        vars Q : String .
  var A : Vid .                var EL : ExprList .   var AL : VidList .
  var N : Label .              var DL : DataList .   var MS : MMtd .
  var T : Rat .                var SS : SSubst .     var MIS : MMtd .
  var P1 : Process .
  var DE : Expr .
  var M : Mid .
  vars CG CG1 : Cogid .
  vars LIM RAND : Nat .
  var COST : Expr .

  --- async-call
  ---
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | asynccall(A ; E ; M ; EL ; DE) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; N) ; $call(N ; O1 ; M ; DL ; false ; eval(DE, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
  if DL :=  evalList(EL, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ O1 := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ N := label(O, F)
      [label async-call] .

  --- sync-call
  ---
  --- Create a $cont at end of called process if both objects are in the same
  --- cog (CG == CG1)
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | synccall(A ; E ; M ; EL ; DE); SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < O1 : C1 | Cog: CG1, Att: S1, Lcnt: F1 >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; N) ; $call(N ; O1 ; M ; DL ; (CG == CG1) ; eval(DE, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < O1 : C1 | Cog: CG1, Att: S1, Lcnt: F1 >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
  if DL :=  evalList(EL, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ O1 := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ N := label(O, F)
      [label sync-call] .

  --- sync-selfcall
  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | synccall(A ; E ; M ; EL ; DE) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; N) ; $call(N ; O ; M ; DL ; true ; eval(DE, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
  if DL :=  evalList(EL, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ O := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      /\ N := label(O, F)
      [label sync-selfcall] .

endm


*** OBJECT CREATION

*** Also start the '.init method.
mod ABS-NEW-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .  vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E : Expr .       var A : Vid .     var EL : ExprList .
  var AL : VidList .   var MS : MMtd .
  var CG : Cogid .
  vars SC SC' : Expr .
  var COST : Expr .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | new(A ; B ; EL); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: G >
  =>
    *** Here we get to write the whole synchronous invocation /
    *** synchronization protocol by hand (normally it is generated by the code
    *** generator)
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; ob(B, G)); synccall('.staticfuture ; ob(B, G) ; '.init ; emp ; "ABS.StdLib.InfDuration"[ emp]) ; get( '.staticfuture ; '_) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: (s G) >
    < ob(B, G) :  B | Cog: CG, Att: ('.nbcr |-> "num"[0], S1,
                               createSubst(AL, evalList(EL, S :: L, none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])))),
                      Lcnt: 0 >
    [label new-object] .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newcog(A ; B ; EL ; E); SL }, PrQ: W >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: G >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newcog(A ; B ; EL ; E ; SC); SL }, PrQ: W >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: G >
    [label newcog-add-scheduler] .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newcog(A ; B ; EL ; E ; SC); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC', Mtds: MS, Ocnt: G >
  =>
    *** we synchronize with the call to .init because otherwise another call
    *** immediately afterwards might overtake the call to .init
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; ob(B, G)) ; asynccall('.staticfuture ; ob(B, G) ; '.init ; emp ; "ABS.StdLib.InfDuration"[ emp ]) ; get( '.staticfuture ; '_) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC', Mtds: MS, Ocnt: (s G) >
    < ob(B, G) :  B | Cog: ob(B, G),
                             Att: ('.nbcr |-> "num"[0], S1,
                               createSubst(AL, evalList(EL, S :: L, none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])))),
                      Lcnt: 0 >
    < ob(B, G) : Cog | Object: null, DC: NEWDC:Data, Sched: SC, Pr: idle, PrQ: noProc >
    if NEWDC:Data := eval(E, S :: L, none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    [label new-object-with-cog] .
endm
mod ABS-NEW-EQ-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .   vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .    vars F G : Nat .
  var E : Expr .       var A : Vid .      var EL : ExprList .
  var AL : VidList .   var MS : MMtd .
  var T : Rat .        var CG : Cogid .
  vars SC SC' : Expr .
  vars LIM RAND : Nat .
  var COST : Expr .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | new(A ; B ; EL); SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: G >
  =
    *** Here we get to write the whole synchronous invocation /
    *** synchronization protocol by hand (normally it is generated by the code
    *** generator)
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; ob(B, G)); synccall('.staticfuture ; ob(B, G) ; '.init ; emp ; "ABS.StdLib.InfDuration"[ emp ]) ; get( '.staticfuture ; '_) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: (s G) >
    < ob(B, G) :  B | Cog: CG, Att: (S1,
                               createSubst(AL, evalList(EL, S :: L, none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])))),
                      Lcnt: 0 >
    [label new-object] .

  eq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newcog(A ; B ; EL ; E); SL }, PrQ: W >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: G >
  =
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newcog(A ; B ; EL ; E ; SC); SL }, PrQ: W >
    < B : Class | Param: AL, Att: S1, Sched: SC, Mtds: MS, Ocnt: G >
    [label newcog-add-scheduler] .

  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newcog(A ; B ; EL ; E ; SC); SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Sched: SC', Mtds: MS, Ocnt: G >
  =
    *** we synchronize with the call to .init because otherwise another call
    *** immediately afterwards might overtake the call to .init
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; ob(B, G)) ; asynccall('.staticfuture ; ob(B, G) ; '.init ; emp ; "ABS.StdLib.InfDuration"[ emp ]) ; get( '.staticfuture ; '_) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: (s F) >
    < B : Class | Param: AL, Att: S1, Sched: SC', Mtds: MS, Ocnt: (s G) >
    < ob(B, G) :  B | Cog: ob(B, G),
                             Att: (S1,
                               createSubst(AL, evalList(EL, S :: L, none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random])))),
                      Lcnt: 0 >
    < ob(B, G) : Cog | Object: null, DC: NEWDC:Data, Sched: SC, Pr: idle, PrQ: noProc >
    if NEWDC:Data := eval(E, S :: L, none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    [label new-object-with-cog] .
endm


*** The Return statement.
mod ABS-STMT-RETURN-RL is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  var Q : String .  var N : Label .  var E : Expr .
  var D : Data .
  var M : Mid .
  var CG : Cogid .
  var COST : Expr .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | return(E); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: false, References: G, Value: null >
   =>
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process .  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: true, References: G, Value: D >
  if N == L['.label] /\ D := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      [label return] .
endm
mod ABS-STMT-RETURN-EQ-TIMED is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  var Q : String .  var N : Label .  var E : Expr .
  var T : Rat .
  vars LIM RAND : Nat .
  var D : Data .
  var M : Mid .
  var CG : Cogid .
  var COST : Expr .

  ceq
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | return(E); SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: false, References: G, Value: null >
   =
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; SL }, PrQ: W >
    < T : Clock | Limit: LIM, Random: RAND >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: true, References: G, Value: D >
  if N == L['.label] /\ D := eval(E, (S :: L), none, ('.time |-> "num"[T], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
      [label return] .
endm


*** Receiving results from Futures.
***
*** Major source of nondeterminism and non-confluence if carelessly made into
*** equations, according to Creol interpreter.  We leave them as rules for
*** now.
mod ABS-RECEIVE-RESULT is
  protecting ABS-EVAL .

  vars O O1 : Oid .            vars B C : Cid .     vars S S1 L L1 : Subst .
  vars SL SL1 : StmtList .  vars W W1 : MProc .  vars F G X : Nat .
  var Q : String .      vars A A' : Vid .    var N : Label .
  var D : Data .
  var M : Mid .
  var CG : Cogid .
  var COST : Expr .

  --- receive-comp
  ---
  --- Must be a rule even in the model checker, because there might be
  --- multiple completion messages with the same label but different return
  --- values in the queue.
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | get(A ; A') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: true, References: G, Value: D >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A' ; D) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: true, References: G, Value: D >
  if N := (S :: L)[A]
    [label receive-comp-var] .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | get(@ A ; A') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: true, References: G, Value: D >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A' ; D) ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < N : Future | Name: M, Completed: true, References: G, Value: D >
  if N := S[A]
    [label receive-comp-field] .


  --- continue
  ---
  --- Continue after executing the code of a local reply.  This is always a
  --- rule.  We want it to be a rule in the interpreter.
  ---
  --- If we support shared futures, this must be a rule in the model
  --- checker, because there might be two processes in PrQ which await a
  --- reply to the label.
  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | $cont N }, PrQ: W , { L1 | get(A ; A') ; SL1} >
  =>
    *** HACK: the process with bindings L is unceremoniously dumped, so
    *** freeing the futures it holds is left to the target process
    < CG : Cog | Object: O1, DC: DC:Data, Sched: SCH:Expr, Pr: { L1 | freeFutures(L) ; get(A ; A') ; SL1 }, PrQ: W >
  if N := L1[A]
      /\ O1 := L1['this]
    [label continue-cog] .

endm


**********************************************
*** Component Model Extension: Rebind, Newloc, GetLoc, GetFather and Subloc
mod ABS-REBIND-RL is
  protecting ABS-EVAL .

  vars O O' : Oid .    vars C C' : Cid .    vars S L S' : Subst .
  var SL : StmtList .  vars W : MProc .  vars F F' : Nat .
  vars E E' : Expr .   vars D D' : Data .       var CG : Cogid .
  var Q : Qid .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | rebind(E ; Q ; E') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
  =>   
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: insert(Q, D, S), Lcnt: F >
  if O = eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    /\ D := eval(E', (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    /\ D' := (S :: L)[Q]
    /\ S['.nbcr] == "num"[0]
    [label rebind-local] .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | rebind(E ; Q ; E') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < O' : C' | Cog: CG, Att: S', Lcnt: F' >
  =>   
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | markFutures(D) ; freeFutures(D') ; SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < O' : C' | Cog: CG, Att: insert(Q, D, S'), Lcnt: F' >
  if O' = eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    /\ D := eval(E', (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> DC:Data, '.random |-> L['.random]))
    /\ D' := (S :: L)[Q]
    /\ S'['.nbcr] == "num"[0]
    [label rebind-distant] .


endm
mod ABS-NEWLOC-RL is
  protecting ABS-EVAL .

  var O : Oid .        vars C : Cid .  vars S L : Subst .
  var SL : StmtList .  var W : MProc .   vars G : Nat .
  var A : Vid .     var EL : ExprList .
  var CG : Cogid .

  rl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | newloc( A ); SL }, PrQ: W >
    < LocId | G >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; loc-comp( G )); SL }, PrQ: W  >
    < locRel | loc-top ; loc-comp( G ) >
    < LocId | s G >
    [label new-location] .
endm
mod ABS-GETLOC-RL is
  protecting ABS-EVAL .

  vars O O' : Oid .        vars C C' : Cid .  vars S L S' : Subst .
  var SL : StmtList .  var P : Process . vars W W' : MProc .   vars F F' : Nat .
  var A : Vid .     var E : Expr .
  vars CG CG' : Cogid .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | getloc( A ; E ); SL }, PrQ: W >
    < O' : C | Cog: CG', Att: S, Lcnt: F >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; loc-cog( CG' )); SL }, PrQ: W >
    < O' : C | Cog: CG', Att: S, Lcnt: F >
  if O' = eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> S['.comp], '.random |-> L['.random]))
    [label get-location] .
endm
mod ABS-GETFATHERLOC-RL is
  protecting ABS-EVAL .

  var O : Oid .        vars B C : Cid .  vars S L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var A : Vid .     var E : Expr .
  var CG : Cogid . vars L1 L2 : Location .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | getfather( A ; E ); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < locRel | L1 ; L2 >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | assign(A ; L1 ); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < locRel | L1 ; L2 >
  if L2 := eval(E, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> S['.comp], '.random |-> L['.random]))
    [label get-father-location] .
endm
mod ABS-SUBLOC-RL is
  protecting ABS-EVAL .

  var O : Oid .        vars B C : Cid .  vars S L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E1 E2 : Expr .     var EL : ExprList .
  var CG : Cogid . vars Loc Lp Ln : Location .

  crl
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | subloc( E1 ; E2 ); SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < locRel | Lp ; Loc >
  =>
    < CG : Cog | Object: O, DC: DC:Data, Sched: SCH:Expr, Pr: { L | SL }, PrQ: W >
    < O : C | Cog: CG, Att: S, Lcnt: F >
    < locRel | Ln ; Loc >
  if Loc = eval(E1, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> S['.comp], '.random |-> L['.random]))
   /\ Ln := eval(E2, (S :: L), none, ('.time |-> "num"[-1], '.deadline |-> L['.deadline], '.comp |-> S['.comp], '.random |-> L['.random]))
    [label get-move-location] .
endm
**********************************************

mod ABS-SIMULATOR-RL is
  --- A machine using rewrite rules.
  protecting ABS-MACHINE-BASICS-RL .
  protecting ABS-STMT-SKIP-RL .
  protecting ABS-STMT-ASSIGN-RL .
  protecting ABS-STMT-GOTO-RL .
  protecting ABS-STMT-COND-RL .
  protecting ABS-STMT-WHILE-RL .
  protecting ABS-STMT-SUSPEND-RL .
  protecting ABS-STMT-DURATION-RL .
  protecting ABS-STMT-AWAIT-RL .
  protecting ABS-CALLSTMTS-RL .
  protecting ABS-NEW-RL .
  protecting ABS-STMT-RETURN-RL .
  protecting ABS-RECEIVE-RESULT .
  --- Component Model Extension
  protecting ABS-REBIND-RL .
  protecting ABS-NEWLOC-RL .
  protecting ABS-GETLOC-RL .
  protecting ABS-GETFATHERLOC-RL .
  protecting ABS-SUBLOC-RL .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.  The fourth (Int) operator is not used in the untimed
  --- case.
  op main : Configuration String DataList Int -> State .
  eq main(CN:Configuration, B:String, DL:DataList, LIM:Int) =
    { initConf(CN:Configuration, qid(B:String), DL:DataList, -1, LIM:Int) } .

  --- The initial object commits suicide after it did its job.
  eq < ob('main, 0) : '... | Cog: ob('main, 0), Att: S:Subst, Lcnt: 2 > =
    none .
endm

mod ABS-SIMULATOR-EQ-TIMED is
  --- A machine using equations, with an auto-advancing clock.
  protecting ABS-MACHINE-BASICS-TIMED .
  protecting ABS-STMT-SKIP-EQ .
  protecting ABS-STMT-ASSIGN-EQ-TIMED .
  protecting ABS-STMT-GOTO-EQ .
  protecting ABS-STMT-COND-EQ-TIMED .
  protecting ABS-STMT-WHILE-EQ .
  protecting ABS-STMT-SUSPEND-EQ .
  protecting ABS-STMT-DURATION-EQ-TIMED .
  protecting ABS-STMT-AWAIT-EQ-TIMED .
  protecting ABS-CALLSTMTS-EQ-TIMED .
  protecting ABS-NEW-EQ-TIMED .
  protecting ABS-STMT-RETURN-EQ-TIMED .
  protecting ABS-RECEIVE-RESULT .
  --- Component Model Extension
  protecting ABS-REBIND-RL .
  protecting ABS-NEWLOC-RL .
  protecting ABS-GETLOC-RL .
  protecting ABS-GETFATHERLOC-RL .
  protecting ABS-SUBLOC-RL .


  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.  This version also creates the global clock, with a
  --- limit given by the 4th argument.
  op main : Configuration String DataList Int -> State .
  eq main(CN:Configuration, B:String, DL:DataList, LIM:Int) =
    { initConf(CN:Configuration, qid(B:String), DL:DataList, 0, LIM:Int) } .

  --- The initial object commits suicide after it did its job.
  eq < ob('main, 0) : '... | Cog: ob('main, 0), Att: S:Subst, Lcnt: 2 > =
    none .
endm

eof

*** Local Variables:
*** maude-indent: 2
*** fill-column: 78
*** End:
