aspect ProductLineTypeAnalysis {
    
    public void DeltaTraitModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model){ 
        getMethodModifier().collectMethodIDs(methodIDSet, model);
    }

    public abstract void MethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model);
    public void ModifyMethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model) { 
        getTraitExpr().collectMethodIDs(methodIDSet, model); 
    }
    public void RemoveMethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model) {
        for (MethodSig sig : getMethodSigList()) {
            methodIDSet.add(sig.getName());        
        }
    }
    public void AddMethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model) {
        getTraitExpr().collectMethodIDs(methodIDSet, model); 
    }
    
    public abstract void TraitExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model);
    
    public void TraitNameExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model){ 
        for (Decl decl : model.getDecls()) {
            if(decl instanceof TraitDecl){
                TraitDecl tDecl = (TraitDecl)decl;
                if(tDecl.getName().equals(this.getName())){
                    tDecl.getTraitExpr().collectMethodIDs(methodIDSet, model);
                }
            }
        }
    }
    public void TraitModifyExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model){ 
        getTraitExpr().collectMethodIDs(methodIDSet, model); 
        getMethodModifier().collectMethodIDs(methodIDSet, model); 
    }

    public void TraitSetExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model){ 
        for (MethodImpl met : getMethodImplList()) {
            methodIDSet.add(met.getMethodSig().getName());
        }
    }


    syn lazy SemanticConditionList Model.typeCheckPL() {
        SemanticConditionList errors = new SemanticConditionList();
        if (! hasProductLine())
            return errors;
        ProductLineTypeAnalysisHelper.typeCheckPL(getProductLine(), errors);
        return errors;
    }


    /*
     * Return all valid feature configurations of the feature model.
     * This is done by solving the CSP and only considering features (no attributes, as that could result in a quasi infinite number of configurations)
     */
    syn lazy Set<Set<String>> Model.getFeatureModelConfigurations() {
        if (! hasMTVL())
            return Collections.emptySet();

        ChocoSolver solver = instantiateCSModelFeaturesOnly();
        return solver.getSolutionsFeaturesOnly();
    }


    /*
     * Add all possible products (i.e. all valid feature configurations = feature model solutions)
     * as non-terminal attributes (NTAs) to the AST (as List of Products to the Model node)
     */
    syn nta lazy List<Product> Model.getProductList() {
        List<Product> plist = new List<Product>();

        Set<Set<String>> featureConfs = getFeatureModelConfigurations();
        for (Set<String> features : featureConfs) {
            // set Features
            List<Feature> flist = new List<Feature>();
            for (String fname : features) {
                Feature feature = new Feature(fname, new List<AttrAssignment>()); // disregard any attribute assignments
                flist.add(feature);
            }
            Product product = new Product(flist);
            plist.add(product);
        }
        return plist;
    }

    /* TEST */
//    syn List<Test> Model.getTestList() {
//        List<Test> l = new List<Test>();
//        l.add(new Test(new List<Token>()));
//        return l;
//    }
    

    
    // inform DeltaClause about the DeltaDecl that it references
    syn lazy DeltaDecl DeltaClause.getDeltaDecl() {
        return getProductLine().getModel().getDeltaDeclsMap().get(getDeltaspec().getDeltaID());
    }
    
}
