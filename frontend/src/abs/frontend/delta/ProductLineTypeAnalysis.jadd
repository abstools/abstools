aspect ProductLineTypeAnalysis {




    public void DeltaTraitModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model){
        getTraitOper().collectMethodIDs(methodIDSet, model);;
    }
	public abstract void TraitOper.collectMethodIDs(HashSet<String> methodIDSet, Model model);
	public void ModifyMethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model){ getTraitExpr().collectMethodIDs(methodIDSet, model); }
	public void RemoveMethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model){ methodIDSet.add(getMethodSig().getName()); }
    public void AddMethodModifier.collectMethodIDs(HashSet<String> methodIDSet, Model model){ getTraitExpr().collectMethodIDs(methodIDSet, model); }

	public abstract void TraitExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model);

     public void TraitNameExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model){
      for (Decl decl : model.getDecls()) {
        if(decl instanceof TraitDecl){
            TraitDecl tDecl = (TraitDecl)decl;
            if(tDecl.getName().equals(this.getName())){
                tDecl.getTraitExpr().collectMethodIDs(methodIDSet, model);
            }
        }
    }
  }
    public void TraitModifyExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model){
      getTraitExpr().collectMethodIDs(methodIDSet, model);
      getTraitOper().collectMethodIDs(methodIDSet, model);
  }

    public void TraitSetExpr.collectMethodIDs(HashSet<String> methodIDSet, Model model){
      for (MethodImpl met : getMethodImplList()) {
        methodIDSet.add(met.getMethodSig().getName());
    }
  }


    syn lazy SemanticConditionList Model.typeCheckPL() {
        SemanticConditionList errors = new SemanticConditionList();
        if (! hasProductLine())
            return errors;
        ProductLineTypeAnalysisHelper.typeCheckPL(getProductLine(), errors);

        return errors;
    }

    /*
     * Return all valid feature configurations of the feature model.
     * This is done by solving the CSP and only considering features (no attributes, as that could result in an infinite number of configurations)
     */
    syn lazy Set<Set<String>> Model.getFeatureModelConfigurations() {
        if (! hasMTVL())
            return Collections.emptySet();

        ChocoSolver solver = instantiateCSModelFeaturesOnly();

        return solver.getSolutionsFeaturesOnly();
    }

    /*
     * Add all possible products (i.e. all valid feature configurations = feature model solutions)
     * as non-terminal attributes (NTAs) to the AST (as List of Products to the Model node)
     */
    syn nta lazy List<Product> Model.getProductList() {
        List<Product> plist = new List<Product>();
        Set<Set<String>> featureConfs = getFeatureModelConfigurations();

        for (Set<String> features : featureConfs) {
            // set Features
            List<Feature> flist = new List<Feature>();
            for (String fname : features) {
                Feature feature = new Feature(fname, new List<AttrAssignment>()); // disregard any attribute assignments
                flist.add(feature);
            }
            Product product = new Product(flist);
            plist.add(product);
        }

        return plist;
    }

    // inform DeltaClause about the DeltaDecl that it references
    syn lazy DeltaDecl DeltaClause.getDeltaDecl() {
        return getProductLine().getModel().getDeltaDeclsMap().get(getDeltaspec().getDeltaID());
    }
}
