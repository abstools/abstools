aspect ProductDeclaration {

    /*
     * Evaluate all sorted ProductDecl,
     * and set implicitProduct correspond to a valid set of features from feature model
     */
    public void Model.evaluateAllProductDeclarations() {
        // Initialize set of ProductDecl
        Set<ProductDecl> productDecls = new HashSet<ProductDecl>(getProductDecls());

        // Sort ProductDecls
        TopologicalSorting productSorter = new TopologicalSorting<ProductDecl>(productDecls);
        for (ProductDecl low : productDecls){
            Set<String> allProductName = new HashSet<String>();
            low.getProductExpr().setAllProductName(allProductName);
            for(String productName : allProductName){
                try{
                    ProductDecl high = findProduct(productName);      
                    productSorter.addEdge(high, low);              
                }
                catch(WrongProgramArgumentException e){
                    e.printStackTrace();
                }
            }
        }
        productSorter.sort();
        java.util.List<ProductDecl> sortedList = productSorter.getAnOrder();

        // Evaluate the sorted list of ProductDecl
        for (ProductDecl p : sortedList) {            
            Set<String> featuresProd = new HashSet<String>(); // Initialize set of featuresProd to simplify comparing
            List<Feature> features = new List<Feature>();
            for (Feature f : p.getProductExpr().evaluate()) {
                try {
                    Feature feature = f.clone();
                    features.add(feature);
                    featuresProd.add(feature.getName());
                } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
                }
            }
            p.setImplicitProduct(new ImplicitProduct(features));

            // TODO: Check validity of product
            boolean valid = false;
            List<ImplicitProduct> implicitProducts = getImplicitProducts();
            for(ImplicitProduct impl : implicitProducts){
                Set<String> featuresImpl = new HashSet<String>(); // Initialize set of featuresImpl to simplify comparing
                for(Feature f : impl.getFeatures()){
                    featuresImpl.add(f.getName());
                }

                if(featuresProd.equals(featuresImpl)){
                    valid = true;
                    break;
                }
            }
            
            // Print the result
            System.out.print(p.getName() + " : ");
            for(Feature f : features){
                System.out.print(f.getName() + " ");
            }
            System.out.println();
        }
    }

    /* 
     * Return the corresponding ImplicitProduct obtained through evaluating the product expression
     */
    private ImplicitProduct ProductDecl.implicitProduct;
    public void ProductDecl.setImplicitProduct(ImplicitProduct implicitProduct){
        this.implicitProduct = implicitProduct;
    }
    syn lazy ImplicitProduct ProductDecl.getImplicitProduct() {
        return implicitProduct;
    }

    /*
     * Set all of product name recursively by given object of ProductExpr
     */
    public abstract void ProductExpr.setAllProductName(Set<String> allProductName);

    public void ProductFeatureSet.setAllProductName(Set<String> allProductName){
        return;
    }
    public void ProductIntersect.setAllProductName(Set<String> allProductName){
        getLeft().setAllProductName(allProductName);
        getRight().setAllProductName(allProductName);
    }
    public void ProductUnion.setAllProductName(Set<String> allProductName){
        getLeft().setAllProductName(allProductName);
        getRight().setAllProductName(allProductName);
    }
    public void ProductName.setAllProductName(Set<String> allProductName){
        allProductName.add(getName());
    }

    /*
     * Evaluate recursively the ProductExpr to get set of features
     */
    public abstract Set<Feature> ProductExpr.evaluate();

    public Set<Feature> ProductFeatureSet.evaluate() {
        return listToSet(getFeatures());
    }
    public Set<Feature> ProductIntersect.evaluate(){
        Set<Feature> left = getLeft().evaluate();
        Set<Feature> right = getRight().evaluate();

        return intersection(left, right);
    }
    public Set<Feature> ProductUnion.evaluate(){
        Set<Feature> left = getLeft().evaluate();
        Set<Feature> right = getRight().evaluate();

        return union(left, right);
    }
    public Set<Feature> ProductName.evaluate() {
        try{
            ProductDecl p = getModel().findProduct(getName());
            return listToSet(p.getImplicitProduct().getFeatures());
        }
        catch(WrongProgramArgumentException e){
            e.printStackTrace();
        }

        return null;
    }

    /*
     * Convert list of features to set of features
     */
    public Set<Feature> ProductExpr.listToSet(List<Feature> features){
        Set<Feature> setFeatures = new HashSet<Feature>();
        for(Feature f : features){
            setFeatures.add(f);
        }

        return setFeatures;
    }

    /*
     * Perform the operation union by comparing name of the features
     */
    public Set<Feature> ProductUnion.union(Set<Feature> left, Set<Feature> right){
        for(Feature r : right){
            boolean exist = false;
            for(Feature l : left){
                if(r.getName().equals(l.getName())){
                    exist = true;
                    break;
                }
            }

            if(!exist)
                left.add(r);
        }

        return left;
    }

    /*
     * Perform the operation intersection by comparing name of the features
     */
    public Set<Feature> ProductIntersect.intersection(Set<Feature> left, Set<Feature> right){
        Set<Feature> result = new HashSet<Feature>();

        for(Feature r : right){
            boolean exist = false;
            for(Feature l : left){
                if(r.getName().equals(l.getName())){
                    exist = true;
                    break;
                }
            }

            if(exist)
                result.add(r);
        }

        return result;
    }
}