aspect ProductDeclaration {

    /*
     * Evaluate all sorted ProductDecl and set implicitProduct
     */
    public void Model.evaluateAllProductDeclarations() throws WrongProgramArgumentException {
        // Initialize set of ProductDecl
        Set<ProductDecl> productDecls = new HashSet<ProductDecl>(getProductDecls());

        // Sort all ProductDecl
        TopologicalSorting productSorter = new TopologicalSorting<ProductDecl>(productDecls);
        for (ProductDecl low : productDecls) {
            Set<String> productNames = new HashSet<String>();
            low.getProductExpr().setRightSideProductNames(productNames);
            for (String productName : productNames) {
                ProductDecl high = findProduct(productName);
                productSorter.addEdge(high, low);
            }
        }
        productSorter.sort();
        java.util.List<ProductDecl> sortedList = productSorter.getAnOrder();

        // Evaluate sorted list of ProductDecl
        for (ProductDecl p : sortedList) {
            List<Feature> features = new List<Feature>();
            for (Feature f : p.getProductExpr().evaluate()) {
                features.add(f.treeCopyNoTransform());
            }
            p.setImplicitProduct(new ImplicitProduct(features));

            // Debug: Print evaluation result
            /*
            System.out.print(p.getName() + " : ");
            for(Feature f : features){
                System.out.print(f.getName() + " ");
            }
            System.out.println();
             */
        }
    }

    /*
     * Return true if this ImplicitProduct is the same as the ImplicitProduct argument; false otherwise.
     */    
    public boolean ImplicitProduct.equals(ImplicitProduct impl) {
        Set<Feature> features = new HashSet<Feature>(ListUtils.ASTListToSet(getFeatures()));
        Set<Feature> implFeatures = new HashSet<Feature>(ListUtils.ASTListToSet(impl.getFeatures())); 
        
        return features.equals(implFeatures);
    }
    public boolean Feature.equals(Feature f) {
        return getName().equals(f.getName());
    }

    /* 
     * Return the corresponding ImplicitProduct obtained through evaluating the product expression
     */
    private ImplicitProduct ProductDecl.implicitProduct;
    public void ProductDecl.setImplicitProduct(ImplicitProduct impl) {
        this.implicitProduct = impl;
    }
    syn lazy ImplicitProduct ProductDecl.getImplicitProduct() {
        return implicitProduct;
    }

    /*
     * Set all of product name recursively by given object of ProductExpr
     */
    public abstract void ProductExpr.setRightSideProductNames(Set<String> productNames);

    public void ProductFeatureSet.setRightSideProductNames(Set<String> productNames) {
        return;
    }
    public void ProductIntersect.setRightSideProductNames(Set<String> productNames) {
        getLeft().setRightSideProductNames(productNames);
        getRight().setRightSideProductNames(productNames);
    }
    public void ProductUnion.setRightSideProductNames(Set<String> productNames) {
        getLeft().setRightSideProductNames(productNames);
        getRight().setRightSideProductNames(productNames);
    }
    public void ProductName.setRightSideProductNames(Set<String> productNames) {
        productNames.add(getName());
    }

    /*
     * Evaluate recursively the ProductExpr to get set of features
     */
    public abstract Set<Feature> ProductExpr.evaluate() throws WrongProgramArgumentException;

    public Set<Feature> ProductFeatureSet.evaluate() throws WrongProgramArgumentException {
        return ListUtils.ASTListToSet(getFeatures());
    }
    public Set<Feature> ProductIntersect.evaluate() throws WrongProgramArgumentException {
        return intersection(getLeft().evaluate(), getRight().evaluate());
    }
    public Set<Feature> ProductUnion.evaluate() throws WrongProgramArgumentException {
        return union(getLeft().evaluate(), getRight().evaluate());
    }
    public Set<Feature> ProductName.evaluate() throws WrongProgramArgumentException {
        ProductDecl p = getModel().findProduct(getName());
        
        return ListUtils.ASTListToSet(p.getImplicitProduct().getFeatures());
    }

    /*
     * Perform the operation union by comparing name of the features
     */
    public Set<Feature> ProductUnion.union(Set<Feature> left, Set<Feature> right) {
        for (Feature r : right) {
            boolean exist = false;
            for (Feature l : left) {
                if (r.equals(l)) {
                    exist = true;
                    break;
                }
            }

            if (!exist)
                left.add(r);
        }

        return left;
    }

    /*
     * Perform the operation intersection by comparing name of the features
     */
    public Set<Feature> ProductIntersect.intersection(Set<Feature> left, Set<Feature> right) {
        Set<Feature> result = new HashSet<Feature>();

        for (Feature r : right) {
            boolean exist = false;
            for (Feature l : left) {
                if (r.equals(l)) {
                    exist = true;
                    break;
                }
            }

            if (exist)
                result.add(r);
        }

        return result;
    }
}