/* HOW IS DIVIDED THIS FILE:
 
 //NEW IMPORT contains the new import file respect TypeInference.jadd
 
 between     //Map Interface_name to Class_name         and             //END Map Interface_name to Class_name
 there are attribute for calculate a mapping between Interface_name and Class_name
 
 between     //OLD ENVIRONMENT CREATION             and         //END OLD ENVIRONMENT CREATION
 there are attribute for create the initial environmant, this is the old code based on old unification algorithm
 
 between     //NEW ENVIRONMENT CREATION             and         //END NEW ENVIRONMENT CREATION
 there are new aspect for calculate the initial environment based on new semiUnification algorithm, what before was attribute, now is aspect becouse of
 the fact that we need to pass a Factory for the creation of Term, in this case freshTermVariable to put into the Environment
 
 between    //TYPEINFERENCE         and         //END TYPEINFERENCE
 there are the aspetc for implement the inference rule, all the inference rule inside paper are written, more than these there are also rule for AST node, necessary for the computanion, e.g. PureExp.typeInference( ... ), we need to discuss how perform it, rule are empty now.
 More than there rule there are also the "super" rule of the biggest node of AST, e.g. Model.typeInference( ... );
 I suppose (and comment) that Model only need Factory to work, and inside Model could be recover the Environment and the mapping between InterfaceName and ClassName.
 
  */

import abs.frontend.typechecker.*;


import java.util.HashMap;
import java.util.LinkedList;
import java.io.PrintStream;

import deadlock.constraints.term.*;

import deadlock.analyser.factory.*;
import deadlock.analyser.generation.*;


aspect TypeInference {


/************************************/
/* Helper function                  */
/************************************/
  RecordPresent ClassDecl.createInstance(Factory df, GroupName a, PrintStream out) {
  // TODO: deal with field assignement, with init, and run
    LinkedList<RecordField> l = new LinkedList<RecordField>();
    Environment env = new Environment();
    for(ParamDecl f : this.getParams()) {
      RecordVariable X = df.newRecordVariable();
      env.putVariable(f.getName(), X);
      l.add(df.newRecordField(f.getName(), X));
    }
    for(FieldDecl f : this.getFields()) {
      if(f.hasInitExp()) {
        l.add(df.newRecordField(f.getName(), f.getInitExp().typeInferenceAsPure(null, env, a, null, df, this, out).getRepresentative()));
      } else { l.add(df.newRecordField(f.getName(), df.newRecordVariable())); } // no need to test for datatype: they all are assign
    }
    return df.newRecordPresent(a, l);
  }
//eAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl)
/************************************/
/* Map Interface_name to Class_name */
/************************************/

/* This mapping is used so we can associate a contract to an interface, not only a class.
  In the original paper, there was no interfaces, and we could directly get the contract
  of a method call by looking to the type of the called object. In ABS, this is not true
  anymore, so we use this trick. This means that two classes cannot implement the same
  interface, otherwise we once again don't know what is the contract of the interface.
*/

  public Map<InterfaceDecl, ClassDecl> Model.getMapInterfaceToClass(PrintStream out) {
    Map<InterfaceDecl, ClassDecl> res = new HashMap<InterfaceDecl, ClassDecl>();
    for(Decl decl : this.getDecls()) {
      if(decl instanceof ClassDecl) {
        // 1. Computes recursively the set of all interfaces the class extends
        Set<InterfaceTypeUse> toAdd = new HashSet<InterfaceTypeUse>();
        Set<InterfaceTypeUse> set = new HashSet<InterfaceTypeUse>();
        Set<InterfaceTypeUse> tmp = new HashSet<InterfaceTypeUse>();
        for(InterfaceTypeUse it : ((ClassDecl)decl).getImplementedInterfaceUses()) { toAdd.add(it); }
        while(!toAdd.isEmpty()) {
          Iterator<InterfaceTypeUse> i = toAdd.iterator();
          while(i.hasNext()) {
            InterfaceTypeUse it = i.next();
            if((!set.contains(it)) && (it.getType() instanceof InterfaceType)) {
              set.add(it);
              for(InterfaceTypeUse itin : ((InterfaceType)it.getType()).getDecl().getExtendedInterfaceUses()) { tmp.add(itin); }
            }
          }
          toAdd = tmp;
          tmp = new HashSet<InterfaceTypeUse>();
        }
        // 2. add these interfaces to the map
        for(InterfaceTypeUse it : set) {
          InterfaceDecl d = ((InterfaceType)it.getType()).getDecl();
          if((res.containsKey(d)) && (out != null)) {
            out.println("WARNING: the class \"" + res.get(d).getName() + "\" and \"" + ((ClassDecl)decl).getName() + 
                                 "\" both implement the interface \"" + d.getName() + "\"." +
                                 "This will probably cause an erroneous deadlock analysis");
          } else { res.put(d, (ClassDecl)decl); }
        }
      }
    }
    return res;
  }

/************************************/
/* New Environment Creation         */
/************************************/

/* this method computes the initial environment of the contract inference.
  An environment is a mapping from methods to a behavior specification of
  the form r(\vect{r'}) -> r'', where
    - r is the record of the object executing the method
    - \vect{r'} are the records of the parameters of the method
    - r'' is the record of the result.
  As contract inference wasn't performed yet, the initial mapping does not
  know the structure of these r's, and so put variables in their place.

  Let remark that this initial environment is still necessary to perform
  contract inference.
  Another remark concerns Datatypes. To be able to deal with them like
  objects, we need to give them a record. As a good approximation, we can
  say that all datatypes live in the same cog that is different from those
  used by the objects.
*/

  public Environment Model.environment(Factory df, boolean verbose, PrintStream out) {
    Environment res = new Environment();
    for(CompilationUnit cu : getCompilationUnits()) {
      for (ModuleDecl mo : cu.getModuleDecls()){
        for (Decl d : mo.getDecls()) { if(d instanceof ClassDecl) { ClassDecl c = (ClassDecl)d;
          for (MethodImpl m : c.getMethods()) {
            if(verbose) { out.println("Generating initial environment for the method \"" + c.getName() + "." + m.getMethodSig().getName() + "\""); }
            // 1. Record of "this"
            Record rthis = c.createInstance(df, df.newGroupName(), out);
            // 2. Simple variables for the method parameters
            LinkedList<Record> rparam = new LinkedList<Record>();
            for(ParamDecl p : m.getMethodSig().getParams()){ rparam.add(df.newRecordVariable()); }
            // 3. Simple variable for the return object (or datatype)
            RecordVariable rres = df.newRecordVariable();
            // 4. Finalize
            MethodInterface mi = df.newMethodInterface(rthis, rparam, rres);
            res.putMethod(c.getName(), m.getMethodSig().getName(), mi);
          }
          MethodInterface mi = df.newMethodInterface(c.createInstance(df, df.newGroupName(), out), new LinkedList<Record>(), df.newRecordVariable());
          res.putMethod(c.getName(), "!init!", mi);
        } }
      }
    }
    return res;
  }
/*
  public Environment CompilationUnit.environment(Factory df, boolean verbose) {
    Environment res = new Environment();
    for (ModuleDecl d : getModuleDecls()){ res.add(d.environment(df, verbose)); }
    return res;
  }

  public Environment ModuleDecl.environment(Factory df, boolean verbose) {
    Environment res = new Environment();
    for (Decl d : getDecls()) { if(d instanceof ClassDecl) { res.add(((ClassDecl) d).environment(df, verbose)); } }
    return res;
  }

  public Environment ClassDecl.environment(Factory df, boolean verbose) {
    Environment res = new Environment();
    // 1. Methods
    for (MethodImpl m : getMethods()) { res.add(m.environment(df, this, verbose)); }
    // 2. init
    MethodInterface mi = df.newMethodInterface(this.createInstance(df, df.newGroupName()), new LinkedList<Record>(), df.newRecordVariable());
    res.putMethod(this.getName(), "!init!", mi);
    return res;
  }

  public Environment MethodImpl.environment(Factory df, ClassDecl c, boolean verbose) {
    if(verbose) { out.println("Generating initial environment for the method \"" + c.getName() + "." + this.getMethodSig().getName() + "\""); }
    Environment res = new Environment();

    // 1. Record of "this"
    Record rthis = c.createInstance(df, df.newGroupName());
    // 2. Simple variables for the method parameters
    LinkedList<Record> rparam = new LinkedList<Record>();
    for(ParamDecl p : getMethodSig().getParams()){ rparam.add(df.newRecordVariable()); }
    // 3. Simple variable for the return object (or datatype)
    RecordVariable rres = df.newRecordVariable();
    // 4. Finalize
    MethodInterface mi = df.newMethodInterface(rthis, rparam, rres);
    res.putMethod(c.getName(), this.getMethodSig().getName(), mi);
    return res;
  }*/


/************************************/
/* TYPE INFERENCE                   */
/************************************/

  // ResultInferenceStmt stands for 'deadlock.constraints.constraint.ConstraintGeneration_output'.
  // Suppose that 'ResultInferenceStmt' is class type containing three
  // value (Record r, Contract c, deadlock.constraints.constraint.ConstraintStore U)
  // Suppose that ResultInferenceStmt has method getRecord() setRecord(),
  // getContract setContract addContract accumulateContract() "the )( operator",
  // getdeadlock.constraints.constraint.ConstraintStore, setdeadlock.constraints.constraint.ConstraintStore, adddeadlock.constraints.constraint.Constraint(), adddeadlock.constraints.constraint.ConstraintStore()

  //because of all the methods different from get/set needs the Factory, we perform that operation outside ResultInferenceStmt class.
  // itfToClass is an HashMap that bind InterfaceName to ClassDelc, this is done because in ABS Interface are type and Class are not.



  //////////////////////////////////////////////////////////////////////////////
  // 1. Model, Compilation Units (files), Classes and methods
  //////////////////////////////////////////////////////////////////////////////

  public ResultInference Model.typeInference(String ident, Environment env, Factory df, Map<InterfaceDecl, ClassDecl> intertoclass, PrintStream out) {
    ResultInference res = new ResultInference();
    for (CompilationUnit c : getCompilationUnits()){ res.add(c.typeInference(ident, env, intertoclass, df, out)); }
    assert hasMainBlock() : "Model doesn't have a main-block!";
    ResultInferenceStmt resMain = getMainBlock().typeInference(ident, env, df.newGroupName(), intertoclass, df, null, out);
    res.add(resMain.getConstraint());
    res.setMain(resMain.getContract());
    return res;
  }

  ResultInference CompilationUnit.typeInference(String ident, Environment env, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, PrintStream out) {
    ResultInference res = new ResultInference();
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the file \"" + this.getName() + "\""); nident = " " + ident; }
    for (ModuleDecl d : getModuleDecls()){ res.add(d.typeInference(nident, env, intertoclass, df, out)); }
    return res;
  }

  ResultInference ModuleDecl.typeInference(String ident, Environment env, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, PrintStream out) {
    ResultInference res = new ResultInference();
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the module \"" + this.getName() + "\""); nident = " " + ident; }
    for (Decl d : getDecls()){
      if(d instanceof ClassDecl){ res.add(((ClassDecl) d).typeInference(nident, env, intertoclass, df, out)); }
    }
    return res;
  }

  ResultInference ClassDecl.typeInference(String ident, Environment env, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, PrintStream out) {
    ResultInference res = new ResultInference();
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the class \"" + this.getName() + "\""); nident = " " + ident; }
    // 1. Methods
    for(MethodImpl m : getMethods()){ res.add(m.typeInference(nident, env, intertoclass, df, this, out)); }
    // 2. Init
    MethodInterface mi = env.getMethod(this.getName(), "!init!");
    Record thisRecord = mi.getThis();
    deadlock.constraints.constraint.Constraint c;
    Contract contract;
    if(this.hasInitBlock()) {
      Environment envInitBlock = env.clone();
      GroupName a = ((RecordPresent)thisRecord).getRoot();
      envInitBlock.putVariable("this", thisRecord);
      ResultInferenceStmt resInitBlock = getInitBlock().typeInference(nident, envInitBlock, a, intertoclass, df, this, out);
      contract = resInitBlock.getContract();
      c = resInitBlock.getConstraint();
    } else { contract = df.newContractEmpty(); c = df.newConstraint(out); }
    // 2.2. add the call to run if the method exists.
    if(env.getMethod(this.getName(), "run") != null) {
      ASTNode node = (this.hasInitBlock() ? this.getInitBlock() : this);

      MethodInterface mirun = df.newMethodInterface(thisRecord, new LinkedList<Record>(), df.newRecordVariable());
      c.addSemiEquation(new ASTNodeInformation(node), env.getMethod(this.getName(), "run"), mirun);
      contract.add(df.newContractInvk(node, this.getName(), "run", mirun));
    }

    res.add(c);
    res.add(this.getName(), "!init!", df.newMethodContract(mi, contract));


    if(ident != null) { out.println(ident + "Inference for the class \"" + this.getName() + "\" Finished"); }
    return res;
  }

  ResultInference MethodImpl.typeInference(String ident, Environment env, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the method \"" + cl.getName() + "." + this.getMethodSig().getName() + "\""); nident = " " + ident; }

    // 1. Generate the environment for the contract inference
    Environment envMethod = env.clone();

    // add to the environment the record for [this], the parameters, and [destiny]
    MethodInterface mi = env.getMethod(cl.getName(),this.getMethodSig().getName());
    Record thisRecord = mi.getThis();
    java.util.List<Record> params = mi.getParameters();
    Record result = mi.getResult();
    GroupName a = ((RecordPresent)thisRecord).getRoot(); // by construction, we know that [thisRecord] is RecordPresent

    envMethod.putVariable("this", thisRecord);
    Iterator<Record> it = params.iterator(); 
    for(ParamDecl p : getMethodSig().getParams()){ envMethod.putVariable(p.getName(), it.next()); }
    envMethod.putVariable("!destiny!", result);

    // 2. perform the inference
    ResultInferenceStmt resBlock = getBlock().typeInference(nident, envMethod, a, intertoclass, df, cl, out);
    if(ident != null) { out.println(ident + "Method Block Finished"); }

    // 3. link the inferred contract with the method interface in the environment
    //deadlock.constraints.constraint.Constraint c = resBlock.getConstraint();

    // 4. give back the result.
    ResultInference res = new ResultInference();
    res.add(cl.getName(), this.getMethodSig().getName(), df.newMethodContract(mi, resBlock.getContract()));
    res.add(resBlock.getConstraint());
    return res;
  }


  //////////////////////////////////////////////////////////////////////////////
  // 2. Rules
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // 2.1. Generic inference rules, for nodes that are not yet managed by the inference

  ResultInferenceStmt Decl.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    out.println("WARNING: Contract inference not implemented for Declaration \"" + this.getClass().getName() + "\"");
    return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env);
  }

  ResultInferenceStmt Stmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    out.println("WARNING: Contract inference not implemented for Statment \"" + this.getClass().getName() + "\"");
    return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env);
  }


  ResultInferenceEffExp Exp.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    out.println("WARNING: Contract inference not implemented for Expression \"" + this.getClass().getName() + "\"");
    return new ResultInferenceEffExp(null, df.newRecordVariable(), df.newContractEmpty(), df.newConstraint(out), env);
  }

  ResultInferencePureExp PureExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    out.println("WARNING: Contract inference not implemented for Expression \"" + this.getClass().getName() + "\"");
    return new ResultInferencePureExp(df);
  }

  ResultInferenceEffExp PureExp.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    ResultInferencePureExp resPure = this.typeInferenceAsPure(ident, env, a, intertoclass, df, cl, out);
    return new ResultInferenceEffExp(resPure.getId(), resPure.getRepresentative(), df.newContractEmpty(), df.newConstraint(out), env);
  }

  ResultInferencePureExp Guard.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    out.println("WARNING: Contract inference not implemented for Guard \"" + this.getClass().getName() + "\"");
    return new ResultInferencePureExp(df);
  }

  //////////////////////////////////////////////////////////////////////////////
  // 2.2. Declarations

  ResultInferenceStmt VarDecl.typeInference(String ident, Environment prev, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the VarDecl \"" + this.getName() + "\""); nident = " " + ident; }

    Contract contract;
    deadlock.constraints.constraint.Constraint c;
    Record X;

    Environment env = prev.clone();

    if(hasInitExp()) {
      Exp exp = getInitExp();
      if(exp instanceof PureExp) {
        ResultInferencePureExp resInitExp = ((PureExp)exp).typeInferenceAsPure(nident, prev, a, intertoclass, df, cl, out);
        contract = df.newContractEmpty();
        c = df.newConstraint(out);
        X = resInitExp.getRepresentative();
      } else {
        ResultInferenceEffExp resInitExp = ((EffExp)exp).typeInference(nident, prev, a, intertoclass, df, cl, out);
        contract = resInitExp.getContract();
        c = resInitExp.getConstraint();
        X = resInitExp.getRecord();
      }
    } else {
      contract = df.newContractEmpty();
      c = df.newConstraint(out);
      X = df.newRecordVariable();
    }
    env.putVariable(this.getName(), X);

    return new ResultInferenceStmt(this.getName(), contract, c, env);
  }


  //////////////////////////////////////////////////////////////////////////////
  // 2.3. Statments

  ResultInferenceStmt AssignStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the AssignStmt"); nident = " " + ident; }

    String name = getVar().getName();

    Contract contract;
    deadlock.constraints.constraint.Constraint c;
    Record X;

    Exp exp = this.getValue();
    if(exp instanceof PureExp) {
      ResultInferencePureExp resValue = ((PureExp)exp).typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
      contract = df.newContractEmpty();
      c = df.newConstraint(out);
      X = resValue.getRepresentative(env.getVariable(name));
    } else {
      ResultInferenceEffExp resValue = ((EffExp)exp).typeInference(nident, env, a, intertoclass, df, cl, out);
      contract = resValue.getContract();
      c = resValue.getConstraint();
      X = resValue.getRecord();
    }

    if(ident != null) { out.println(ident + "AssignStmt Sub-Expression Finished"); }

    if(env.isField(name)) { c.addEquation(new ASTNodeInformation(this), env.getVariable(name), X); }
    else { env.putVariable(name, X); } // implementation of the new environment update
            
    return new ResultInferenceStmt(name, contract, c, env);
  }


  ResultInferenceStmt AwaitStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl clthis, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the AwaitStmt "); nident = " " + ident; }

    Contract contract;
    deadlock.constraints.constraint.Constraint c = df.newConstraint(out);
    GroupName aprime = df.newGroupName();

    // 1. First look if there is some annotation defined
    Iterator<Annotation> it = this.getAnnotations().iterator();
    if(it.hasNext()) {
      PureExp dep = it.next().getValue();
      ResultInferencePureExp resAnn = dep.typeInferenceAsPure(nident, env, a, intertoclass, df, clthis, out);
      contract = df.newContractAwait(this, aprime, a);

      if(ident != null) { out.println(ident + "AwaitStmt Annotation Finished"); }
      ClassDecl cl; Type t = dep.getType();
      if(t.isInterfaceType()) { cl = intertoclass.get(((InterfaceType)t).getDecl()); }
      else { cl = clthis; }
     
      Record r = null;
      if(cl == null) {
        out.println(ident + "WARNING: in await, there is no class implementing the \"" + ((InterfaceType)t).getDecl().getName() + "\" interface");
        r = new RecordVariable(new deadlock.constraints.term.Variable(),false);
      } else { r = cl.createInstance(df, aprime, out); }
      c.addEquation(new ASTNodeInformation(this), resAnn.getRepresentative(), r);

      return new ResultInferenceStmt(null, contract, c, env);
    } else {
      ResultInferencePureExp resGuard = getGuard().typeInference(nident, env, a, intertoclass, df, clthis, out);
      if(ident != null) { out.println(ident + "AwaitStmt Sub-Expression Finished"); }
      contract = df.newContractAwait(this, a,aprime);
      c.addEquation(new ASTNodeInformation(this), df.newRecordFuture(aprime, df.newRecordVariable()), resGuard.getRepresentative());

      return new ResultInferenceStmt(resGuard.getId(), contract, c, env);
    }

  }

  ResultInferenceStmt SkipStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env);
  }

  ResultInferenceStmt SuspendStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env);
  }

  ResultInferenceStmt DurationStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env);
  }


  ResultInferenceStmt ReturnStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the ReturnStmt "); nident = " " + ident; }

    ResultInferenceEffExp resRetExp = getRetExp().typeInference(nident, env, a, intertoclass, df, cl, out);
    if(ident != null) { out.println(ident + "ReturnStmt Sub-Expression Finished"); }

    Contract contract = resRetExp.getContract();
    deadlock.constraints.constraint.Constraint c = resRetExp.getConstraint();
    c.addEquation(new ASTNodeInformation(this), env.getVariable("!destiny!"), resRetExp.getRecord());

    return new ResultInferenceStmt(resRetExp.getId(), contract, c, env); // we need to forward the id, in case there is a get in the expression
  }


  ResultInferenceStmt ExpressionStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the ExpressionStmt "); nident = " " + ident; }

    // 1. is called the inference on the value expression of assignment
    ResultInferenceEffExp resExp = getExp().typeInference(nident, env, a, intertoclass, df, cl, out);
    if(ident != null) { out.println(ident + "ExpressionStmt Sub-Expression Finished"); }
    return new ResultInferenceStmt(resExp.getId(), resExp.getContract(), resExp.getConstraint(), env);
  }


  ResultInferenceStmt AssertStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the AssertStmt "); nident = " " + ident; }
    return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env);
  }


  ResultInferenceStmt VarDeclStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the VarDeclStmt "); nident = " " + ident; }
    ResultInferenceStmt resVarDecl = this.getVarDecl().typeInference(nident, env, a, intertoclass, df, cl, out);
    if(ident != null) { out.println(ident + "VarDeclStmt Sub-Expression Finished"); }
    return resVarDecl;
  }


  ResultInferenceStmt IfStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract inference of a Conditional Expression"); nident = " " + ident; }
    // as the condition is a pure expression, it doesn't have contract or constraints
    ResultInferenceStmt resThen = this.getThen().typeInference(nident, env.clone(), a, intertoclass, df, cl, out);
    
    Contract contract;
    deadlock.constraints.constraint.Constraint c = resThen.getConstraint();

    if(this.hasElse()) {
      ResultInferenceStmt resElse = this.getElse().typeInference(nident, env.clone(), a, intertoclass, df, cl, out);
      c.add(resElse.getConstraint());
      c.add(resThen.getEnvironment().unify(df, new ASTNodeInformation(this), resElse.getEnvironment())); // ensure that the two branches return the same environment
      contract = df.newContractUnion(this, resThen.getContract(), resElse.getContract());
    } else { contract = df.newContractUnion(this, resThen.getContract(), df.newContractEmpty()); }
    if(ident != null) { out.println(ident + "IfStmt Sub-Expression Finished"); }
    env.updateValues(resThen.getEnvironment());
    return new ResultInferenceStmt(resThen.getId(), contract, c, env);
  }

  ResultInferenceStmt WhileStmt.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the While (Approximated with one iteration) "); nident = " " + ident; }
    ResultInferenceStmt resStmt = getBody().typeInference(nident, env, a, intertoclass, df, cl, out);
    if(ident != null) { out.println(ident + "While Sub-Statments Finished"); }
    return resStmt;
  }

  ResultInferenceStmt Block.typeInference(String ident, Environment envInit, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the Block "); nident = " " + ident; }

    // accumulate constracts and deadlock.constraints.constraint.Constraints in the resulting output
    ResultInferenceStmt resStmt = null;
    deadlock.constraints.constraint.Constraint c = df.newConstraint(out);
    Contract contract = df.newContractEmpty();
    Environment env = envInit;
    String prev_id = null;

    for (Stmt s : getStmts()) {
      resStmt = s.typeInference(nident, env, a, intertoclass, df, cl, out);
      c.add(resStmt.getConstraint());
      env = resStmt.getEnvironment();

      //if(prev_id != null) out.println("    previous id = " + prev_id);

      if((resStmt.getId() != null) && (prev_id != null) && (resStmt.getId().equals(prev_id))) {
        contract.fusion(resStmt.getContract());
      } else{
        prev_id = resStmt.getId();
        contract.add(resStmt.getContract());
      }
      // for debugging
      //if(resStmt.getId() != null)   out.println("    current id = " + resStmt.getId());
    }
    if(ident != null) { out.println(ident + "Block Sub-Statments Finished"); }
    
    // finish
    if(resStmt == null) { return new ResultInferenceStmt(null, df.newContractEmpty(), df.newConstraint(out), env); }
    else { return new ResultInferenceStmt(resStmt.getId(), contract, c, env); }
  }




  //////////////////////////////////////////////////////////////////////////////
  // 2.4. Expressions

  // 2.4.1. Pure Expressions
  
  ResultInferencePureExp NullExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    if(ident != null) { out.println(ident + "Contract inference of 'null' PureExp "); }
    return new ResultInferencePureExp(df, null, df.newRecordVariableFanthom());
  }


  ResultInferencePureExp ThisExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    if(ident != null) { out.println(ident + "Contract inference of 'this' PureExp "); }
    return new ResultInferencePureExp(df, "this", env.getVariable("this"));
  }

  ResultInferencePureExp VarOrFieldUse.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    if(ident != null) { out.println(ident + "Contract Inference for the VarOrFieldUse \"" + this.getName() + "\" (considered as a"
        + ((env.getVariable(this.getName()) instanceof RecordVariable) && (((RecordVariable)env.getVariable(this.getName())).isDataType()) ? " datatype)" : "n object)")); }
    return new ResultInferencePureExp(df, this.getName(), env.getVariable(this.getName()));
  }


  ResultInferencePureExp LiteralExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    if(ident != null) { out.println(ident + "Contract inference of a Literal "); }
    return new ResultInferencePureExp(df, null, df.getDataType());
  }

  ResultInferencePureExp DataConstructorExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) { // DATATYPES
    String nident = null;
    if(ident != null) { out.println(ident + "Contract inference of the Data type Constructor \"" + this.getConstructor() + "\""); nident = " " + ident; }
    ResultInferencePureExp res = new ResultInferencePureExp(df);
    for(PureExp param : getParams()) { res.add(param.typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out)); }
    return res;
  }

  ResultInferencePureExp LetExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract inference of a Let Expression "); nident = " " + ident; }
    ResultInferencePureExp res = getVal().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
    Record X = res.getRepresentative();
    Environment envExp = env.clone();
    envExp.putVariable(this.getVar().getName(), X);
    res.add(getExp().typeInferenceAsPure(nident, envExp, a, intertoclass, df, cl, out));
    /*
    Record X = resVal.getRecord();
    Environment envExp = env.clone();
    envExp.putVariable(this.getVar().getName(), X);
    ResultInferenceStmt resExp = getExp().typeInference(nident, envExp, a, intertoclass, df, cl);
    
    Contract contract = resVal.getContract();
    contract.add(resExp.getContract());
    deadlock.constraints.constraint.Constraint c = resVal.getConstraint();
    c.add(resExp.getConstraint());*/

    return res;
  }

  ResultInferencePureExp FnApp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) { // DATATYPES
    String nident = null;
    if(ident != null) { out.println(ident + "Contract inference of a Function Application "); nident = " " + ident; }
    ResultInferencePureExp res = new ResultInferencePureExp(df);
    for(PureExp param : getParams()) { res.add(param.typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out)); }
    return res;
  }

  ResultInferencePureExp IfExp.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract inference of an Exp Conditional Expression"); nident = " " + ident; }
    // as the condition is a pure expression, its contract and constraint are empty
    ResultInferencePureExp res = this.getThenExp().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
    res.add(this.getElseExp().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out));
    return res;
  }

  ResultInferencePureExp Unary.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) { // DATATYPES
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for an Unary Pure Expression -> no contract and no record "); nident = " " + ident; }
    return this.getOperand().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
  }

  ResultInferencePureExp Binary.typeInferenceAsPure(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) { // DATATYPES
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for an Unary Pure Expression -> no contract and no record "); nident = " " + ident; }
    ResultInferencePureExp res = this.getLeft().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
    res.add(this.getRight().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out));
    return res;
  }


// TODO:
//CaseExp  : PureExp ::= Expr:PureExp Branch:CaseBranch* ;
//CaseBranch ::= Left:Pattern Right:PureExp ;
//abstract Pattern ;
//PatternVarUse:    Pattern ::= <Name>;
//PatternVar:			Pattern ::= Var:PatternVarDecl;
//ConstructorPattern: Pattern ::= <Constructor> Param:Pattern*;
//LiteralPattern:		Pattern ::= Literal:LiteralExp;
//UnderscorePattern:	Pattern;



  // 2.4.2. Expressions with side effects.

  ResultInferenceEffExp NewExp.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl clthis, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the NewExp "); nident = " " + ident; }

    // 1. Create the record for the new object, and collect contract and constraints from arguments
    ClassDecl cl = (ClassDecl)(lookup(new KindedName(Kind.CLASS,getClassName())));
    LinkedList<RecordField> fields = new LinkedList<RecordField>();
    int i = 0;
    Contract contract = df.newContractEmpty();
    deadlock.constraints.constraint.Constraint c = df.newConstraint(out);
    Environment envFields = env.clone();
    // 1.1. Params
    ResultInferencePureExp resParam;
    for (PureExp p : getParams()){
      resParam = p.typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
      fields.add(df.newRecordField(cl.getParam(i).getName(), resParam.getRepresentative()));
      envFields.putVariable(cl.getParam(i).getName(), resParam.getRepresentative());
      i++;
    }
    // 1.2. Fields
    for(FieldDecl f : cl.getFields()) {
      if(f.hasInitExp()) {
        resParam = f.getInitExp().typeInferenceAsPure(nident, envFields, a, intertoclass, df, cl, out);
        fields.add(df.newRecordField(f.getName(), resParam.getRepresentative()));
      } else { fields.add(df.newRecordField(f.getName(), df.newRecordVariable())); }
    }
    // 1.3. Group Name
    GroupName aprime; // depends if the new object is in the same cog or not
    if(this.hasLocal()) { aprime = a; }
    else { aprime = df.newGroupName(); }
    Record r = df.newRecordPresent(aprime,fields);

    // 1.4. Calling the init of r
    MethodInterface miinit = df.newMethodInterface(r, new LinkedList<Record>(), df.newRecordVariable());
    c.addSemiEquation(new ASTNodeInformation(this), env.getMethod(cl.getName(), "!init!"), miinit);
    contract.add(df.newContractInvk(this, cl.getName(), "!init!", miinit));

    return new ResultInferenceEffExp(null, r, contract, c, env);
  }



  ResultInferenceEffExp Call.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl clthis, PrintStream out) {
    String nident = null;
    if(ident != null) {
      out.println(ident + "Contract Inference for a " + ((this instanceof SyncCall)?"Synchronous":"Asynchronous") + "  method Call");
      nident = " " + ident; }

    // 1. Get the method interface
    Type t = getCallee().getType();
    final ClassDecl cl;
    if(t.isInterfaceType()) { cl = intertoclass.get(((InterfaceType)t).getDecl()); }
    else { cl = clthis; }

    if(cl != null) { // there is an implementation for the given interface
      // 2. Collect contracts and deadlock.constraints.constraint.Constraints from the call
      ResultInferencePureExp resCallee = getCallee().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
      Contract contract = df.newContractEmpty();
      deadlock.constraints.constraint.Constraint c = df.newConstraint(out);
      Record callee = resCallee.getRepresentative();
    
      LinkedList<Record> s = new LinkedList<Record>();
      ResultInferencePureExp resParam;
      for (PureExp p : getParams()){
        resParam = p.typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
        s.add(resParam.getRepresentative());
      }

      // 3. Construct the record for the return value
      Record Y = df.newRecordVariable();

      // 4. pack up the result
      MethodInterface mi = df.newMethodInterface(callee, s, Y);
      c.addSemiEquation(new ASTNodeInformation(this), env.getMethod(cl.getName(), getMethod()), mi);

      Record r;
      if(this instanceof SyncCall) {
        r = Y;
        contract.add(df.newContractSyncInvk(this, cl.getName(), getMethod(), mi));
      } else {
        contract.add(df.newContractInvk(this, cl.getName(), getMethod(), mi));

        GroupName aprime = df.newGroupName();
        Record calleeShape = cl.createInstance(df, aprime, out);
        c.addEquation(new ASTNodeInformation(this), callee, calleeShape);
        r = df.newRecordFuture(aprime,Y);
      }
      return new ResultInferenceEffExp(null, r, contract, c, env);
    } else { // there is no implementation for the interface -> we suppose that the contract of the method is 0
      out.println(ident + "WARNING: in call, there is no class implementing the \"" + ((InterfaceType)t).getDecl().getName() + "\" interface");
      boolean datatype = true;
      if(getMethodSig().getReturnType().getType() instanceof InterfaceType) datatype = false;
      return new ResultInferenceEffExp(null, new RecordVariable(new deadlock.constraints.term.Variable(),datatype), new Contract(), df.newConstraint(out), env);
    }
  }
   


  ResultInferenceEffExp GetExp.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for a GetExp "); nident = " " + ident; }

    // 1. first is calculate the inference of the expression 'e' of 'e.get'
    ResultInferencePureExp resPureExp = getPureExp().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
    if(ident != null) { out.println(ident + "GetExp Sub-Expression Finished"); }

    Contract contract = df.newContractEmpty();
    deadlock.constraints.constraint.Constraint c = df.newConstraint(out);

    // 2. record for the result
    GroupName aprime = df.newGroupName();
    Record X = df.newRecordVariable();
    c.addEquation(new ASTNodeInformation(this), df.newRecordFuture(aprime, X), resPureExp.getRepresentative());

    // pack up the result
    contract.fusion(df.newContractGet(this, a, aprime));
    return new ResultInferenceEffExp(resPureExp.getId(), X, contract, c, env);
  }



  //////////////////////////////////////////////////////////////////////////////
  // 2.5. Guards

  ResultInferencePureExp ClaimGuard.typeInference(String ident, Environment env, GroupName a, Map<InterfaceDecl, ClassDecl> intertoclass, Factory df, ClassDecl cl, PrintStream out) {
    String nident = null;
    if(ident != null) { out.println(ident + "Contract Inference for the ClaimGuard "); nident = " " + ident; }
    return getVar().typeInferenceAsPure(nident, env, a, intertoclass, df, cl, out);
  }
 

  // TODO; AndGuard, ExpGuard, DurationGuard


// END TYPE INFERENCE



    
//TYPE INFERENCE OF MAIN! Done only after right creation of CCT
    /*
    
    //only for Main.main
    //TI-ModuleDecl
  public ResultInference ModuleDecl.typeInferenceMain(Environment env, Map<Interface, ClassDecl> intertoclass, Factory df) {
    out.println("Level 2: Contract Inference for the module \"" + this.getName() + "\"");

    ResultInference res = new ResultInference();

    //1. Calculate the ModuleDecl Inference by collecting together the ClassDecls Inferences
    for (Decl d : getDecls()){
      if(d instanceof ClassDecl){
        res.add(((ClassDecl) d).typeInference(env, itfToClass, df, semi));
      }
    }
        
    //2. If the modules has a Main, then we put also a Main.main method with this contract
    if (hasBlock()) {
      GroupName amain = df.newGroupName();             //Variable name of this into the Main
      ResultInferenceStmt resBlock = getBlock().typeInference(env, amain, itfToClass, df, semi);
      MethodInterface mi = df.newMethodInterface(df.newRecordVariable(), new LinkedList<Record>(), df.newRecordVariable());
      res.add("!Main!", "!main!", df.newMethodContract(mi, resBlock.getContract())); //I invent this "method name" Main.main to recognize the contract of main
      res.add(resBlock.getConstraint());
    }
    return res;
  }

    
    //only for Main.main
    //TI-CompilationUnit
    public ResultInference CompilationUnit.typeInferenceMain(Environment g, HashMap<String, ClassDecl> itfToClass, Factory df, boolean semi) {

        out.println("Level 1: Contract Inference for the file \"" + this.getName() + "\"");


        ResultInference res = new ResultInference();

        //1. Calculate the CompilationUnit Inference by collecting together the ModuleDecls Inferences
        for (ModuleDecl d : getModuleDecls()){
            //Like in Environment generation I avoid ModuleDecl starting with ABS, that are automatically generated and are not part of our analisys
            //if(!(d.getName()).startsWith("ABS")){
                res.add(d.typeInferenceMain(g, itfToClass, df, semi));
            //}
        }
        return res;
    }


    //Only for Main.main
    //TI-Model
    public ResultInference Model.typeInferenceMain(Environment g, Factory df, boolean semi) {

        ResultInference res = new ResultInference();
        HashMap<String, ClassDecl> intertoclass = new HashMap<String, ClassDecl>();//interfToClass();

        //due to a compilationUnit not part of our analysis we skipped the "abslang.abs" unit
        //1. Calculate the model Inference by collecting together the CompilationUnits Inferences
        for (CompilationUnit c : getCompilationUnits()){
            if(c.getName().endsWith("abslang.abs")) {
                out.println("  Inference skipped");
            } else {
                res.add(c.typeInferenceMain(g, intertoclass, df, semi));
            }
        }
        return res;
    }
    
    //I want the environment outside to reintroduce it for a new inference cycle
    public Environment Model.getEnvironment(Factory df){
        return this.environment(df);
    }
*/
//END NEW CODE
  //END TYPEINFERENCE


/*    //TI-Field
    public ResultInferenceStmt FieldUse.typeInference(Environment g, Term a, HashMap<String, ClassDecl> itfToClass, Factory df, boolean semi) {

        out.println("Level 5: Contract Inference for the FieldUse ");

        ClassDecl classOfThis;

        // 1. crazy way to adjust and write more elegant to find the ClassDecl of this

        if((this.getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent();
        else if((this.getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent();
        else if((this.getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else if( (this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else if((this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getClass().getName()).endsWith("ClassDecl")) classOfThis = (ClassDecl) this.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent();
        else classOfThis = null;





        ResultInferenceStmt res = new ResultInferenceStmt();
        // 2. here it is created a frash this with fresh variable inside field
        Term aprime = df.freshTermVariable();
        LinkedList<Term> fields = new LinkedList<Term>();

        for(FieldDecl f : classOfThis.getFields()){
            Term Y = df.freshTermVariable();
            fields.add(df.newRecordField(f.getName(), Y));
            // 3. the right field f extract in this.f assign the record to the rule T-Field
            if((f.getName()).equals(this.getName())) {res.setRecord(Y);}
        }


        //Need to write deadlock.deadlock.constraints.constraint.Constraints.deadlock.constraints.constraint.Constraint.deadlock.constraints.constraint.Constraint instead of deadlock.constraints.constraint.Constraint because of ABS compiler.

        // 4. deadlock.constraints.constraint.Constraint returned is an equation between real this of the environment and the new fresh one
        semiUnification.deadlock.constraints.constraint.Constraint.deadlock.constraints.constraint.Constraint constr = df.newConstraint();
        constr.addEquation(df.newRecordPresent(aprime, fields), g.getVariable("this"));
        res.setConstraint(constr);
        res.setEnvironment(g);
        
        return res;
    }*/

    
}

// Local unification.Variables:
// mode: java
// End:
