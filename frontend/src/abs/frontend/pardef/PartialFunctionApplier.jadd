import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import abs.frontend.pardef.*;

aspect PartialFunctionApplier {

    public void Model.flattenPartialFunctions() {
        for (ModuleDecl moduleDecl : getModuleDecls()) {
            moduleDecl.flattenPartialFunctions();
        }

        // TODO use check results
        if(!TreeUtil.isAbsent(this, ParFnApp.class)
            || !TreeUtil.isAbsent(this, PartialFunctionDecl.class)
            || !TreeUtil.isAbsent(this, PartialFunctionDef.class)) {
            throw new RuntimeException("Did not remove all partial function nodes");
        }
    }

    void ModuleDecl.flattenPartialFunctions() {
        Map<String, PartialFunctionWrapper> functions = collectPartialFunctions();
        if(functions.isEmpty()) {
            return;
        }

        // check for cycles
        for (PartialFunctionWrapper wrapper : functions.values()) {
            PartialFunctionDecl function = wrapper.getFunction();
            function.checkCycles(functions);
        }

        // declare annotation type
        String annotationTypeName = getName() + "Expansion";
        TypeUse intTypeUse = new UnresolvedTypeUse("Int", new List<Annotation>());
        addDecl(new TypeSynDecl(annotationTypeName, new List<Annotation>(), intTypeUse));
        TypeUse annotationType = new UnresolvedTypeUse(annotationTypeName, new List<Annotation>());
        int expansionCount = 0;
        int oldExpansionCount = -1;
        while (oldExpansionCount != expansionCount && !TreeUtil.isAbsent(this, ParFnApp.class)) {
            oldExpansionCount = expansionCount;
            for (ParFnApp fnApp : TreeUtil.collectChildren(this, ParFnApp.class)) {
                if (TreeUtil.findParent(fnApp, PartialFunctionDecl.class) != null) {
                    // ignore ParFnApp within pardef that has not been expanded yet
                    continue;
                }
                PartialFunctionWrapper function = functions.get(fnApp.getName());
                if (function == null) {
                    // TODO handle errors
                    throw new RuntimeException("No such function: " + fnApp.getName());
                }

                PureExp expansionCountLiteral = new IntLiteral(Integer.toString(expansionCount++));
                Annotation annotation = new TypedAnnotation(expansionCountLiteral, annotationType.treeCopy());
                FunctionDecl appliedFunction = function.apply(fnApp, annotation);
                addDecl(appliedFunction);
                FnApp appliedFunctionCall = fnApp.apply(appliedFunction);
                TreeUtil.replace(fnApp, appliedFunctionCall);
                Stmt stmt = TreeUtil.findParent(appliedFunctionCall, Stmt.class);
                if (stmt != null) {
                    // TODO handle missing parent statement (e.g. in function definitions)
                    // TODO merge with existing annotation of same type
                    stmt.addAnnotation(annotation.treeCopy());
                }
            }
        }

        for (PartialFunctionWrapper wrapper : functions.values()) {
            wrapper.removeFromParent();
        }
    }

    private Map<String, PartialFunctionWrapper> ModuleDecl.collectPartialFunctions() {
        Map<String, PartialFunctionWrapper> result = new HashMap<>(32);

        for (Decl decl : getDecls()) {
            if (decl instanceof PartialFunctionDecl) {
                PartialFunctionDecl functionDecl = (PartialFunctionDecl) decl;
                result.put(functionDecl.getName(), new PartialFunctionWrapper(functionDecl));
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionWrapper> functions) {
        checkCycles(functions, new HashSet<String>());
    }

    private void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionWrapper> functions, Set<String> visited) {
        if (!visited.add(getName())) {
            throw new RuntimeException("Cycle detected");
        }
        for (ParFnApp parFnApp : TreeUtil.collectChildren(this, ParFnApp.class)) {
            PartialFunctionWrapper called = functions.get(parFnApp.getName());
            if (called == null) {
                // will be caught somewhere else
                continue;
            }
            PartialFunctionDecl calledFunction = called.getFunction();
            calledFunction.checkCycles(functions, new HashSet<>(visited));
        }
    }

    public FunctionDecl PartialFunctionDecl.apply(ParFnApp fnApp, Annotation annotation, int applyCount) {
        FunctionDecl decl = new FunctionDecl();
        apply(decl, fnApp, annotation, applyCount);
        return decl;
    }

    public FunctionDecl ParametricPartialFunctionDecl.apply(ParFnApp fnApp, Annotation annotation, int applyCount) {
        ParametricFunctionDecl decl = new ParametricFunctionDecl();
        // TODO do this differently
        apply(decl, fnApp, annotation, applyCount);
        decl.setTypeParameterList(getTypeParameters().treeCopy());
        return decl;
    }

    protected void PartialFunctionDecl.apply(FunctionDecl applied, ParFnApp fnApp, Annotation annotation, int applyCount) {
        int funcParamCount = getNumFuncParam();
        if(funcParamCount != fnApp.getNumFuncParam()) {
            // TODO handle errors
            throw new RuntimeException("Wrong number of arguments");
        }

        String appliedName = appliedName(applyCount);
        applied.setName(appliedName);
        applied.setAnnotationList(getAnnotations().treeCopy().add(annotation));
        applied.setTypeUse(getTypeUse().treeCopy());
        applied.setParamList(getParams().treeCopy());

        Map<String, String> functions = new HashMap<>(funcParamCount * 2);
        for (int i = 0; i < funcParamCount; ++i) {
            String funcParam = getFuncParam(i).getName();
            String actualParam = fnApp.getFuncParam(i).getName();
            functions.put(funcParam, actualParam);
        }
        // enable recursion by replacing partial function name with applied name
        functions.put(getName(), appliedName);
        applied.setFunctionDef(getPartialFunctionDef().apply(functions));
    }

    protected String PartialFunctionDecl.appliedName(int applyCount) {
        // avoid collisions by capitalizing the applied function name
        return StringUtils.capitalize(getName()) + "_" + applyCount;
    }

    public FunctionDef PartialFunctionDef.apply(Map<String, String> functions) {
        PureExp expression = getPureExp().treeCopy();
        for (FnApp innerCall : TreeUtil.collectChildren(expression, FnApp.class)) {
            String newName = functions.get(innerCall.getName());
            if (newName != null) {
                innerCall.setName(newName);
            }
        }

        return new ExpFunctionDef(expression);
    }

    public FnApp ParFnApp.apply(FunctionDecl function) {
        return new FnApp(function.getName(), getParamList().treeCopy());
    }
}