import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import abs.frontend.pardef.*;

aspect PartialFunctionApplier {

    public void Model.flattenPartialFunctions() {
        for (ModuleDecl moduleDecl : getModuleDecls()) {
            moduleDecl.flattenPartialFunctions();
        }

        // TODO use check results
        if(!checkAbsence(ParFnApp.class)
            || !checkAbsence(PartialFunctionDecl.class)
            || !checkAbsence(PartialFunctionDef.class)) {
            throw new RuntimeException("Did not remove all partial function nodes");
        }
    }

    private <T extends ASTNode<?>> boolean Model.checkAbsence(Class<T> type) {
        return TreeUtil.collectChildren(this, type).isEmpty();
    }

    void ModuleDecl.flattenPartialFunctions() {
        Map<String, PartialFunctionWrapper> functions = collectPartialFunctions();
        if(functions.isEmpty()) {
            return;
        }

        // declare annotation type
        String annotationTypeName = getName() + "Expansion";
        TypeUse intTypeUse = new UnresolvedTypeUse("Int", new List<Annotation>());
        addDecl(new TypeSynDecl(annotationTypeName, new List<Annotation>(), intTypeUse));
        TypeUse annotationType = new UnresolvedTypeUse(annotationTypeName, new List<Annotation>());
        int expansionCount = 0;
        for (ParFnApp fnApp : TreeUtil.collectChildren(this, ParFnApp.class)) {
            PartialFunctionWrapper function = functions.get(fnApp.getName());
            if (function == null) {
                // TODO handle errors
                throw new RuntimeException("No such function: " + fnApp.getName());
            }

            PureExp expansionCountLiteral = new IntLiteral(Integer.toString(expansionCount++));
            Annotation annotation = new TypedAnnotation(expansionCountLiteral, annotationType.treeCopy());
            FunctionDecl appliedFunction = function.apply(fnApp, annotation);
            addDecl(appliedFunction);
            FnApp appliedFunctionCall = fnApp.apply(appliedFunction);
            TreeUtil.replace(fnApp, appliedFunctionCall);
            Stmt stmt = TreeUtil.findParent(appliedFunctionCall, Stmt.class);
            if (stmt != null) {
                // TODO handle missing parent statement (e.g. in function definitions)
                // TODO merge with existing annotation of same type
                stmt.addAnnotation(annotation.treeCopy());
            }
        }

        for (PartialFunctionWrapper wrapper : functions.values()) {
            wrapper.removeFromParent();
        }
    }

    private Map<String, PartialFunctionWrapper> ModuleDecl.collectPartialFunctions() {
        Map<String, PartialFunctionWrapper> result = new HashMap<>(32);

        for (Decl decl : getDecls()) {
            if (decl instanceof PartialFunctionDecl) {
                PartialFunctionDecl functionDecl = (PartialFunctionDecl) decl;
                result.put(functionDecl.getName(), new PartialFunctionWrapper(functionDecl));
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public FunctionDecl PartialFunctionDecl.apply(ParFnApp fnApp, Annotation annotation, int applyCount) {
        FunctionDecl decl = new FunctionDecl();
        apply(decl, fnApp, annotation, applyCount);
        return decl;
    }

    public FunctionDecl ParametricPartialFunctionDecl.apply(ParFnApp fnApp, Annotation annotation, int applyCount) {
        ParametricFunctionDecl decl = new ParametricFunctionDecl();
        // TODO do this differently
        apply(decl, fnApp, annotation, applyCount);
        decl.setTypeParameterList(getTypeParameters().treeCopy());
        return decl;
    }

    protected void PartialFunctionDecl.apply(FunctionDecl applied, ParFnApp fnApp, Annotation annotation, int applyCount) {
        int funcParamCount = getNumFuncParam();
        if(funcParamCount != fnApp.getNumFuncParam()) {
            // TODO handle errors
            throw new RuntimeException("Wrong number of arguments");
        }

        String appliedName = appliedName(applyCount);
        applied.setName(appliedName);
        applied.setAnnotationList(getAnnotations().treeCopy().add(annotation));
        applied.setTypeUse(getTypeUse().treeCopy());
        applied.setParamList(getParams().treeCopy());

        Map<String, String> functions = new HashMap<>(funcParamCount * 2);
        for (int i = 0; i < funcParamCount; ++i) {
            String funcParam = getFuncParam(i).getName();
            String actualParam = fnApp.getFuncParam(i).getName();
            functions.put(funcParam, actualParam);
        }
        // enable recursion by replacing partial function name with applied name
        functions.put(getName(), appliedName);
        applied.setFunctionDef(getPartialFunctionDef().apply(functions));
    }

    protected String PartialFunctionDecl.appliedName(int applyCount) {
        // avoid collisions by capitalizing the applied function name
        return StringUtils.capitalize(getName()) + "_" + applyCount;
    }

    public FunctionDef PartialFunctionDef.apply(Map<String, String> functions) {
        PureExp expression = getPureExp().treeCopy();
        for (FnApp innerCall : TreeUtil.collectChildren(expression, FnApp.class)) {
            String newName = functions.get(innerCall.getName());
            if (newName != null) {
                innerCall.setName(newName);
            }
        }

        return new ExpFunctionDef(expression);
    }

    public FnApp ParFnApp.apply(FunctionDecl function) {
        return new FnApp(function.getName(), getParamList().treeCopy());
    }
}