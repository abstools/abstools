import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import abs.frontend.pardef.*;

aspect PartialFunctionApplier {

    public void Model.flattenPartialFunctions() {
        for (ModuleDecl moduleDecl : getModuleDecls()) {
            moduleDecl.flattenPartialFunctions();
        }

        // TODO use check results
        if(!TreeUtil.isAbsent(this, ParFnApp.class)
            || !TreeUtil.isAbsent(this, PartialFunctionDecl.class)
            || !TreeUtil.isAbsent(this, PartialFunctionDef.class)) {
            throw new RuntimeException("Did not remove all partial function nodes");
        }
    }

    void ModuleDecl.flattenPartialFunctions() {
        Map<String, PartialFunctionDecl> functions = collectPartialFunctions();
        if(functions.isEmpty()) {
            return;
        }

        // check for cycles
        for (PartialFunctionDecl function : functions.values()) {
            function.checkCycles(functions);
        }

        Map<String, ExpandedWrapper> expanded = new HashMap<>(functions.size() * 4);

        expandChildParFnApps(this, functions, expanded, 0);

        for (PartialFunctionDecl function : functions.values()) {
            TreeUtil.removeFromParent(function);
        }
    }

    private void ModuleDecl.expandChildParFnApps(ASTNode<?> node,
        Map<String, PartialFunctionDecl> functions,
        Map<String, ExpandedWrapper> expanded,
        int expansionCount) {
        for (ParFnApp fnApp : TreeUtil.collectChildren(node, ParFnApp.class)) {
            if (TreeUtil.findParent(fnApp, PartialFunctionDecl.class) != null) {
                // ignore ParFnApp within pardef that has not been expanded yet
                continue;
            }
            PartialFunctionDecl function = functions.get(fnApp.getName());
            if (function == null) {
                // TODO handle errors
                throw new RuntimeException("No such partially defined function: " + fnApp.getName());
            }

            String expandedName = function.expandedName(fnApp);
            ExpandedWrapper expandedWrapper;
            expandedWrapper = expanded.get(expandedName);

            if (expandedWrapper == null) {
                FunctionDecl expandedFunction = function.expand(fnApp);
                addDecl(expandedFunction);
                AnnotationUtil.annotateExpansion(expandedFunction, expansionCount);
                expandedWrapper = new ExpandedWrapper(expandedFunction, expansionCount);
                expanded.put(expandedName, expandedWrapper);
                ++expansionCount;

                expandChildParFnApps(expandedFunction, functions, expanded, expansionCount);
            }

            FnApp expandedFunctionCall = fnApp.apply(expandedWrapper.getExpanded());
            TreeUtil.replace(fnApp, expandedFunctionCall);
            AnnotationUtil.annotateCall(expandedFunctionCall, expandedWrapper.getExpansionId());
        }
    }

    private Map<String, PartialFunctionDecl> ModuleDecl.collectPartialFunctions() {
        Map<String, PartialFunctionDecl> result = new HashMap<>(32);

        for (Decl decl : getDecls()) {
            if (decl instanceof PartialFunctionDecl) {
                PartialFunctionDecl functionDecl = (PartialFunctionDecl) decl;
                result.put(functionDecl.getName(), functionDecl);
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionDecl> functions) {
        checkCycles(functions, new HashSet<String>());
    }

    private void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionDecl> functions, Set<String> visited) {
        if (!visited.add(getName())) {
            throw new RuntimeException("Cycle detected");
        }
        for (ParFnApp parFnApp : TreeUtil.collectChildren(this, ParFnApp.class)) {
            PartialFunctionDecl called = functions.get(parFnApp.getName());
            if (called == null) {
                // will be caught somewhere else
                continue;
            }
            called.checkCycles(functions, new HashSet<>(visited));
        }
    }

    public FunctionDecl PartialFunctionDecl.expand(ParFnApp fnApp) {
        FunctionDecl expanded = new FunctionDecl();
        int funcParamCount = getNumFuncParam();
        if(funcParamCount != fnApp.getNumFuncParam()) {
            // TODO handle errors
            throw new RuntimeException("Wrong number of arguments");
        }

        String expandedName = expandedName(fnApp);
        expanded.setName(expandedName);
        expanded.setAnnotationList(getAnnotations().treeCopy());
        expanded.setTypeUse(getTypeUse().treeCopy());
        expanded.setParamList(getParams().treeCopy());

        Map<String, String> functions = new HashMap<>(funcParamCount * 2);
        for (int i = 0; i < funcParamCount; ++i) {
            String funcParam = getFuncParam(i).getName();
            String actualParam = fnApp.getFuncParam(i).getName();
            functions.put(funcParam, actualParam);
        }
        // enable recursion by replacing partial function name with expanded name
        functions.put(getName(), expandedName);
        expanded.setFunctionDef(getPartialFunctionDef().apply(functions));

        return expanded;
    }

    public FunctionDecl ParametricPartialFunctionDecl.expand(ParFnApp uncheckedFnApp) {
        FunctionDecl decl = super.expand(uncheckedFnApp);

        if(!(uncheckedFnApp instanceof ParametricParFnApp)) {
            // TODO error handling
            throw new RuntimeException("Calling parametric partially defined functions needs type parameters");
        }
        ParametricParFnApp fnApp = (ParametricParFnApp) uncheckedFnApp;
        if(fnApp.getNumTypeParam() != getNumTypeParameter()) {
            // TODO error handling
            throw new RuntimeException("Not the same amount of type parameters");
        }

        Map<String, TypeUse> typeBindings = new HashMap<>(getNumTypeParameter() * 2);
        for (int index = 0; index < getNumTypeParameter(); ++index) {
            TypeParameterDecl typeParamDecl = getTypeParameter(index);
            TypeUse typeParam = fnApp.getTypeParam(index);
            typeBindings.put(typeParamDecl.getName(), typeParam);
        }

        for (TypeUse typeUse : TreeUtil.collectChildren(decl.getTypeUseNoTransform(), TypeUse.class)) {
            TypeUse binding = typeBindings.get(typeUse.getName());
            if (binding != null) {
                TreeUtil.replace(typeUse, binding.treeCopy());
            }
        }

        for (ParamDecl param : decl.getParams()) {
            for (TypeUse typeUse : TreeUtil.collectChildren(param.getAccessNoTransform(), TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    TreeUtil.replace(typeUse, binding.treeCopy());
                }
            }
        }

        FunctionDef functionDef = decl.getFunctionDef();
        if (functionDef instanceof ExpFunctionDef) {
            ExpFunctionDef def = (ExpFunctionDef) functionDef;
            for (TypeUse typeUse : TreeUtil.collectChildren(def.getRhsNoTransform(), TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    TreeUtil.replace(typeUse, binding.treeCopy());
                }
            }
        } else {
            // TODO implement builtin
            throw new RuntimeException("Builtin is not supported yet");
        }
        return decl;
    }

    public String PartialFunctionDecl.expandedName(ParFnApp fnApp) {
        // avoid collisions by capitalizing the applied function name
        StringBuilder builder = new StringBuilder()
            .append(StringUtils.capitalize(getName()))
            .append('_').append(getModuleDecl().getName());

        for (FunctionParamDecl funcParam : fnApp.getFuncParams()) {
            builder.append('_').append(funcParam.getName());
        }

        return builder.toString();
    }

    public String ParametricPartialFunctionDecl.expandedName(ParFnApp fnApp) {
        String result = super.expandedName(fnApp);
        if(fnApp instanceof ParametricParFnApp) {
            // if this is not the case, it will be caught elsewhere
            ParametricParFnApp paramFnApp = (ParametricParFnApp) fnApp;
            StringBuilder builder = new StringBuilder();

            for (TypeUse typeUse : paramFnApp.getTypeParams()) {
                builder.append('_').append(typeUse.getName());
            }
            result += builder.toString();
        }
        return result;
    }

    public FunctionDef PartialFunctionDef.apply(Map<String, String> functions) {
        PureExp expression = getPureExp().treeCopy();
        for (FnApp innerCall : TreeUtil.collectChildren(expression, FnApp.class)) {
            String newName = functions.get(innerCall.getName());
            if (newName != null) {
                innerCall.setName(newName);
            }
        }

        return new ExpFunctionDef(expression);
    }

    public FnApp ParFnApp.apply(FunctionDecl function) {
        List<PureExp> params = getParamList();
        if (params == null) {
            throw new IllegalStateException("ParFnApp.apply() called twice");
        }
        TreeUtil.removeFromParent(params);
        return new FnApp(function.getName(), params);
    }
}
