import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import abs.frontend.pardef.*;

aspect PartialFunctionApplier {

    public void Model.expandPartialFunctions() {
        for (ModuleDecl moduleDecl : getModuleDecls()) {
            moduleDecl.expandPartialFunctions();
        }

        // TODO use check results
        if(!TreeUtil.isAbsent(this, ParFnApp.class)
            || !TreeUtil.isAbsent(this, PartialFunctionDecl.class)
            || !TreeUtil.isAbsent(this, PartialFunctionDef.class)) {
            throw new RuntimeException("Did not remove all partial function nodes");
        }
    }

    void ModuleDecl.expandPartialFunctions() {
        Map<String, PartialFunctionDecl> functionByName = collectPartialFunctions();

        // check for cycles
        for (PartialFunctionDecl function : functionByName.values()) {
            function.checkCycles(functionByName);
        }

        Map<String, ExpandedWrapper> expanded = new HashMap<>(functionByName.size() * 4);

        expandChildParFnApps(this, functionByName, expanded, 0);

        for (PartialFunctionDecl function : functionByName.values()) {
            TreeUtil.removeFromParent(function);
        }
    }

    private void ModuleDecl.expandChildParFnApps(ASTNode<?> node,
        Map<String, PartialFunctionDecl> functions,
        Map<String, ExpandedWrapper> expanded,
        int expansionCount) {
        for (ParFnApp fnApp : TreeUtil.findChildren(node, ParFnApp.class)) {
            if (TreeUtil.findParent(fnApp, PartialFunctionDecl.class) != null) {
                // ignore ParFnApp within pardef that has not been expanded yet
                continue;
            }
            PartialFunctionDecl function = functions.get(fnApp.getName());
            if (function == null) {
                String message = "No such partially defined function: " + fnApp.getName();
                throw new PardefModellingException(fnApp, message);
            }

            String expandedName = function.expandedName(fnApp);
            ExpandedWrapper expandedWrapper;
            expandedWrapper = expanded.get(expandedName);

            if (expandedWrapper == null) {
                FunctionDecl expandedFunction = function.expand(fnApp);
                addDecl(expandedFunction);
                AnnotationUtil.annotateExpansion(expandedFunction, expansionCount);
                expandedWrapper = new ExpandedWrapper(expandedFunction, expansionCount);
                expanded.put(expandedName, expandedWrapper);
                ++expansionCount;

                expandChildParFnApps(expandedFunction, functions, expanded, expansionCount);
            }

            FnApp expandedFunctionCall = fnApp.apply(expandedWrapper.getExpanded());
            TreeUtil.replace(fnApp, expandedFunctionCall);
            AnnotationUtil.annotateCall(expandedFunctionCall, expandedWrapper.getExpansionId());
        }
    }

    /**
     * Collects all Pardefs declared in this module and returns a map from their names to their declarations.
     * @return an unmodifiable map (functionName -> functionDeclaration), never null
     */
    private Map<String, PartialFunctionDecl> ModuleDecl.collectPartialFunctions() {
        Map<String, PartialFunctionDecl> result = new HashMap<>(32);

        for (Decl decl : getDecls()) {
            if (decl instanceof PartialFunctionDecl) {
                PartialFunctionDecl functionDecl = (PartialFunctionDecl) decl;
                result.put(functionDecl.getName(), functionDecl);
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionDecl> functionByName) {
        checkCycles(functionByName, new HashSet<String>());
    }

    private void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionDecl> functionByName, Set<String> visited) {
        if (!visited.add(getName())) {
            throw new PardefCycleException(this);
        }
        for (ParFnApp parFnApp : TreeUtil.findChildren(this, ParFnApp.class)) {
            PartialFunctionDecl called = functionByName.get(parFnApp.getName());
            if (called == null) {
                // will be caught somewhere else
                continue;
            }
            try {
            called.checkCycles(functionByName, new HashSet<>(visited));
            } catch (PardefCycleException e) {
                throw e.calledBy(this);
            }
        }
    }

    public FunctionDecl PartialFunctionDecl.expand(ParFnApp fnApp) {
        FunctionDecl expanded = new FunctionDecl();
        int funcParamCount = getNumFuncParam();
        if (funcParamCount != fnApp.getNumFuncParam()) {
            String message = "Wrong number of function arguments for partially defined function " + getName();
            throw new PardefModellingException(fnApp, message);
        }

        if (getNumParam() != fnApp.getNumParam()) {
            String message = "Wrong number of arguments for partially defined function " + getName();
            throw new PardefModellingException(fnApp, message);
        }

        String expandedName = expandedName(fnApp);
        expanded.setName(expandedName);
        expanded.setAnnotationList(getAnnotations().treeCopy());
        expanded.setTypeUse(getTypeUse().treeCopy());
        expanded.setParamList(getParams().treeCopy());

        Map<String, String> funcParamBindings = new HashMap<>(funcParamCount * 2);
        for (int i = 0; i < funcParamCount; ++i) {
            String paramName = getFuncParam(i).getName();
            String binding = fnApp.getFuncParam(i).getName();
            funcParamBindings.put(paramName, binding);
        }
        // enable recursion by replacing partial function name with expanded name
        funcParamBindings.put(getName(), expandedName);
        expanded.setFunctionDef(getPartialFunctionDef().apply(funcParamBindings));

        return expanded;
    }

    public FunctionDecl ParametricPartialFunctionDecl.expand(ParFnApp uncheckedFnApp) {
        FunctionDecl decl = super.expand(uncheckedFnApp);

        if(!(uncheckedFnApp instanceof ParametricParFnApp)) {
            String message = "Calling parametric partially defined function '" + getName() + "' needs type parameters";
            throw new PardefModellingException(uncheckedFnApp, message);
        }
        ParametricParFnApp fnApp = (ParametricParFnApp) uncheckedFnApp;
        if(fnApp.getNumTypeParam() != getNumTypeParameter()) {
            String message = "Wrong number of type parameters for partially defined function " + getName();
            throw new PardefModellingException(fnApp, message);
        }

        Map<String, TypeUse> typeBindings = new HashMap<>(getNumTypeParameter() * 2);
        for (int index = 0; index < getNumTypeParameter(); ++index) {
            TypeParameterDecl typeParamDecl = getTypeParameter(index);
            TypeUse typeParam = fnApp.getTypeParam(index);
            typeBindings.put(typeParamDecl.getName(), typeParam);
        }

        // apply type bindings to return type
        for (TypeUse typeUse : TreeUtil.findChildren(decl.getTypeUseNoTransform(), TypeUse.class)) {
            TypeUse binding = typeBindings.get(typeUse.getName());
            if (binding != null) {
                TreeUtil.replace(typeUse, binding.treeCopy());
            }
        }

        // apply type bindings to parameters
        for (ParamDecl param : decl.getParams()) {
            for (TypeUse typeUse : TreeUtil.findChildren(param.getAccessNoTransform(), TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    TreeUtil.replace(typeUse, binding.treeCopy());
                }
            }
        }

        // apply type bindings in function definition
        FunctionDef functionDef = decl.getFunctionDef();
        if (functionDef instanceof ExpFunctionDef) {
            ExpFunctionDef def = (ExpFunctionDef) functionDef;
            for (TypeUse typeUse : TreeUtil.findChildren(def.getRhsNoTransform(), TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    TreeUtil.replace(typeUse, binding.treeCopy());
                }
            }
        } else {
            // TODO implement builtin
            throw new RuntimeException("Builtin pardefs are not supported yet");
        }
        return decl;
    }

    /**
     * Returns the name for the expanded version of this function based on the specified function call.<br>
     *
     * @return CapitalizedFunctioName_moduleName_funcParam1_funcParam2[...]
     */
    public String PartialFunctionDecl.expandedName(ParFnApp fnApp) {
        // avoid collisions by capitalizing the applied function name
        StringBuilder builder = new StringBuilder()
            .append(StringUtils.capitalize(getName()))
            .append('_').append(getModuleDecl().getName());

        for (FunctionParamDecl funcParam : fnApp.getFuncParams()) {
            builder.append('_').append(funcParam.getName());
        }

        return builder.toString();
    }

    /**
     * Returns the name for the expanded version of this function based on the specified function call.<br>
     *
     * @return CapitalizedFunctioName_moduleName_funcParam1_funcParam2[...]_typeParam1_typeParam2[...]
     */
    public String ParametricPartialFunctionDecl.expandedName(ParFnApp fnApp) {
        String result = super.expandedName(fnApp);
        if(fnApp instanceof ParametricParFnApp) {
            // if this is not the case, it will be caught elsewhere
            ParametricParFnApp paramFnApp = (ParametricParFnApp) fnApp;
            StringBuilder builder = new StringBuilder();

            for (TypeUse typeUse : paramFnApp.getTypeParams()) {
                builder.append('_').append(typeUse.getName());
            }
            result += builder.toString();
        }
        return result;
    }

    /**
     * <p>Gets a FunctionDef instance based on this PartialFunctionDef.</p>
     *
     * In the resulting FunctionDef, all function calls to functions contained in the specified map are replaced by
     * calls to the respective value in the map.
     *
     * @return a FunctionDef
     */
    public FunctionDef PartialFunctionDef.apply(Map<String, String> functionBindings) {
        PureExp expression = getPureExp().treeCopy();
        for (FnApp innerCall : TreeUtil.findChildren(expression, FnApp.class)) {
            String newName = functionBindings.get(innerCall.getName());
            if (newName != null) {
                innerCall.setName(newName);
            }
        }

        return new ExpFunctionDef(expression);
    }

    /**
     * <p>Gets an applied version of this ParFnApp.</p>
     *
     * After calling this method, this object is in an invalid state and should be discarded.
     *
     * @return a FnApp
     * @throws IllegalStateException if this method is called twice
     */
    public FnApp ParFnApp.apply(FunctionDecl function) {
        List<PureExp> params = getParamList();
        if (params == null) {
            throw new IllegalStateException("ParFnApp.apply() called twice");
        }
        TreeUtil.removeFromParent(params);
        return new FnApp(function.getName(), params);
    }
}
