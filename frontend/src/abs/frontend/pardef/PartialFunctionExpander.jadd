import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import abs.frontend.pardef.*;

aspect PartialFunctionApplier {

    public void Model.expandPartialFunctions() {
        for (ModuleDecl moduleDecl : getModuleDecls()) {
            moduleDecl.expandPartialFunctions();
        }
    }

    void ModuleDecl.expandPartialFunctions() {
        Map<String, PartialFunctionDecl> functionByName = collectPartialFunctions();

        // check for cycles
        for (PartialFunctionDecl function : functionByName.values()) {
            function.checkCycles(functionByName);
        }

        Map<String, ExpandedWrapper> expanded = new HashMap<>(functionByName.size() * 4);

        expandChildParFnApps(this, functionByName, expanded, 0);
    }

    private int ModuleDecl.expandChildParFnApps(ASTNode<?> node,
        Map<String, PartialFunctionDecl> functions,
        Map<String, ExpandedWrapper> expanded,
        int expansionCount) {
        for (ParFnApp fnApp : TreeUtil.findChildren(node, ParFnApp.class)) {
            if (TreeUtil.findParent(fnApp, PartialFunctionDecl.class) != null) {
                // ignore ParFnApp within pardef that has not been expanded yet
                continue;
            }
            PartialFunctionDecl function = functions.get(fnApp.getName());
            if (function == null) {
                throw new PardefModellingException(fnApp, ErrorMessage.FUNCTION_NOT_RESOLVABLE, fnApp.getName());
            }

            String expandedName = function.expandedName(fnApp);
            ExpandedWrapper expandedWrapper;
            expandedWrapper = expanded.get(expandedName);

            if (expandedWrapper == null) {
                FunctionDecl expandedFunction = function.expand(fnApp);
                addDecl(expandedFunction);
                AnnotationUtil.annotateExpansion(expandedFunction, expansionCount);
                expandedWrapper = new ExpandedWrapper(expandedFunction, expansionCount);
                expanded.put(expandedName, expandedWrapper);
                ++expansionCount;

                expansionCount = expandChildParFnApps(expandedFunction, functions, expanded, expansionCount);
            } else {
                function.checkValid(fnApp);
            }

            FnApp expandedFunctionCall = fnApp.apply(expandedWrapper.getExpanded());
            TreeUtil.replace(fnApp, expandedFunctionCall);
            AnnotationUtil.annotateCall(expandedFunctionCall, expandedWrapper.getExpansionId());
        }
        return expansionCount;
    }

    /**
     * Collects all Pardefs declared in this module and returns a map from their names to their declarations.
     * @return an unmodifiable map (functionName -> functionDeclaration), never null
     */
    private Map<String, PartialFunctionDecl> ModuleDecl.collectPartialFunctions() {
        Map<String, PartialFunctionDecl> result = new HashMap<>(32);

        for (Decl decl : getDecls()) {
            if (decl instanceof PartialFunctionDecl) {
                PartialFunctionDecl functionDecl = (PartialFunctionDecl) decl;
                String functionName = functionDecl.getName();
                if (result.containsKey(functionName)) {
                    throw new PardefModellingException(
                        ErrorMessage.DUPLICATE_FUN_NAME.withArgs(functionName, "")
                    );
                }
                result.put(functionName, functionDecl);
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionDecl> functionByName) {
        checkCycles(functionByName, new HashSet<String>());
    }

    private void PartialFunctionDecl.checkCycles(Map<String, PartialFunctionDecl> functionByName, Set<String> visited) {
        if (!visited.add(getName())) {
            throw new PardefCycleException(this);
        }
        for (ParFnApp parFnApp : TreeUtil.findChildren(this, ParFnApp.class)) {
            PartialFunctionDecl called = functionByName.get(parFnApp.getName());
            if (called == null) {
                // will be caught somewhere else
                continue;
            }
            try {
            called.checkCycles(functionByName, new HashSet<>(visited));
            } catch (PardefCycleException e) {
                throw e.calledBy(this);
            }
        }
    }

    public void PartialFunctionDecl.checkValid(ParFnApp fnApp) {
        if (getNumFuncParam() != fnApp.getNumFuncParam()) {
            throw new PardefModellingException(
                fnApp,
                ErrorMessage.WRONG_NUMBER_OF_FUNC_ARGS,
                getNumFuncParam(),
                fnApp.getNumFuncParam()
            );
        }

        if (getNumParam() != fnApp.getNumParam()) {
            throw new PardefModellingException(
                fnApp,
                ErrorMessage.WRONG_NUMBER_OF_ARGS,
                getNumParam(),
                fnApp.getNumParam()
            );
        }
    }

    public void ParametricPartialFunctionDecl.checkValid(ParFnApp uncheckedFnApp) {
        super.checkValid(uncheckedFnApp);
        if(!(uncheckedFnApp instanceof ParametricParFnApp)) {
            throw new PardefModellingException(
                uncheckedFnApp,
                ErrorMessage.WRONG_NUMBER_OF_TYPE_ARGS_FUNCTION,
                getName(),
                getNumTypeParameter(),
                0
            );
        }
        ParametricParFnApp fnApp = (ParametricParFnApp) uncheckedFnApp;
        if(fnApp.getNumTypeParam() != getNumTypeParameter()) {
            throw new PardefModellingException(
                fnApp,
                ErrorMessage.WRONG_NUMBER_OF_TYPE_ARGS_FUNCTION,
                getName(),
                getNumTypeParameter(),
                fnApp.getNumTypeParam()
            );
        }
    }

    public FunctionDecl PartialFunctionDecl.expand(ParFnApp fnApp) {
        checkValid(fnApp);
        FunctionDecl expanded = new FunctionDecl();
        String expandedName = expandedName(fnApp);
        expanded.setName(expandedName);
        expanded.setAnnotationList(getAnnotations().treeCopy());
        expanded.setTypeUse(getTypeUse().treeCopy());
        expanded.setParamList(getParams().treeCopy());

        int funcParamCount = getNumFuncParam();
        Map<String, String> funcParamBindings = new HashMap<>(funcParamCount * 2);
        for (int i = 0; i < funcParamCount; ++i) {
            String paramName = getFuncParam(i).getName();
            String binding = fnApp.getFuncParam(i).getName();
            funcParamBindings.put(paramName, binding);
        }
        // enable recursion by replacing partial function name with expanded name
        funcParamBindings.put(getName(), expandedName);
        expanded.setFunctionDef(getPartialFunctionDef().apply(funcParamBindings));

        return expanded;
    }

    public FunctionDecl ParametricPartialFunctionDecl.expand(ParFnApp uncheckedFnApp) {
        FunctionDecl decl = super.expand(uncheckedFnApp);
        // cast is checked in checkValid()
        ParametricParFnApp fnApp = (ParametricParFnApp) uncheckedFnApp;
        Map<String, TypeUse> typeBindings = new HashMap<>(getNumTypeParameter() * 2);
        for (int index = 0; index < getNumTypeParameter(); ++index) {
            TypeParameterDecl typeParamDecl = getTypeParameter(index);
            TypeUse typeParam = fnApp.getTypeParam(index);
            typeBindings.put(typeParamDecl.getName(), typeParam);
        }

        // apply type bindings to return type
        for (TypeUse typeUse : TreeUtil.findChildren(decl.getTypeUseNoTransform(), TypeUse.class)) {
            TypeUse binding = typeBindings.get(typeUse.getName());
            if (binding != null) {
                TreeUtil.replace(typeUse, binding.treeCopy());
            }
        }

        // apply type bindings to parameters
        for (ParamDecl param : decl.getParams()) {
            for (TypeUse typeUse : TreeUtil.findChildren(param.getAccessNoTransform(), TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    TreeUtil.replace(typeUse, binding.treeCopy());
                }
            }
        }

        // apply type bindings in function definition
        FunctionDef functionDef = decl.getFunctionDef();
        if (functionDef instanceof ExpFunctionDef) {
            ExpFunctionDef def = (ExpFunctionDef) functionDef;
            for (TypeUse typeUse : TreeUtil.findChildren(def.getRhsNoTransform(), TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    TreeUtil.replace(typeUse, binding.treeCopy());
                }
            }
        } else {
            // TODO implement builtin
            throw new RuntimeException("Builtin pardefs are not supported yet");
        }
        return decl;
    }

    /**
     * Returns the name for the expanded version of this function based on the specified function call.<br>
     *
     * @return CapitalizedFunctioName_moduleName_funcParam1_funcParam2[...]
     */
    public String PartialFunctionDecl.expandedName(ParFnApp fnApp) {
        // avoid collisions by capitalizing the applied function name
        StringBuilder builder = new StringBuilder()
            .append(StringUtils.capitalize(getName()))
            .append('_').append(getModuleDecl().getName());

        for (FunctionParamDecl funcParam : fnApp.getFuncParams()) {
            builder.append('_').append(funcParam.getName());
        }

        return builder.toString();
    }

    /**
     * Returns the name for the expanded version of this function based on the specified function call.<br>
     *
     * @return CapitalizedFunctioName_moduleName_funcParam1_funcParam2[...]_typeParam1_typeParam2[...]
     */
    public String ParametricPartialFunctionDecl.expandedName(ParFnApp fnApp) {
        String result = super.expandedName(fnApp);
        if(fnApp instanceof ParametricParFnApp) {
            // if this is not the case, it will be caught elsewhere
            ParametricParFnApp paramFnApp = (ParametricParFnApp) fnApp;
            StringBuilder builder = new StringBuilder();

            for (TypeUse typeUse : paramFnApp.getTypeParams()) {
                builder.append('_').append(typeUse.getName());
            }
            result += builder.toString();
        }
        return result;
    }

    /**
     * <p>Gets a FunctionDef instance based on this PartialFunctionDef.</p>
     *
     * In the resulting FunctionDef, all function calls to functions contained in the specified map are replaced by
     * calls to the respective value in the map.
     *
     * @return a FunctionDef
     */
    public FunctionDef PartialFunctionDef.apply(Map<String, String> functionBindings) {
        PureExp expression = getPureExp().treeCopy();
        for (FnApp innerCall : TreeUtil.findChildren(expression, FnApp.class)) {
            String newName = functionBindings.get(innerCall.getName());
            if (newName != null) {
                innerCall.setName(newName);
            }
        }

        for (ParFnApp innerCall : TreeUtil.findChildren(expression, ParFnApp.class)) {
            for (FunctionParamDecl funcParam : innerCall.getFuncParamsNoTransform()) {
                String binding = functionBindings.get(funcParam.getName());
                if (binding != null) {
                    funcParam.setName(binding);
                }
            }
        }

        return new ExpFunctionDef(expression);
    }

    /**
     * <p>Gets an applied version of this ParFnApp.</p>
     *
     * After calling this method, this object is in an invalid state and should be discarded.
     *
     * @return a FnApp
     * @throws IllegalStateException if this method is called twice
     */
    public FnApp ParFnApp.apply(FunctionDecl function) {
        List<PureExp> params = getParamList();
        if (params == null) {
            throw new IllegalStateException("ParFnApp.apply() called twice");
        }
        TreeUtil.removeFromParent(params);
        return new FnApp(function.getName(), params);
    }
}
