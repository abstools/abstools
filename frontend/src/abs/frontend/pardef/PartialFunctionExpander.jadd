import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import abs.frontend.pardef.*;

aspect PartialFunctionExpander {

    public void Model.expandPartialFunctions() {
        for (ModuleDecl moduleDecl : getModuleDecls()) {
            moduleDecl.expandPartialFunctions();
        }
    }

    public PartialFunctionDecl ModuleDecl.getPartialFunction(String name) {
        ResolvedName resolved = resolveName(new KindedName(Kind.PARTIAL_FUN, name));
        return resolved == null ? null : (PartialFunctionDecl) resolved.getDecl();
    }

    syn int ModuleDecl.getExpansionCount() {
        int result = 0;
        for (FunctionDecl decl : getDeclsNoTransform().findChildren(FunctionDecl.class)) {
            if (AnnotationUtil.getExpansionId(decl) > -1) {
                ++result;
            }
        }
        return result;
    }

    void ModuleDecl.expandPartialFunctions() {
        // check for cycles
        for (PartialFunctionDecl function : getDecls().findChildren(PartialFunctionDecl.class)) {
            function.checkCycles(this);
        }

        expandChildParFnApps(this, getExpansionCount());
    }

    private ExpandedWrapper ModuleDecl.getExpansion(String expansionName) {
        ResolvedName resolved = resolveName(new KindedName(Kind.FUN, expansionName));
        if (resolved != null) {
            FunctionDecl decl = (FunctionDecl) resolved.getDecl();
            int expansionId = AnnotationUtil.getExpansionId(decl);
            if (expansionId > -1) {
                return new ExpandedWrapper(decl, expansionId);
            }
        }
        return null;
    }

    private void ModuleDecl.expandChildParFnApps() {
        expandChildParFnApps(this, getExpansionCount());
    }

    private int ModuleDecl.expandChildParFnApps(ASTNode<?> node, int expansionCount) {
        for (ParFnApp fnApp : node.findChildren(ParFnApp.class, true)) {
            if (fnApp.closestParent(PartialFunctionDecl.class) != null) {
                // ignore ParFnApp within pardef that has not been expanded yet
                continue;
            }

            if (fnApp.closestParent(ModuleDecl.class) == null) {
                // If this happens, it's a compiler error
                throw new RuntimeException("This should not have happened");
            }

            PartialFunctionDecl function = getPartialFunction(fnApp.getName());
            if (function == null) {
                throw new PardefModellingException(fnApp, ErrorMessage.FUNCTION_NOT_RESOLVABLE, fnApp.getName());
            }

            String expandedName = function.expandedName(fnApp);
            ExpandedWrapper expandedWrapper;
            expandedWrapper = getExpansion(expandedName);

            if (expandedWrapper == null) {
                FunctionDecl expandedFunction = function.expand(fnApp);
                addDecl(expandedFunction);
                AnnotationUtil.annotateExpansion(expandedFunction, expansionCount);
                expandedWrapper = new ExpandedWrapper(expandedFunction, expansionCount);
                ++expansionCount;
                // flush cache so expanded function can be resolved
                flushAttrCache();

                expansionCount = expandChildParFnApps(expandedFunction, expansionCount);
            } else {
                function.checkValid(fnApp);
            }

            FnApp expandedFunctionCall = fnApp.apply(expandedWrapper.getExpanded());
            fnApp.replaceWith(expandedFunctionCall);
            AnnotationUtil.annotateCall(expandedFunctionCall, expandedWrapper.getExpansionId());
            // expand ParFnApps in params of expandedFunctionCall
            expansionCount = expandChildParFnApps(expandedFunctionCall, expansionCount);
        }
        return expansionCount;
    }

    /**
    * Checks for cycles in this PartialFunctionDecl.
    * @param module the ModuleDecl containing this pardef
    * @throws PardefCycleException if a cycle is detected
    */
    public void PartialFunctionDecl.checkCycles(ModuleDecl module) {
        checkCycles(module, new HashSet<String>());
    }

    private void PartialFunctionDecl.checkCycles(ModuleDecl module, Set<String> visited) {
        if (!visited.add(getName())) {
            throw new PardefCycleException(this);
        }
        for (ParFnApp parFnApp : this.findChildren(ParFnApp.class)) {
            PartialFunctionDecl called = module.getPartialFunction(parFnApp.getName());
            if (called == null) {
                // will be caught somewhere else
                continue;
            }
            try {
                called.checkCycles(module, new HashSet<>(visited));
            } catch (PardefCycleException e) {
                throw e.calledBy(this);
            }
        }
    }

    /**
    * Checks whether a ParFnApp is a valid call to this function by comparing parameter counts.
    * @param fnApp a ParFnApp calling this PartialFunctionDecl
    * @throws PardefModellingException if the call is invalid
    */
    public void PartialFunctionDecl.checkValid(ParFnApp fnApp) {
        if (getNumFuncParam() != fnApp.getNumFuncParam()) {
            throw new PardefModellingException(
                fnApp,
                ErrorMessage.WRONG_NUMBER_OF_FUNC_ARGS,
                getNumFuncParam(),
                fnApp.getNumFuncParam()
            );
        }

        if (getNumParam() != fnApp.getNumParam()) {
            throw new PardefModellingException(
                fnApp,
                ErrorMessage.WRONG_NUMBER_OF_ARGS,
                getNumParam(),
                fnApp.getNumParam()
            );
        }
    }

    @Override
    public void ParametricPartialFunctionDecl.checkValid(ParFnApp uncheckedFnApp) {
        super.checkValid(uncheckedFnApp);
        if(!(uncheckedFnApp instanceof ParametricParFnApp)) {
            // Parametric pardefs MUST be called with type parameters
            throw new PardefModellingException(
                uncheckedFnApp,
                ErrorMessage.WRONG_NUMBER_OF_TYPE_ARGS_FUNCTION,
                getName(),
                getNumTypeParameter(),
                0
            );
        }
        ParametricParFnApp fnApp = (ParametricParFnApp) uncheckedFnApp;
        if(fnApp.getNumTypeParam() != getNumTypeParameter()) {
            throw new PardefModellingException(
                fnApp,
                ErrorMessage.WRONG_NUMBER_OF_TYPE_ARGS_FUNCTION,
                getName(),
                getNumTypeParameter(),
                fnApp.getNumTypeParam()
            );
        }
    }

    /**
    * Creates an expanded version of this partially defined function based on the specified function call.
    * @param fnApp a call to this function
    * @return a detached FunctionDecl
    * @throws PardefModellingException if the given ParFnApp is not a valid call to this function
    */
    public FunctionDecl PartialFunctionDecl.expand(ParFnApp fnApp) {
        checkValid(fnApp);
        FunctionDecl expanded = new FunctionDecl();
        String expandedName = expandedName(fnApp);
        expanded.setName(expandedName);
        expanded.setAnnotationList(getAnnotations().treeCopy());
        expanded.setTypeUse(getTypeUse().treeCopy());
        expanded.setParamList(getParams().treeCopy());

        int funcParamCount = getNumFuncParam();
        Map<String, ParFnAppParamDecl> funcParamBindings = new HashMap<>(funcParamCount * 2);
        for (int i = 0; i < funcParamCount; ++i) {
            String paramName = getFuncParam(i).getName();
            ParFnAppParamDecl binding = fnApp.getFuncParam(i);
            funcParamBindings.put(paramName, binding);
        }

        // enable recursion by replacing partial function name with expanded name
        funcParamBindings.put(getName(), new NamedParFnAppParam(expandedName));
        expanded.setFunctionDef(getPartialFunctionDef().apply(funcParamBindings));

        // must happen after recursive calls have been renamed to the expanded name
        java.util.List<AnonymousFunctionDecl> addedClosures = new LinkedList<>();
        for (ParFnAppParamDecl funcParam : fnApp.getFuncParams()) {
            if (funcParam instanceof AnonymousFunctionDecl) {
                AnonymousFunctionDecl anon = (AnonymousFunctionDecl) funcParam;
                anon.addClosureParams(addedClosures, expanded);
            }
        }

        return expanded;
    }

    @Override
    public FunctionDecl ParametricPartialFunctionDecl.expand(ParFnApp uncheckedFnApp) {
        FunctionDecl decl = super.expand(uncheckedFnApp);
        // cast is checked in checkValid()
        ParametricParFnApp fnApp = (ParametricParFnApp) uncheckedFnApp;
        Map<String, TypeUse> typeBindings = new HashMap<>(getNumTypeParameter() * 2);
        for (int index = 0; index < getNumTypeParameter(); ++index) {
            TypeParameterDecl typeParamDecl = getTypeParameter(index);
            TypeUse typeParam = fnApp.getTypeParam(index);
            typeBindings.put(typeParamDecl.getName(), typeParam);
        }

        // apply type bindings to return type
        for (TypeUse typeUse : decl.getTypeUseNoTransform().findChildren(TypeUse.class)) {
            TypeUse binding = typeBindings.get(typeUse.getName());
            if (binding != null) {
                typeUse.replaceWith(binding.treeCopy());
            }
        }

        // apply type bindings to parameters
        for (ParamDecl param : decl.getParams()) {
            for (TypeUse typeUse : param.getAccessNoTransform().findChildren(TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    typeUse.replaceWith(binding.treeCopy());
                }
            }
        }

        // apply type bindings in function definition
        FunctionDef functionDef = decl.getFunctionDef();
        if (functionDef instanceof ExpFunctionDef) {
            ExpFunctionDef def = (ExpFunctionDef) functionDef;
            for (TypeUse typeUse : def.getRhsNoTransform().findChildren(TypeUse.class)) {
                TypeUse binding = typeBindings.get(typeUse.getName());
                if (binding != null) {
                    typeUse.replaceWith(binding.treeCopy());
                }
            }
        } else {
            // TODO implement builtin
            throw new RuntimeException("Builtin pardefs are not supported yet");
        }
        return decl;
    }

    /**
    * Sanitizes the given identifier name by replacing illegal characters.
    * For example "m_StdLib.Int test" becomes "m_StdLib_Int_test".
    *
    * @param identifier the identifier name to sanitize
    * @return a string without illegal characters
    */
    protected String PartialFunctionDecl.sanitizeIdentifierName(String identifier) {
        // In theory, catching "." would suffice, but you never know...
        return identifier.replaceAll("[^a-zA-Z\\d_]", "_");
    }

    /**
     * Returns the name for the expanded version of this function based on the specified function call.<br>
     *
     * @return CapitalizedFunctioName_moduleName_funcParam1_funcParam2[...]
     */
    public String PartialFunctionDecl.expandedName(ParFnApp fnApp) {
        // avoid collisions by capitalizing the applied function name
        StringBuilder builder = new StringBuilder()
            .append(StringUtils.capitalize(getName()))
            .append('_').append(getModuleDecl().getName());

        for (ParFnAppParamDecl funcParam : fnApp.getFuncParamsNoTransform()) {
            if (funcParam instanceof NamedParFnAppParam) {
                NamedParFnAppParam namedParam = (NamedParFnAppParam) funcParam;
                builder.append('_').append(namedParam.getName());
            } else if (funcParam instanceof AnonymousFunctionDecl) {
                AnonymousFunctionDecl anon = (AnonymousFunctionDecl) funcParam;
                builder.append(anon.qualifyName(""));
            }
        }

        return sanitizeIdentifierName(builder.toString());
    }

    /**
     * Returns the name for the expanded version of this function based on the specified function call.<br>
     *
     * @return CapitalizedFunctioName_moduleName_funcParam1_funcParam2[...]_typeParam1_typeParam2[...]
     */
    @Override
    public String ParametricPartialFunctionDecl.expandedName(ParFnApp fnApp) {
        String result = super.expandedName(fnApp);
        if(fnApp instanceof ParametricParFnApp) {
            // if this is not the case, it will be caught elsewhere
            ParametricParFnApp paramFnApp = (ParametricParFnApp) fnApp;
            StringBuilder builder = new StringBuilder();

            for (TypeUse typeUse : paramFnApp.getTypeParams()) {
                builder.append('_').append(typeUse.getName());
            }
            result += builder.toString();
        }
        return sanitizeIdentifierName(result);
    }

    /**
    * <p>Gets a FunctionDef instance based on this PartialFunctionDef.</p>
    *
    * In the resulting FunctionDef, all function calls to functions contained in the specified map are replaced by
    * calls to the respective value in the map.
    *
    * @return a FunctionDef
    */
    public FunctionDef PartialFunctionDef.apply(Map<String, ParFnAppParamDecl> bindingByName) {
        PureExp expression = getPureExp().treeCopy();
        // Wrap the expression BEFORE applying the bindings so it has a parent
        FunctionDef result = new ExpFunctionDef(expression);

        applyBindings(expression, bindingByName);

        return result;
    }

    private void PartialFunctionDef.applyBindings(PureExp expression, Map<String, ParFnAppParamDecl> bindingByName) {
        for (FnApp innerCall : expression.findChildren(FnApp.class)) {
            ParFnAppParamDecl binding = bindingByName.get(innerCall.getName());
            if (binding != null) {
                PureExp replacement = binding.getExpression(innerCall);
                innerCall.replaceWith(replacement);
                applyBindings(replacement, bindingByName);
            }
        }

        for (ParFnApp innerCall : expression.findChildren(ParFnApp.class)) {
            for (ParFnAppParamDecl funcParam : innerCall.getFuncParamsNoTransform()) {
                if (funcParam instanceof NamedParFnAppParam) {
                    NamedParFnAppParam namedFuncParam = (NamedParFnAppParam) funcParam;
                    ParFnAppParamDecl binding = bindingByName.get(namedFuncParam.getName());
                    if (binding != null) {
                        namedFuncParam.replaceWith(binding.treeCopyNoTransform());
                    }
                }
            }
        }
    }

    /**
     * <p>Creates a function call to the specified expanded pardef with a copy of the this pardef call's params.</p>
     *
     * @return a FnApp
     */
    public FnApp ParFnApp.apply(FunctionDecl function) {
        java.util.List<AnonymousFunctionDecl> addedClosures = new LinkedList<>();
        for (ParFnAppParamDecl fnParam : getFuncParamsNoTransform()) {
            if (fnParam instanceof AnonymousFunctionDecl) {
                AnonymousFunctionDecl anon = (AnonymousFunctionDecl) fnParam;
                anon.addClosureParams(addedClosures, this);
            }
        }

        List<PureExp> params = getParamList();
        return new FnApp(function.getName(), params.treeCopyNoTransform());
    }
}
