import abs.frontend.pardef.*;

aspect ParFnAppParam {
    syn PureExp ParFnAppParamDecl.getExpression(FnApp toReplace);

    eq NamedParFnAppParam.getExpression(FnApp toReplace) = new FnApp(getName(), toReplace.getParams().treeCopyNoTransform());
    eq AnonymousFunctionDecl.getExpression(FnApp toReplace) {
        PureExp exp = getPureExpNoTransform().treeCopyNoTransform();
        PureExp result = exp;

        int numParam = getNumParam();
        if (numParam != toReplace.getNumParam()) {
            throw new PardefModellingException(toReplace, ErrorMessage.WRONG_NUMBER_OF_ARGS, numParam, toReplace.getNumParam());
        }

        // Wrap the expression by let expressions for each parameter
        // TODO note: this obviously has some flaws, but works for a start (should be fixed alongside the introduction of closures)
        for (int i = 0; i < numParam; ++i) {
            result = new LetExp(
                getParamNoTransform(i).treeCopyNoTransform(),
                toReplace.getParamNoTransform(i).treeCopyNoTransform(),
                result
            );
        }

        Map<String, ParamDecl> freeVars = getFreeVars();
        for (VarOrFieldUse varUse : TreeUtil.findChildren(exp, VarOrFieldUse.class)) {
            ParamDecl replacement = freeVars.get(varUse.getName());
            if (replacement != null) {
                varUse.setName(replacement.getName());
            }
        }

        return result;
    }

    syn lazy Map<String, ParamDecl> AnonymousFunctionDecl.getFreeVars() {
        ASTNode<?> parent = getParent();
        setParent(null);
        java.util.List<VarOrFieldUse> freeVarUses = new LinkedList<>();
        for (VarOrFieldUse use : TreeUtil.findChildren(this, VarOrFieldUse.class)) {
            VarOrFieldDecl varDecl = use.getDecl();
            if (varDecl == null) {
                freeVarUses.add(use);
            }
        }
        setParent(parent);

        Map<String, ParamDecl> result = new HashMap<>();
        for (VarOrFieldUse freeVarUse : freeVarUses) {
            Type type = freeVarUse.getType();
            if (type.isUnknownType()) {
                // TODO refine message
                throw new PardefModellingException("Unknown var: " + freeVarUse.getName());
            }
            ParamDecl param = result.get(freeVarUse.getName());
            if (param == null) {
                String qualifiedName = qualifyName(freeVarUse.getName());
                param = new ParamDecl(qualifiedName, type.toUse(), new List<Annotation>());
                result.put(freeVarUse.getName(), param);
            } else {
                // TODO check for same type
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public String AnonymousFunctionDecl.qualifyName(String name) {
        return name + "_" + getPureExpNoTransform().getExpId();
    }

    public void AnonymousFunctionDecl.addClosureParams(FunctionDecl func) {
        List<ParamDecl> params = func.getParams();
        for (ParamDecl freeVar : getFreeVars().values()) {
            params.add(freeVar.treeCopyNoTransform());
        }
    }

    public void AnonymousFunctionDecl.addClosureParams(ParFnApp fnApp) {
        for (String freeVarName : getFreeVars().keySet()) {
            fnApp.addParam(new VarUse(freeVarName));
        }
    }

    syn lazy String PureExp.getExpId() {
          // TODO this can cause collisions. Should create actual IDs.
          StringWriter sw = new StringWriter();
          PrintWriter pw = new PrintWriter(sw);
          this.doPrettyPrint(pw, new DefaultABSFormatter(pw));
          long hashCode = sw.toString().hashCode();
          // avoid negative numbers
          return Long.toString(hashCode - Integer.MIN_VALUE);
    }
}