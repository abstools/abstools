import abs.frontend.pardef.*;

/**
* This aspect handles parameters for ParFnApps (function references and anonymous functions).
*/
aspect ParFnAppParam {
    /**
    * Gets an expression with which occurrences of this ParFnApp parameter should be replaced in the function expansion.
    *
    @param toReplace a FnApp calling the function represented by this ParFnAppParamDecl
    @return a pure expression to replace the given FnApp with
    */
    syn PureExp ParFnAppParamDecl.getExpression(FnApp toReplace);

    eq NamedParFnAppParam.getExpression(FnApp toReplace) = new FnApp(getName(), toReplace.getParams().treeCopyNoTransform());
    eq AnonymousFunctionDecl.getExpression(FnApp toReplace) {
        PureExp exp = getPureExp().treeCopy();
        PureExp result = exp;

        int numParam = getNumParam();
        if (numParam != toReplace.getNumParam()) {
            throw new PardefModellingException(toReplace, ErrorMessage.WRONG_NUMBER_OF_ARGS, numParam, toReplace.getNumParam());
        }

        // Create a let expression for each closure so no VarUse in the expression has to be renamed.
        for (Map.Entry<String, ParamDecl> entry : getFreeVars().entrySet()) {
            ParamDecl closureParam = entry.getValue();
            Access closureType = closureParam.getAccess();
            ParamDecl letParam = new ParamDecl(entry.getKey(), closureType, new List<Annotation>());
            VarUse closureUse = new VarUse(closureParam.getName());
            result = new LetExp(
                letParam,
                closureUse,
                result
            );
        }

        /*
        Wrap the expression by let expressions for each parameter.
        Alternatives would be:
        a) rename all occurrences of each parameter in the expression
        b) create a new named function for each anonymous function (clutters namespace)
        */
        for (int i = 0; i < numParam; ++i) {
            result = new LetExp(
                getParam(i).treeCopy(),
                toReplace.getParamNoTransform(i).treeCopyNoTransform(),
                result
            );
        }

        return result;
    }

    syn lazy Set<String> AnonymousFunctionDecl.getFreeVarNames() {
        Set<String> res = new HashSet<>(getPureExp().getFreeVars());
        for (ParamDecl param : getParams()) {
            res.remove(param.getName());
        }
        return res;
    }

    /**
    * Determines the free vars in this anonymous function's expression.
    * The resulting map maps from the name of the free var to a ParamDecl with a different (qualified) name.
    * @return an immutable map (free var name - closure param) with predictable iteration order
    */
    syn lazy Map<String, ParamDecl> AnonymousFunctionDecl.getFreeVars() {
        // Find the type of each free var and create a ParamDecl with it
        Map<String, ParamDecl> result = new LinkedHashMap<>();
        PureExp pureExp = getPureExp();
        for (String freeVar : getFreeVarNames()) {
            ParamDecl param = result.get(freeVar);
            if (param == null) {
                VarOrFieldDecl decl = pureExp.lookupVarOrFieldName(freeVar, false);
                if (decl == null) {
                    throw new PardefModellingException(pureExp, ErrorMessage.UNDECLARED_VARIABLE, freeVar);
                }
                String qualifiedName = qualifyName(freeVar);
                param = new ParamDecl(qualifiedName, decl.getType().toUse(), new List<Annotation>());
                result.put(freeVar, param);
            }
        }

        return Collections.unmodifiableMap(result);
    }

    public String AnonymousFunctionDecl.qualifyName(String name) {
        return StringUtils.capitalize(name) + "_" + getPureExpNoTransform().getExpId();
    }

    /**
    * Adds the closure params for this anonymous function to the given FunctionDecl.
    * If the params for this anonymous function's PureExp have already been added, this method will do nothing.
    * After adding the closure params to the function, this AnonymousFunctionDecl will be added to the passed list.
    *
    * <p>If the function contains any recursive calls, the closure params will be added.</p>
    *
    * @param added a list of anonymous functions that already added their closure params
    * @param func a function to add the closure params to
    */
    public void AnonymousFunctionDecl.addClosureParams(java.util.List<AnonymousFunctionDecl> added, FunctionDecl func) {
        for (AnonymousFunctionDecl anon : added) {
            if (anon.getPureExpNoTransform().getExpId().equals(this.getPureExpNoTransform().getExpId())) {
                // Closure params for this pure expression were already added
                return;
            }
        }

        java.util.List<FnApp> recursiveCalls = new LinkedList<>();
        for (FnApp call : TreeUtil.findChildren(func, FnApp.class)) {
            if (call.getName().equals(func.getName())) {
                recursiveCalls.add(call);
            }
        }

        List<ParamDecl> params = func.getParams();
        for (ParamDecl freeVar : getFreeVars().values()) {
            params.add(freeVar.treeCopyNoTransform());
            for (FnApp recursiveCall : recursiveCalls) {
                recursiveCall.addParam(new VarUse(freeVar.getName()));
            }
        }

        added.add(this);
    }

    /**
    * Adds the closure params for this anonymous function to the given ParFnApp.
    * If the params for this anonymous function's PureExp have already been added, this method will do nothing.
    * After adding the closure params to the function call, this AnonymousFunctionDecl will be added to the passed list.
    * @param added a list of anonymous functions that already added their closure params
    * @param func a function call to add the closure params to
    */
    public void AnonymousFunctionDecl.addClosureParams(java.util.List<AnonymousFunctionDecl> added, ParFnApp fnApp) {
        for (AnonymousFunctionDecl anon : added) {
            if (anon.getPureExpNoTransform().getExpId().equals(this.getPureExpNoTransform().getExpId())) {
                // Closure params for this pure expression were already added
                return;
            }
        }

        for (String freeVarName : getFreeVars().keySet()) {
            fnApp.addParam(new VarUse(freeVarName));
        }

        added.add(this);
    }

    /**
    * Stores the IDs for all pure expressions. Keys are the pretty-printed pure expressions.
    */
    static Map<String, String> PureExp.pureExpIds = new HashMap<>(256);

    /**
    * Determines an ID for this pure expression.
    * IDs are guaranteed to be the same for expressions which are syntactically identical and
    * to be different for expressions that are not.
    */
    syn lazy String PureExp.getExpId() {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        this.doPrettyPrint(pw, new DefaultABSFormatter(pw));
        String prettyPrinted = sw.toString();
        String id = PureExp.pureExpIds.get(prettyPrinted);
        if (id == null) {
            id = Integer.toString(PureExp.pureExpIds.size());
            PureExp.pureExpIds.put(prettyPrinted, id);
        }
        return id;
    }
}
