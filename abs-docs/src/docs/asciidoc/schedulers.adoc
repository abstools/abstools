[[sec:schedulers]]
== User-Defined Schedulers

User-defined schedulers are an experimental feature of Timed ABS.  They are
available on the Maude and Erlang backends.  This section describes the
current state of the implementation on the Erlang backend.

All identifiers introduced in this section reside in the `ABS.Scheduler`
module, which is not imported by default.


=== Defining Schedulers

A scheduler is a function that takes a list of processes and chooses one of
them.  Schedulers are ordinary ABS functions.

The following two example schedulers illustrate the concept.  The first,
deterministic scheduler takes the first process off the list; the second
scheduler chooses a non-deterministic one.

[source]
.Example
----
def Process defaultscheduler(List<Process> queue) = head(queue);

def Process randomscheduler(List<Process> queue) = nth(queue, random(length(queue)));
----

It is possible to formulate an Earliest Deadline First (EDF) scheduler in ABS:

[source]
.Example
----
def Process earliest_deadline_scheduler(List<Process> queue) =
  foldl((Process a, Process b) =>
      if durationLessThan(proc_deadline(a), proc_deadline(b)) // a < b
      then a else b)
    (queue, head(queue));
----


All schedulers must have a result type `Process` or `Maybe<Process>` and must
take an argument of type `List<Process>` as their first argument.

If `Maybe<Process>` is used as a return type, the user-defined scheduler can
decide not to schedule any process by returning `Nothing`.
That is, if a user-defined scheduler returns `Nothing` then the ABS model
behaves as if there are no processes that can be scheduled for the COG at the
time.
In that case, the scheduler will be invoked again if:

* An asynchronous call is performed on an object of the cog, or
* some future that a process of the cog was awaiting is resolved, or
* a `duration` or a resource that the cog was waiting for completes / is
  refilled.

NOTE: The `Maybe<Process>` return type is supported by the Erlang backend only.

[[sec:process-attributes]]
=== Processes and Process Attributes

A _process_ is an ABS abstract datatype; i.e., there is no constructor
available to create a `Process` value inside ABS.  Processes are created by
the runtime and handed to schedulers.

Processes have _attributes_ which can be used by schedulers to choose the next
process to run.  For example, a scheduler could always prefer processes that
run a certain method.  The following attributes are available:

[options="header"]
|=======================
|Name |Type |Meaning
|`method` |`String` |Name of the method executed by the process
|`arrival` |`Time` |Time when method call was issued
|`proc_deadline` |`Duration` | The (current) deadline value of the process (`InfDuration` if none)
|=======================

NOTE: The attributes `cost`, `start`, `crit` are available in
the Maude backend only but will be implemented in the Erlang backend as well.
The attributes `value`, `finish` are under consideration since their
usefulness is questionable.
// Duration cost(Process p) = builtin;
// Duration proc_deadline(Process p) = builtin;
// Time start(Process p) = builtin;
// Time finish(Process p) = builtin;
// Bool crit(Process p) = builtin;
// Int value(Process p) = builtin;

=== Using Schedulers

Schedulers apply to _cogs_ since cogs are responsible for scheduling one of
their processes when idle.  Since cogs are created via `new` expressions, a
scheduler can be given at that point via an annotation.  Classes can have a
_default scheduler_ that is given as an annotation to the class definition;
any cog created when instantiating this class will have that scheduler by
default (unless overridden by an annotation at the `new` expression).

The following example shows how to define a class that uses the
`randomscheduler` by default.  The first argument (the list of processes) must
have the name `queue`.

[source]
.Example
----
[Scheduler: defaultscheduler(queue)] class C implements I {
  ...
}
----

The following example shows how to create a cog with a different scheduler.

[source]
.Example
----
   [Scheduler: randomscheduler(queue)] I instance = new C();
----

For schedulers with more than one argument, values for subsequent arguments
are filled with the value of object fields of the same name current at
scheduling time.  The object whose fields are used is the first object in a
cog, i.e., the object created via the `new` expression that created the cog.
Subseqent objects created in that cog via `new local` cannot influence the
scheduler.

[source]
.Example
----
module Test;
import * from ABS.StdLib.Scheduler;

class C {
  Bool flag = False; <1>
}

def Process some_scheduler(List<Process> queue, Bool value) = head(queue); <2>

{
  [Scheduler: some_scheduler(queue, flag)] new C(); <3>
}
----
<1> Here, class `C` defines a field called `flag`
<2> The scheduler `some_scheduler` has a second argument of type `Bool`
<3> The current value of field `flag` will used as the second argument to `some_scheduler`

The `Maybe<Process>` return type of schedulers can be utilized to enforce a
specific process activation order.
That is, the class `SharedResourceImpl` in the following example enforces that
its methods `connect()`, `performAction()`, and `disconnect()` can only ever be
executed in this order.
For example, if `connect()` has not run yet, then the scheduler of
`SharedResourceImpl` will not activate any method execution, until an
activation for `connect()` is available:

[source]
.Example
----
module MainMod;
import * from ABS.Scheduler;

def Maybe<Process> resourceScheduler(List<Process> queue, Object connection) =
  when method(head(queue)) == ".init" then Just(head(queue)) else <1>
    let List<Process> permittedActivations = filter( <2>
        (Process p) => 
          when (connection == null) then
            method(p) == "connect"
          else
            method(p) == "performAction" || method(p) == "disconnect" 
      )(queue)
    in
      case permittedActivations {
        Nil => Nothing | <3>
        Cons(p, _) => Just(
          head(permittedActivations)
        )
      };

interface SharedResource {
  Unit connect();
  Unit performAction();
  Unit disconnect();
}

class Connection {}

[Scheduler: resourceScheduler(queue, connection)]
class SharedResourceImpl implements SharedResource {
  Object connection;

  Unit connect() { connection = new Connection(); println("connect"); }
  Unit performAction()  { println("performAction"); }
  Unit disconnect() { connection = null; println("disconnect"); }
}
----
<1> `.init` must always be executed first.
<2> Here, we filter the available `Process` instances for those that can be
    executed in the current state.
<3> If no available activation is viable, the scheduler returns `Nothing`.
