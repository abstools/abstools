== ABS Backends

This section describes the available and supported backends for ABS.
Different backends have different purposes (simulation, code execution,
visualization).  Their respective section describes their features and usage.

The following table gives an overview of the features that different backends
have.

Real-Time ABS:: Simulating a dense-time clock, and language constructs
expressing delays and task deadlines.  Used for simulating time usage of ABS
models.
Resource Models:: Specification of resource availability (processor power,
bandwidth) of _Deployment Components_ and simulation of resource usage
deployed thereon.  Builds on the semantics of Real-Time ABS.
FLI:: Foreign-Language Interface, the ability to call backend-specific native
code from ABS.
User-defined Schedulers:: Specification of per-cog task priorities
using ABS functions.
Model API:: Interacting with a running ABS model via HTTP requests.

.Backend Capabilities
|===
| Backend | Maude | Erlang | Java


| Real-Time ABS
| yes
| yes
| yes

| Resource Models
| yes
| yes
| yes

| FLI
| -
| -
| yes

| User-defined Schedulers
| yes
| yes
| -

| Model API
| -
| yes
| -
| yes

|===


=== Maude Backend

The Maude backend is a high-level, executable semantics in rewriting logic of
the ABS language.  Due to its relatively compact nature, it serves as a
test-bed for new language features.

Executing a model on the Maude backend results in a complete snapshot of the system state after execution has finished.

The main drawback of the Maude backend is its relatively poor performance, making it not very suitable to simulate large models.

Features:

* CPU and bandwidth resources
* Simulation of resource usage on deployment components
* Timed semantics
* Executable formal semantics of the ABS language


==== How to run the Maude backend

Running a model on Maude involves compiling the code, then starting Maude with
the resulting file as input.

Compiling all files in the current directory into Maude is done with the following command:

  $ absc --maude *.abs -o model.maude

The model is started with the following commands:

  $ maude
  Maude> in model.maude
  Maude> frew start .

This sequence of commands starts Maude, then loads the compiled model and
starts it.  The resulting output is a dump of the complete system state after
execution of the model finishes.

In case of problems, check the following:

- `absc` should be in the path; check the `PATH` environment variable.
- `absfrontend.jar` should be in the environment variable `CLASSPATH`.


[[sec:erlang-backend]]
=== Erlang Backend

The Erlang backend runs ABS models on the Erlang virtual machine by
translating them into Erlang and combining them with a small runtime library
implementing key ABS concepts (cogs, futures, objects, method invocations) in
Erlang.

Executing an ABS model in Erlang currently returns the value of the last
statement of the main block; output via `ABS.StdLib.println` is printed on the
console.  For additional introspective and interactive capabilities, the
Erlang backend supports a Model API (see below).


==== How to run the Erlang backend

Running a model in Erlang involves compiling the ABS code, then compiling and
running the resulting Erlang code.

Compiling all files in the current directory into Erlang and starting the
resulting model is done with the following commands:

  $ absc --erlang *.abs
  $ gen/erl/run

This sequence of commands starts Erlang, then compiles the generated Erlang
code and starts it.  Type `gen/erl/run -h` for a list of options accepted by
the model.

==== Recording and replaying traces

ABS task scheduling is non-deterministic; i.e., when two tasks are enabled,
the cog will select an arbitrary one (but see <<sec:schedulers>>).  The erlang
backend can record a trace of scheduling decisions and replay it to precisely
reproduce the previous run.

To record a trace to a file `trace.json`, start the model with a parameter
`--record trace.json` or `-t trace.json`.

To replay an existing trace recorded in `trace.json`, start the model with
`--replay trace.json` or `-r trace.json`.

A trace can also be obtained from a running model via the Model API.  Assuming
the model is started on port 8080 (via a parameter `-p 8080`), the trace is
accessible at the url http://localhost:8080/trace.  A trace visualizer can be
found here: https://github.com/larstvei/ABS-traces.

==== Generating code coverage information

The Erlang backend can optionally generate code coverage information in a
format inspired by gnu `gcov` (see
https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html).  The coverage
information contains line numbers and execution count, but not the source code
itself.  This is sufficient for some tools to visualize code coverage, e.g.,
`cov-mode` for Emacs (https://github.com/AdamNiederer/cov).

To generate code coverage information, compile an abs model with the
`--debuginfo` switch, then run it as normal, i.e.,

  $ absc --erlang --debuginfo *.abs
  $ gen/erl/run

For each `.abs` file, running the model will generate a `.abs.gcov` file in
the directory `gen/erl/absmodel` after the simulation finishes.

=== Java Backend

The Java backend runs ABS models on the JVM by translating them into Java and
combining them with a runtime library implementing key ABS concepts.

==== How to run the Java backend

Compiling all files in the current directory into Java and starting the
resulting model is done with the following commands:

  $ absc --java *.abs -o model.jar
  $ java -jar model.jar

The first command compiles the ABS model, the second command starts Java and
runs the code contained in `model.jar`.  In case more than one abs file
contains a main block, an arbitrary main block is executed.

The source code of the generated classes can be inspected below the `gen/`
directory.

