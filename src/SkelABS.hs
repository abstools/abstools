module SkelABS where

-- Haskell module generated by the BNF converter

import AbsABS
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident str  -> failure x


transTypeIdent :: TypeIdent -> Result
transTypeIdent x = case x of
  TypeIdent str  -> failure x


transType :: Type -> Result
transType x = case x of
  TyUnit  -> failure x
  TyInt  -> failure x
  TyRat  -> failure x
  TyFut type'  -> failure x
  TyUnderscore  -> failure x
  TypeVar qualtype  -> failure x
  ArgType qualtype anntypes  -> failure x


transAnnType :: AnnType -> Result
transAnnType x = case x of
  AnnType anns type'  -> failure x


transQualType :: QualType -> Result
transQualType x = case x of
  QualType qualtypeidents  -> failure x


transQualTypeIdent :: QualTypeIdent -> Result
transQualTypeIdent x = case x of
  QualTypeIdent typeident  -> failure x


transProgram :: Program -> Result
transProgram x = case x of
  Prog moduledecl  -> failure x


transModuleDecl :: ModuleDecl -> Result
transModuleDecl x = case x of
  ModuleDecl qualtype exports imports anndecls maybeblock  -> failure x


transExport :: Export -> Result
transExport x = case x of
  ExportAny anyidents  -> failure x
  ExportAnyFrom anyidents qualtype  -> failure x
  ExportStar  -> failure x
  ExportStarFrom qualtype  -> failure x


transImportType :: ImportType -> Result
transImportType x = case x of
  ImportHaskell  -> failure x
  ImportABS  -> failure x


transImport :: Import -> Result
transImport x = case x of
  ImportAnyFrom importtype anyidents qualtype  -> failure x
  ImportStarFrom importtype qualtype  -> failure x


transAnyIdent :: AnyIdent -> Result
transAnyIdent x = case x of
  AnyIdentI id  -> failure x
  AnyIdentT typeident  -> failure x


transAnnDecl :: AnnDecl -> Result
transAnnDecl x = case x of
  AnnDecl anns decl  -> failure x


transDecl :: Decl -> Result
transDecl x = case x of
  TypeDecl typeident type'  -> failure x
  DataDecl typeident constridents  -> failure x
  ParDataDecl typeident typeidents constridents  -> failure x
  Fun type' id params funbody  -> failure x
  ParFun type' id typeidents params funbody  -> failure x
  InterfDecl typeident methsigs  -> failure x
  ExtendsDecl typeident qualtypes methsigs  -> failure x
  ClassDecl typeident bodydecls1 maybeblock2 bodydecls3  -> failure x
  ClassParamDecl typeident params bodydecls1 maybeblock2 bodydecls3  -> failure x
  ClassImplements typeident qualtypes bodydecls1 maybeblock2 bodydecls3  -> failure x
  ClassParamImplements typeident params qualtypes bodydecls1 maybeblock2 bodydecls3  -> failure x


transConstrIdent :: ConstrIdent -> Result
transConstrIdent x = case x of
  UnaryConstr typeident  -> failure x
  MultConstr typeident constrtypes  -> failure x


transConstrType :: ConstrType -> Result
transConstrType x = case x of
  EmptyConstrType type'  -> failure x
  RecordConstrType type' id  -> failure x


transMethSig :: MethSig -> Result
transMethSig x = case x of
  MethSig type' id params  -> failure x


transBodyDecl :: BodyDecl -> Result
transBodyDecl x = case x of
  FieldDecl type' id  -> failure x
  FieldDeclAss type' id pureexp  -> failure x
  MethDecl type' id params block  -> failure x


transBlock :: Block -> Result
transBlock x = case x of
  Block stms  -> failure x


transMaybeBlock :: MaybeBlock -> Result
transMaybeBlock x = case x of
  JustBlock block  -> failure x
  NoBlock  -> failure x


transFunBody :: FunBody -> Result
transFunBody x = case x of
  Builtin  -> failure x
  PureBody pureexp  -> failure x


transParam :: Param -> Result
transParam x = case x of
  Par anntype id  -> failure x


transPureExp :: PureExp -> Result
transPureExp x = case x of
  Let param pureexp1 pureexp2  -> failure x
  If pureexp1 pureexp2 pureexp3  -> failure x
  Case pureexp casebranchs  -> failure x
  EOr pureexp1 pureexp2  -> failure x
  EAnd pureexp1 pureexp2  -> failure x
  EEq pureexp1 pureexp2  -> failure x
  ENeq pureexp1 pureexp2  -> failure x
  ELt pureexp1 pureexp2  -> failure x
  ELe pureexp1 pureexp2  -> failure x
  EGt pureexp1 pureexp2  -> failure x
  EGe pureexp1 pureexp2  -> failure x
  EAdd pureexp1 pureexp2  -> failure x
  ESub pureexp1 pureexp2  -> failure x
  EMul pureexp1 pureexp2  -> failure x
  EDiv pureexp1 pureexp2  -> failure x
  EMod pureexp1 pureexp2  -> failure x
  ELogNeg pureexp  -> failure x
  EIntNeg pureexp  -> failure x
  ECall id pureexps  -> failure x
  ENaryCall id pureexps  -> failure x
  ELit literal  -> failure x
  EVar id  -> failure x
  EThis id  -> failure x
  EUnaryConstr qualtype  -> failure x
  EMultConstr qualtype pureexps  -> failure x


transCaseBranch :: CaseBranch -> Result
transCaseBranch x = case x of
  CBranch pattern pureexp  -> failure x


transPattern :: Pattern -> Result
transPattern x = case x of
  PIdent id  -> failure x
  PLit literal  -> failure x
  PUnaryConstr typeident  -> failure x
  PMultConstr typeident patterns  -> failure x
  PUnderscore  -> failure x


transStm :: Stm -> Result
transStm x = case x of
  SExp effexp  -> failure x
  SBlock stms  -> failure x
  SWhile pureexp stm  -> failure x
  SReturn exp  -> failure x
  SAss id exp  -> failure x
  SFieldAss id exp  -> failure x
  SDec type' id  -> failure x
  SDecAss type' id exp  -> failure x
  SIf pureexp stm  -> failure x
  SIfElse pureexp stm1 stm2  -> failure x
  SAwait guard  -> failure x
  SSuspend  -> failure x
  SSkip  -> failure x
  SAssert pureexp  -> failure x


transGuard :: Guard -> Result
transGuard x = case x of
  VarGuard id  -> failure x
  FieldGuard id  -> failure x
  ExpGuard pureexp  -> failure x
  AndGuard guard1 guard2  -> failure x


transLiteral :: Literal -> Result
transLiteral x = case x of
  LNull  -> failure x
  LThis  -> failure x
  LStr str  -> failure x
  LInt n  -> failure x


transEffExp :: EffExp -> Result
transEffExp x = case x of
  New type' pureexps  -> failure x
  NewLocal type' pureexps  -> failure x
  SyncCall pureexp id pureexps  -> failure x
  ThisSyncCall id pureexps  -> failure x
  AsyncCall pureexp id pureexps  -> failure x
  ThisAsyncCall id pureexps  -> failure x
  Get pureexp  -> failure x


transExp :: Exp -> Result
transExp x = case x of
  ExpP pureexp  -> failure x
  ExpE effexp  -> failure x


transAnn :: Ann -> Result
transAnn x = case x of
  SimpleAnn pureexp  -> failure x



