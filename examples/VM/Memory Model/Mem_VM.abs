module Communication;
export *;

data LocationT = LocationT(String name);
data Access   = Write(Thread, LocationT, Int value, Int) | Read(Thread, LocationT, Int);

def LocationT getLocation(Access acc) = case(acc) {
    Write(_,l,_,_) => l;
    Read(_,l,_)    => l;
};

interface Thread { }





module Mem;
export *;
import * from Communication;

configuration TSO = {WriteReadFeature, ReadEarlyFeature};
configuration PSO = {WriteReadFeature, WriteWriteFeature, ReadEarlyFeature};
configuration IBM370 = {WriteReadFeature};
configuration Demo = {DemoFeature}; 
configuration IBMDemo = {WriteReadFeature, DemoFeature}; 
configuration TSODemo = {WriteReadFeature, ReadEarlyFeature, DemoFeature}; 
configuration MaximalProduct = {ReadReadFeature, ReadWriteFeature, WriteWriteFeature, WriteReadFeature, ReadEarlyFeature};

def List<T> slice<T>(List<T> list, Int startPos, Int endPos) = sliceAux(list, startPos, endPos, 0);
def List<T> sliceAux<T>(List<T> list, Int startPos, Int endPos, Int it) =  when it > endPos then Nil
 else when it < startPos then sliceAux(tail(list), startPos, endPos, it + 1)
 else case list{
 	Cons(x, xs) => Cons(x ,sliceAux(xs, startPos, endPos, it + 1));
 	Nil => Nil;
 };
 
	
def Maybe<Int> getWriteValueFor(List<Access> list, LocationT loc, Thread tid) = getWriteForAux(list, loc, 0, tid);
def Maybe<Int> getWriteForAux(List<Access> list, LocationT loc, Int pos, Thread tid) = case list {
		Cons(x, xs) => case x {
			Write(tidW,locW,_,id) => when (locW == loc && tid == tidW) then Just(id) else getWriteForAux(xs, loc, pos+1, tid);
			_ => getWriteForAux(xs, loc, pos+1, tid);
		};
		Nil => Nothing;
	};
	
	
def Int getFirstRead(List<Int> list,List<Access> acc) = getFirstReadAux(list,acc,0);

def Int getFirstReadAux(List<Int> list, List<Access> acc, Int pos) = case list{
	Cons(x,xs) => case (nth(acc,x)){
		Read(_,_,_)    => pos;
		Write(_,_,_,_) => getFirstReadAux(xs,acc, pos+1);
	};
	Nil => 0;
};
	
	
unique interface MemoryI{
     Fut<Int> read(Thread t, LocationT loc);
     Unit write(Thread t, LocationT loc, Int val);
     
     Int const(Int i);
     Int internalRead(Int myId); //spec only
}

class Memory implements MemoryI {
	
     Int counter = 0;                                                                 //internal modeling of equality   
     List<Access> list = Nil;                                                         //access list
     Set<Int> done = EmptySet;                                                        //completed accesses
     Map<Int, Int> ret = EmptyMap;                                                    //maps access ids to return values
     Map<LocationT, Int> mem = put(put(EmptyMap, LocationT("w"), 0), LocationT("v"), 0); //actual memory
     
     //issues a read operation, returns the read value once the access has succeeded
     Fut<Int> read(Thread t, LocationT loc){
       Int myId = counter;
       list = appendright(list, Read(t, loc, myId));
       counter = counter + 1;
       Fut<Int> ff = this!internalRead(myId);
       return ff;
     }
     
     Int internalRead(Int myId){     
       await contains(done, myId);
       return lookupUnsafe(ret, myId);
     }
     
     //issues a write operation, returns immediately once the access is added to the access list
     Unit write(Thread t, LocationT loc, Int val){
       Int myId = counter;
       list = appendright(list, Write(t, loc, val, myId));     
       counter = counter + 1;
     }
     
     //for init
     Int const(Int i){
       return i;
     }
     
     
     List<Int> strategy(){
     	Int i = 0;
     	List<Int> allowed = Nil;
     	while(i < length(list)){
     		Bool add = True;
     		Int j = 0;
     		while(j < i){
     			Bool b = this.maySwap(nth(list,j),nth(list,i));
     			if(!b){
     				add = False;
     				j = length(list);
     			}
     			j = j +1;
     		}
     		if(add){ allowed = Cons(i, allowed);}
     		i = i + 1;
     	}
     	return allowed;
	 }
	 
	 Bool maySwap(Access a, Access b){
     	 Bool ret = False;  
     	switch (a) {
     		Read(t1,_,_)    => switch (b) {
     								Read(t2,_,_) => { ret = t1 != t2; }
     								Write(t2,_,_,_) => { ret = t1 != t2; }
     						  }
     		Write(t1,_,_,_) => switch (b) {
     								Read(t2,_,_) => { ret = t1 != t2; }
     								Write(t2,_,_,_) => { ret = t1 != t2; }
     						  }
     	}
     	return ret;
	 }
	 
	 Int getValueFor(Thread tid, LocationT loc, Int pos){
	 	return lookupUnsafe(mem, loc);
	 }
	 
	 Pair<Access, Int> getAccess(Int pos){
     	Access acc = nth(list, pos);
	    Int val = -1;
	    switch (acc) { 
	      	Write(_, _ ,vi, _) => {val = vi;}
	      	Read(tid, loc,_ ) => {val = this.getValueFor(tid, loc, pos);}
	    }
	    
     	this.list = concatenate(slice(list, 0, pos-1), slice(list, pos+1, length(list)));
     	return Pair(acc, val);
	 }
	 
	 Int retrieve(List<Int> myList){
	 	return head(myList);//nth(accList, random(length(list))); for less predictability
	 }
	 
     Unit run(){
     	while(True){
     	   	await list != Nil;	 
     	   	  
	       	List<Int> accList = this.strategy();
	       	Int pos = this.retrieve(accList);
	       	
	       	Pair<Access, Int> pp = this.getAccess(pos); 
	       	
	     	switch (fst(pp)) {
	     		Write(t, loc, val, id) => {
	     			done = insertElement(done, id);
	     			mem = put(mem, loc, val);
	     		}
	     		Read(t, loc, id)       => {
	     			done = insertElement(done, id);
			  		ret = put(ret, id, snd(pp));
	     	   	}
	     	}     	   
     	}
     }
}


features ReadReadFeature, ReadWriteFeature, WriteWriteFeature, WriteReadFeature, ReadEarlyFeature, DemoFeature
 with (DemoFeature || !DemoFeature);
 /**
Allows to reorder a read before a read
**/
delta ReadReadDelta;
modifies class Memory {
	 //gets first read, if no read in list, gets first write
     modifies Bool maySwap(Access a, Access b){
     	Bool rets = False;
        LocationT loca = getLocation(a);
        LocationT locb = getLocation(b);
        Bool last = original(a,b);
     	switch (a) {
     		Read(_,_,_)    => switch (b) {
     								Read(_,_,_) => {  rets = last || loca != locb; }
     								Write(_,_,_,_) => { rets = last;}
     						  }
     		Write(_,_,_,_) => { rets = last;}
     	}
     	return rets;
	 }
}
/**
Allows to reorder a write before a read
**/
delta ReadWriteDelta;
modifies class Memory {
	 //gets first read, if no read in list, gets first write
     modifies Bool maySwap(Access a, Access b){
     	Bool rets = False;  
        LocationT loca = getLocation(a);
        LocationT locb = getLocation(b);
        Bool last = original(a,b);
     	switch (a) {
     		Read(_,_,_)    => switch (b) {
     								Read(_,_,_) => { rets = last; }
     								Write(_,_,_,_) => {  rets = last || loca != locb; }
     						  }
     		Write(_,_,_,_) => { rets = last; }
     	}
     	return rets;
	 }
}
/**
Allows to reorder a read before a write
**/
delta WriteReadDelta;
modifies class Memory {
	 //gets first read, if no read in list, gets first write
     modifies Bool maySwap(Access a, Access b){
     	Bool rets = False;  
        LocationT loca = getLocation(a);
        LocationT locb = getLocation(b);
        Bool last = original(a,b);
     	switch (a) {
     		Read(_,_,_)    => { rets = last; }
     		Write(_,_,_,_) => switch (b) {
     								Read(_,_,_) => {  
     								                    rets = last || loca != locb; }
     								Write(_,_,_,_) => { rets = last; }
     						  }
     	}
     	return rets;
	 }
}

/**
Allows to reorder a read before a write
**/
delta WriteWriteDelta;
modifies class Memory {
	 //gets first read, if no read in list, gets first write
     modifies Bool maySwap(Access a, Access b){
     	Bool rets = False;  
        LocationT loca = getLocation(a);
        LocationT locb = getLocation(b);
        Bool last = original(a,b);
     	switch (a) {
     		Read(_,_,_)    => { rets = last; }
     		Write(_,_,_,_) => switch (b) {
     								Read(_,_,_) => { rets = last; }
     								Write(_,_,_,_) => {  rets = last || loca != locb; }
     						  }
     	}
     	return rets;
	 }
}

/**
Allows to reorder a read before a write
**/
delta WriteReadOwnDelta;
modifies class Memory {
	 //gets first read, if no read in list, gets first write
     modifies Bool maySwap(Access a, Access b){
     	Bool rets = False;  
        LocationT loca = getLocation(a);
        LocationT locb = getLocation(b);
        Bool last = original(a,b);
     	switch (a) {
     		Read(_,_,_)    => { rets = last; }
     		Write(_,_,_,_) => switch (b) {
     								Read(_,_,_) => { if(loca == locb) rets = True; else rets = last; }
     								Write(_,_,_,_) => { rets = last; }
     						  }
     	}
     	return rets;
	 }
}


/**
Instead of reading from the memory, the read may read from a write it is reorder before
**/
delta ReadEarlyLocalDelta;
modifies class Memory {
     modifies Int getValueFor(Thread tid, LocationT loc, Int pos){
     	List<Access> pre = slice(list, 0, pos-1);
     	Maybe<Int> ret = getWriteValueFor(pre, loc, tid);
     	Int i = -1;
     	switch (ret){
     		Just(val) => i = val;
     		Nothing   => i = original(tid, loc, pos);
     	}
		return i;
	 }
}

delta DemoDelta;
modifies class Memory {
     modifies Unit run(){
	 	await duration(3,3);
	 	original();
	 } 
	 
	 modifies Int retrieve(List<Int> myList){
	 	Int i = getFirstRead(reverse(myList), this.list);
	 	return i;
	 }
	 
}



delta ReadReadDelta when ReadReadFeature;
delta DemoDelta when DemoFeature;
delta ReadWriteDelta when ReadWriteFeature;
delta WriteWriteDelta when WriteWriteFeature;
delta WriteReadDelta  when WriteReadFeature;
delta ReadEarlyLocalDelta when ReadEarlyFeature;
delta WriteReadOwnDelta after WriteReadDelta when ReadEarlyFeature;

module Threads;
export *;
import * from Mem;
import * from Devices;
import * from Communication;

class Thread1(MemoryI mem, DeviceI other) implements Thread {
   Fut<Int> reg1;
             
   Unit run(){
     reg1 = mem!const(0);
     reg1.get;
     
     //duration(3,3); //duration enforces demo ordering
	 await mem!write(this,LocationT("w"),1);  
     reg1 = await mem!read(this,LocationT("v"));    
     Int i = reg1.get;
     println("thread1: "+toString(i));
   }
}

class Thread2(MemoryI mem, DeviceI other) implements Thread {
   Fut<Int> reg1;
     
   Unit run(){
     reg1 = mem!const(0);
     reg1.get;

	 await mem!write(this,LocationT("v"),1);  
     reg1 = await mem!read(this,LocationT("w"));  
     Int i = reg1.get;
     await other!directSaveMainThread("v", i);
     println("thread2: "+toString(i));
   }
}

module Devices;
export *;
import * from Communication;
import * from Threads;
import * from Mem;

unique interface DevicePairI{ }

unique interface DeviceI{
    Unit directSaveMainThread(String loc, Int val);
    Unit setOther(DeviceI newOther);
    Unit launch(MemoryI newMem);
}

unique class Device implements DeviceI {
    DeviceI other = null;
    MemoryI mem = null;
    Thread t1 = null;
    Thread t2 = null;
    Unit setOther(DeviceI newOther){ this.other = newOther; }
    Unit launch(MemoryI newMem){
        this.mem = newMem;
        this.t1 = new Thread1(mem, other);
        this.t2 = new Thread2(mem, other);
    }
    Unit directSaveMainThread(String loc, Int val){
        await mem!write(t1,LocationT(loc),val);
    }
}

class DevicePair implements DevicePairI {
    MemoryI mem1 = null;
    MemoryI mem2 = null;
    DeviceI d1 = null;
    DeviceI d2 = null;
    Unit run(){
        this.d1 = new Device();
        this.d2 = new Device();
        this.setupDevice1();
        this.setupDevice2();
        d1.setOther(d2);
        d2.setOther(d1);
        d1!launch(mem1);
        d2!launch(mem2);
    }

    Unit setupDevice1(){
	 	  this.mem1 = null; //new Memory(); //with MaximalProduct;
    }

    Unit setupDevice2(){
	 	 this.mem1 = null; //new Memory();
    }
}


features FPSO1, FPSO2, FTSO1, FTSO2, FIBM1, FIBM2, FMax1, FMax2 with FMax1 || !FMax1;

delta Max1;
modifies class DevicePair {
    modifies Unit setupDevice1(){ this.mem1 = new Memory() with MaximalProduct; }          
}
delta Max2;
modifies class DevicePair {
    modifies Unit setupDevice2(){ this.mem2 = new Memory() with MaximalProduct; }          
}
delta IBM1;
modifies class DevicePair {
    modifies Unit setupDevice1(){ this.mem1 = new Memory() with IBM370; }          
}
delta IBM2;
modifies class DevicePair {
    modifies Unit setupDevice2(){ this.mem2 = new Memory() with IBM370; }          
}
delta TSO1;
modifies class DevicePair {
    modifies Unit setupDevice1(){ this.mem1 = new Memory() with TSO; }          
}
delta TSO2;
modifies class DevicePair {
    modifies Unit setupDevice2(){ this.mem2 = new Memory() with TSO; }          
}
delta PSO1;
modifies class DevicePair {
    modifies Unit setupDevice1(){ this.mem1 = new Memory() with PSO; }          
}
delta PSO2;
modifies class DevicePair {
    modifies Unit setupDevice2(){ this.mem2 = new Memory() with PSO; }          
}

delta IBM1 when FIBM1;
delta IBM2 when FIBM2;
delta TSO1 when FTSO1;
delta TSO2 when FTSO2;
delta PSO1 when FPSO1;
delta PSO2 when FPSO2;
delta Max1 when FMax1;
delta Max2 when FMax2;

module Main;
import * from Devices;
import * from Mem;
import * from Communication;

class Application{ 
	Unit run(){
        DevicePairI p1 = new DevicePair() with {FMax1, FIBM2};
        DevicePairI p2 = new DevicePair() with {FTSO1, FPSO2};
	}
}

{
   new Application();
}
