module HTest;

// Maps
data Map<A, B> = EmptyMap | InsertAssoc(Pair<A, B>, Map<A, B>);
 // map constructor helper (does not preserve injectivity)

def Map<A, B> put<A, B>(Map<A, B> ms, A k, B v) =
  case ms {
    EmptyMap => InsertAssoc(Pair(k, v),EmptyMap);
    InsertAssoc(Pair(k, _), ts) => InsertAssoc(Pair(k, v), ts);
    InsertAssoc(p, ts) => InsertAssoc(p, put(ts, k, v));
  };

def B lookupUnsafe<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  fromJust(lookup(ms,k));
  
def Maybe<B> lookup<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  case ms {
     InsertAssoc(Pair(k, y), _) => Just(y);
     InsertAssoc(_, tm) => lookup(tm, k);
     EmptyMap => Nothing;
  };

interface IArray{
	Int sum();
}

class Array (Int n)implements IArray{
	Int i=0;
	Int s=0;
		
	Map<Int,Int> m = EmptyMap;
	
	{
	while (this.i<=this.n){
		Int a = this.i*this.n;
		this.m = put(this.m,this.i, a);
		this.i=this.i+1;
	}
	}
	
	Int sum(){
		this.i=0;
		while (this.i<=this.n){
			this.s=this.s+ lookupUnsafe(this.m,this.i);	
			this.i=this.i+1;
		}	
		return this.s;
	}
			 
}


{
IArray a1 = new Array(1000);
IArray a2 = new Array(1000);
IArray a3 = new Array(1000);
IArray a4 = new Array(1000);

// IArray a3 = new local Array(1000);

Fut<Int> f1 = a1!sum();
Fut<Int> f2 = a2!sum();
Fut<Int> f3 = a3!sum();
Fut<Int> f4 = a4!sum();

// Int x = a3.sum();

Int res1 = f1.get;
Int res2 = f2.get;
Int res3 = f3.get;
Int res4 = f4.get;

assert res1 == 500500000;
assert res2 == 500500000;
assert res3 == 500500000;
assert res4 == 500500000;

}

